<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Stf CS149 Parallel Programming - Assign2 | Zhutao Zhuang </title> <meta name="author" content="Zhutao Zhuang"> <meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. "> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://bilyz98.github.io/blog/2024/cs149-assign2/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Zhutao</span> Zhuang </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Stf CS149 Parallel Programming - Assign2</h1> <p class="post-meta"> Created in October 26, 2024 </p> <p class="post-tags"> <a href="/blog/2024"> <i class="fa-solid fa-calendar fa-sm"></i> 2024 </a>   ·   <a href="/blog/tag/parallel"> <i class="fa-solid fa-hashtag fa-sm"></i> parallel</a>   <a href="/blog/tag/programming"> <i class="fa-solid fa-hashtag fa-sm"></i> programming</a>   ·   <a href="/blog/category/parallel"> <i class="fa-solid fa-tag fa-sm"></i> parallel</a>   <a href="/blog/category/programming"> <i class="fa-solid fa-tag fa-sm"></i> programming</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <h1 id="thread-pool-for-task-scheduling">Thread pool for task scheduling</h1> <h2 id="step1--parallel-thread-spawn">Step1 : parallel thread spawn</h2> <p>First implementaion that spawns new thread for each task:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">TaskSystemParallelSpawn</span><span class="o">::</span><span class="n">run</span><span class="p">(</span><span class="n">IRunnable</span><span class="o">*</span> <span class="n">runnable</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_total_tasks</span><span class="p">)</span> <span class="p">{</span>


    <span class="c1">//</span>
    <span class="c1">// TODO: CS149 students will modify the implementation of this</span>
    <span class="c1">// method in Part A.  The implementation provided below runs all</span>
    <span class="c1">// tasks sequentially on the calling thread.</span>
    <span class="c1">//</span>

    <span class="c1">// for (int i = 0; i &lt; num_total_tasks; i++) {</span>
    <span class="c1">//     runnable-&gt;runTask(i, num_total_tasks);</span>
    <span class="c1">// }</span>

  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">workers</span><span class="p">[</span><span class="n">num_threads_</span><span class="p">];</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="n">num_total_tasks</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span> <span class="n">num_threads_</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">cur_end</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">num_threads_</span> <span class="o">&lt;</span> <span class="n">num_total_tasks</span><span class="p">)</span> <span class="o">?</span> <span class="n">i</span><span class="o">+</span><span class="n">num_threads_</span> <span class="o">:</span> <span class="n">num_total_tasks</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">cur_begin</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">t_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">cur_begin</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">cur_end</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">,</span> <span class="n">t_idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
       <span class="n">workers</span><span class="p">[</span><span class="n">t_idx</span><span class="p">]</span><span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">runTask</span><span class="p">,</span> <span class="n">runnable</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">num_total_tasks</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">t_idx</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">cur_begin</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">cur_end</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">,</span> <span class="n">t_idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">workers</span><span class="p">[</span><span class="n">t_idx</span><span class="p">].</span><span class="n">join</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Result: Not good. Very slow. I think this is because of frequent thread spawn overhead.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(base) ➜  part_a git:(master) ✗ python3 ../tests/run_test_harness.py -n 8 -t  super_light super_super_light
runtasks_ref
Linux x86_64
================================================================================
Running task system grading harness... (2 total tests)
  - Detected CPU with 40 execution contexts
  - Task system configured to use at most 8 threads
================================================================================
================================================================================
Executing test: super_super_light...
Reference binary: ./runtasks_ref_linux
Results for: super_super_light
                                        STUDENT   REFERENCE   PERF?
[Serial]                                12.239    12.216      1.00  (OK)
[Parallel + Always Spawn]               444.19    53.469      8.31  (NOT OK)
[Parallel + Thread Pool + Spin]         12.121    25.723      0.47  (OK)
[Parallel + Thread Pool + Sleep]        12.106    24.976      0.48  (OK)
================================================================================
</code></pre></div></div> <p>Solution 2 : Created <code class="language-plaintext highlighter-rouge">num_threads</code> at the beginning of <code class="language-plaintext highlighter-rouge">run</code> call and reuse all of them. Use atomic counter to asggub unique id to each runnalbe call.</p> <p>Code :</p> <p>Notice that that we have to set <code class="language-plaintext highlighter-rouge">my_counter_=0</code> at the beginning of each run call.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">TaskSystemParallelSpawn</span><span class="o">::</span><span class="n">run</span><span class="p">(</span><span class="n">IRunnable</span><span class="o">*</span> <span class="n">runnable</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_total_tasks</span><span class="p">)</span> <span class="p">{</span> 
  <span class="n">my_counter_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">workers</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="n">num_threads_</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">workers</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">([</span><span class="k">this</span><span class="p">,</span> <span class="n">runnable</span><span class="p">,</span> <span class="n">num_total_tasks</span><span class="p">]</span> <span class="p">{</span>
      <span class="k">this</span><span class="o">-&gt;</span><span class="n">threadTask</span><span class="p">(</span><span class="n">runnable</span><span class="p">,</span> <span class="n">num_total_tasks</span><span class="p">);</span>
    <span class="p">});</span>

  <span class="p">}</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_threads_</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">workers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">join</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>===================================================================================
(base) ➜  part_a git:(master) ✗ python3 ../tests/run_test_harness.py -n 8 -t  super_light super_super_light
runtasks_ref
Linux x86_64
================================================================================
Running task system grading harness... (2 total tests)
  - Detected CPU with 40 execution contexts
  - Task system configured to use at most 8 threads
================================================================================
================================================================================
Executing test: super_super_light...
Reference binary: ./runtasks_ref_linux
Results for: super_super_light
                                        STUDENT   REFERENCE   PERF?
[Serial]                                8.562     12.451      0.69  (OK)
[Parallel + Always Spawn]               56.804    54.287      1.05  (OK)
[Parallel + Thread Pool + Spin]         8.532     25.417      0.34  (OK)
[Parallel + Thread Pool + Sleep]        8.456     24.996      0.34  (OK)
================================================================================
Executing test: super_light...
Reference binary: ./runtasks_ref_linux
Results for: super_light
                                        STUDENT   REFERENCE   PERF?
[Serial]                                81.044    95.194      0.85  (OK)
[Parallel + Always Spawn]               55.138    83.604      0.66  (OK)
[Parallel + Thread Pool + Spin]         80.753    27.388      2.95  (NOT OK)
[Parallel + Thread Pool + Sleep]        80.646    33.46       2.41  (NOT OK)
================================================================================
Overall performance results
[Serial]                                : All passed Perf
[Parallel + Always Spawn]               : All passed Perf
[Parallel + Thread Pool + Spin]         : Perf did not pass all tests
[Parallel + Thread Pool + Sleep]        : Perf did not pass all tests
</code></pre></div></div> <h2 id="step2--threadpool--spinning-waiting">Step2 : threadpool + spinning waiting</h2> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void TaskSystemParallelThreadPoolSpinning::threadTask() {
      // bool done = done_.load();
  while(!done_.load()) {
    // printf("id: %d\n", id);
    mutex_.lock();
    threadArg arg;
    if(!task_queue_.empty()) {
      arg = task_queue_.front();
      task_queue_.pop_front();
    }
    mutex_.unlock();
    if(arg.runnable) {
      arg.runnable-&gt;runTask( arg.task_id, arg.num_total_tasks);
      finished_tasks_.fetch_add(1);
    }
  }

}
TaskSystemParallelThreadPoolSpinning::TaskSystemParallelThreadPoolSpinning(int num_threads): ITaskSystem(num_threads) {
    //
    // TODO: CS149 student implementations may decide to perform setup
    // operations (such as thread pool construction) here.
    // Implementations are free to add new class member variables
    // (requiring changes to tasksys.h).
    //
  done_ = false;
  num_threads_ = num_threads;
  for(int i=0; i &lt; num_threads_; i++) {
    workers_.emplace_back([this ]{
      this-&gt;threadTask();
    });
  }

}

TaskSystemParallelThreadPoolSpinning::~TaskSystemParallelThreadPoolSpinning() {
  done_.store(true);
  for(int i=0; i&lt; num_threads_; i++) {
    workers_[i].join();
  }
}

void TaskSystemParallelThreadPoolSpinning::run(IRunnable* runnable, int num_total_tasks) {


    //
    // TODO: CS149 students will modify the implementation of this
    // method in Part A.  The implementation provided below runs all
    // tasks sequentially on the calling thread.
    //

  finished_tasks_ = 0;
  {
  const std::lock_guard&lt;std::mutex&gt; lock(mutex_);
  for(int i=0; i &lt; num_total_tasks; i++) {
      threadArg arg(i, num_total_tasks, runnable);
    task_queue_.emplace_back(arg);
  }
  }
  
  while(finished_tasks_.load() != num_total_tasks) {

  }

}
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(base) ➜  part_a git:(master) ✗ python3 ../tests/run_test_harness.py -n 8
runtasks_ref
Linux x86_64
================================================================================                              Running task system grading harness... (11 total tests)
- Detected CPU with 40 execution contexts
  - Task system configured to use at most 8 threads
================================================================================
================================================================================                                                                             Executing test: super_super_light...
Reference binary: ./runtasks_ref_linux
Results for: super_super_light
                                        STUDENT   REFERENCE   PERF?
[Serial]                                8.574     12.343      0.69  (OK)
[Parallel + Always Spawn]               56.938    54.949      1.04  (OK)
[Parallel + Thread Pool + Spin]         21.404    25.716      0.83  (OK)
[Parallel + Thread Pool + Sleep]        8.704     17.781      0.49  (OK)
================================================================================
Executing test: super_light...
Reference binary: ./runtasks_ref_linux
Results for: super_light
                                        STUDENT   REFERENCE   PERF?
[Serial]                                80.252    94.107      0.85  (OK)
[Parallel + Always Spawn]               73.338    83.35       0.88  (OK)
[Parallel + Thread Pool + Spin]         27.698    36.119      0.77  (OK)
[Parallel + Thread Pool + Sleep]        80.795    34.28       2.36  (NOT OK)
================================================================================
Executing test: ping_pong_equal...
Reference binary: ./runtasks_ref_linux
Results for: ping_pong_equal
                                        STUDENT   REFERENCE   PERF?
[Serial]                                1297.763  1553.482    0.84  (OK)
[Parallel + Always Spawn]               574.729   649.785     0.88  (OK)
[Parallel + Thread Pool + Spin]         187.65    232.88      0.81  (OK)
[Parallel + Thread Pool + Sleep]        1294.887  226.363     5.72  (NOT OK)
================================================================================
Executing test: ping_pong_unequal...
Reference binary: ./runtasks_ref_linux
Results for: ping_pong_unequal
                                        STUDENT   REFERENCE   PERF?
[Serial]                                2405.604  2401.768    1.00  (OK)
[Parallel + Always Spawn]               969.55    1021.323    0.95  (OK)
[Parallel + Thread Pool + Spin]         336.518   332.326     1.01  (OK)
[Parallel + Thread Pool + Sleep]        2396.002  338.008     7.09  (NOT OK)
================================================================================
Executing test: recursive_fibonacci...
Reference binary: ./runtasks_ref_linux
Results for: recursive_fibonacci
                                        STUDENT   REFERENCE   PERF?
[Serial]                                1578.621  1938.967    0.81  (OK)
[Parallel + Always Spawn]               482.274   548.912     0.88  (OK)
[Parallel + Thread Pool + Spin]         222.252   266.043     0.84  (OK)
[Parallel + Thread Pool + Sleep]        1583.164  266.454     5.94  (NOT OK)
================================================================================
Executing test: math_operations_in_tight_for_loop...
Reference binary: ./runtasks_ref_linux
Results for: math_operations_in_tight_for_loop
                                        STUDENT   REFERENCE   PERF?
[Serial]                                808.052   833.969     0.97  (OK)
[Parallel + Always Spawn]               651.691   705.552     0.92  (OK)
[Parallel + Thread Pool + Spin]         139.645   154.966     0.90  (OK)
[Parallel + Thread Pool + Sleep]        802.654   157.355     5.10  (NOT OK)
================================================================================
================================================================================
Executing test: math_operations_in_tight_for_loop_fewer_tasks...
Reference binary: ./runtasks_ref_linux
Results for: math_operations_in_tight_for_loop_fewer_tasks
                                        STUDENT   REFERENCE   PERF?
[Serial]                                806.914   839.226     0.96  (OK)
[Parallel + Always Spawn]               809.429   810.212     1.00  (OK)
[Parallel + Thread Pool + Spin]         215.631   238.903     0.90  (OK)
[Parallel + Thread Pool + Sleep]        805.115   244.607     3.29  (NOT OK)
================================================================================
Executing test: math_operations_in_tight_for_loop_fan_in...
Reference binary: ./runtasks_ref_linux
Results for: math_operations_in_tight_for_loop_fan_in
                                        STUDENT   REFERENCE   PERF?
[Serial]                                416.313   428.492     0.97  (OK)
[Parallel + Always Spawn]               133.057   160.116     0.83  (OK)
[Parallel + Thread Pool + Spin]         71.286    74.03       0.96  (OK)
[Parallel + Thread Pool + Sleep]        412.149   81.239      5.07  (NOT OK)
================================================================================
Executing test: math_operations_in_tight_for_loop_reduction_tree...
Reference binary: ./runtasks_ref_linux
Results for: math_operations_in_tight_for_loop_reduction_tree
                                        STUDENT   REFERENCE   PERF?
[Serial]                                415.842   428.485     0.97  (OK)
[Parallel + Always Spawn]               142.34    191.563     0.74  (OK)
[Parallel + Thread Pool + Spin]         70.203    65.066      1.08  (OK)
[Parallel + Thread Pool + Sleep]        411.849   67.231      6.13  (NOT OK)
================================================================================
Executing test: spin_between_run_calls...
Reference binary: ./runtasks_ref_linux
Results for: spin_between_run_calls
                                        STUDENT   REFERENCE   PERF?
[Serial]                                540.34    687.538     0.79  (OK)
[Parallel + Always Spawn]               290.111   364.247     0.80  (OK)
[Parallel + Thread Pool + Spin]         295.734   373.543     0.79  (OK)
[Parallel + Thread Pool + Sleep]        538.037   364.643     1.48  (NOT OK)
================================================================================
Executing test: mandelbrot_chunked...
Reference binary: ./runtasks_ref_linux
Results for: mandelbrot_chunked
                                        STUDENT   REFERENCE   PERF?
[Serial]                                526.695   537.581     0.98  (OK)
[Parallel + Always Spawn]               79.414    78.909      1.01  (OK)
[Parallel + Thread Pool + Spin]         83.16     77.74       1.07  (OK)
[Parallel + Thread Pool + Sleep]        530.464   85.143      6.23  (NOT OK)
================================================================================
Overall performance results
[Serial]                                : All passed Perf
[Parallel + Always Spawn]               : All passed Perf
[Parallel + Thread Pool + Spin]         : All passed Perf
[Parallel + Thread Pool + Sleep]        : Perf did not pass all tests
</code></pre></div></div> <h2 id="step3-threadpool--put-threads-to-sleep-when-there-is-nothing-to-do">Step3: Threadpool + put threads to sleep when there is nothing to do</h2> <p>Implementation :</p> <p>Notice that we have to test if each thread is joinable and call <code class="language-plaintext highlighter-rouge">join()</code> at the destructor of the class.</p> <p>Because each thread might have already exited when <code class="language-plaintext highlighter-rouge">done_</code> is set to <code class="language-plaintext highlighter-rouge">true</code></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">TaskSystemParallelThreadPoolSleeping</span><span class="o">::</span><span class="n">threadTask</span><span class="p">(</span> <span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">num_task</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">done_</span><span class="p">.</span><span class="n">load</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mutex_</span><span class="p">);</span>
    <span class="n">threadArg</span> <span class="n">arg</span> <span class="p">;</span> 
    <span class="kt">bool</span> <span class="n">get_task</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">task_queue_</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">arg</span> <span class="o">=</span> <span class="n">task_queue_</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
      <span class="n">task_queue_</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
      <span class="n">get_task</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
      <span class="c1">// printf("get task\n");</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">cv_</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">lock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="n">get_task</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">arg</span><span class="p">.</span><span class="n">runnable</span><span class="o">-&gt;</span><span class="n">runTask</span><span class="p">(</span><span class="n">arg</span><span class="p">.</span><span class="n">task_id</span><span class="p">,</span> <span class="n">arg</span><span class="p">.</span><span class="n">num_total_tasks</span><span class="p">);</span>
      <span class="n">num_task</span> <span class="o">=</span> <span class="n">arg</span><span class="p">.</span><span class="n">num_total_tasks</span><span class="p">;</span>
      <span class="n">finished_tasks_</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
      <span class="k">if</span><span class="p">(</span><span class="n">finished_tasks_</span><span class="p">.</span><span class="n">load</span><span class="p">()</span> <span class="o">==</span> <span class="n">num_task</span><span class="p">)</span>  <span class="p">{</span>
        <span class="c1">// printf("send notify\n");</span>
        <span class="n">cv_</span><span class="p">.</span><span class="n">notify_all</span><span class="p">();</span>
      <span class="p">}</span>
    <span class="p">}</span>
 
  <span class="p">}</span>
<span class="p">}</span>
<span class="n">TaskSystemParallelThreadPoolSleeping</span><span class="o">::</span><span class="n">TaskSystemParallelThreadPoolSleeping</span><span class="p">(</span><span class="kt">int</span> <span class="n">num_threads</span><span class="p">)</span><span class="o">:</span> <span class="n">ITaskSystem</span><span class="p">(</span><span class="n">num_threads</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//</span>
    <span class="c1">// TODO: CS149 student implementations may decide to perform setup</span>
    <span class="c1">// operations (such as thread pool construction) here.</span>
    <span class="c1">// Implementations are free to add new class member variables</span>
    <span class="c1">// (requiring changes to tasksys.h).</span>
    <span class="c1">//</span>
  <span class="n">num_threads_</span> <span class="o">=</span> <span class="n">num_threads</span><span class="p">;</span>
  <span class="n">done_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="n">num_threads_</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
    <span class="n">workers_</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">([</span><span class="k">this</span><span class="p">]{</span>
      <span class="k">this</span><span class="o">-&gt;</span><span class="n">threadTask</span><span class="p">();</span>
    <span class="p">});</span>
  <span class="p">}</span>

<span class="p">}</span>

<span class="n">TaskSystemParallelThreadPoolSleeping</span><span class="o">::~</span><span class="n">TaskSystemParallelThreadPoolSleeping</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">//</span>
    <span class="c1">// TODO: CS149 student implementations may decide to perform cleanup</span>
    <span class="c1">// operations (such as thread pool shutdown construction) here.</span>
    <span class="c1">// Implementations are free to add new class member variables</span>
    <span class="c1">// (requiring changes to tasksys.h).</span>
    <span class="c1">//</span>
  <span class="n">done_</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
  <span class="n">cv_</span><span class="p">.</span><span class="n">notify_all</span><span class="p">();</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_threads_</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">workers_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">joinable</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">workers_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">join</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">TaskSystemParallelThreadPoolSleeping</span><span class="o">::</span><span class="n">run</span><span class="p">(</span><span class="n">IRunnable</span><span class="o">*</span> <span class="n">runnable</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_total_tasks</span><span class="p">)</span> <span class="p">{</span>


    <span class="c1">//</span>
    <span class="c1">// TODO: CS149 students will modify the implementation of this</span>
    <span class="c1">// method in Parts A and B.  The implementation provided below runs all</span>
    <span class="c1">// tasks sequentially on the calling thread.</span>
    <span class="c1">//</span>

  <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mutex_</span><span class="p">);</span>
  <span class="n">finished_tasks_</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_total_tasks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">threadArg</span> <span class="n">arg</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">num_total_tasks</span><span class="p">,</span> <span class="n">runnable</span><span class="p">);</span>
    <span class="n">task_queue_</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="c1">// printf("before notify all\n");</span>
  <span class="n">lock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
  <span class="n">cv_</span><span class="p">.</span><span class="n">notify_all</span><span class="p">();</span>
  <span class="n">lock</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>

  
  <span class="k">while</span><span class="p">(</span><span class="n">finished_tasks_</span><span class="p">.</span><span class="n">load</span><span class="p">()</span> <span class="o">!=</span> <span class="n">num_total_tasks</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cv_</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// printf("finished_tasks_:%d\n", finished_tasks_.load());</span>

<span class="p">}</span>
</code></pre></div></div> <h2 id="part-b-threadpoll--async-call-w">Part B: threadpoll + async call w</h2> <p>This line of code is important.</p> <p>We have two conditions to check for <code class="language-plaintext highlighter-rouge">cv_.wait()</code>. <code class="language-plaintext highlighter-rouge">cv_.wait()</code> will check the condition each time it wakes up and it would stop waiting when the condition is true.</p> <p>This can help save time for further unncessary condition checking in the while loop.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      cv_.wait(lock, [this]{return !ready_queue_.empty() || done_ ;});
</code></pre></div></div> <p>Another change I make compared to previous version of code is that I use <code class="language-plaintext highlighter-rouge">bool</code> intead of <code class="language-plaintext highlighter-rouge">std::atomic&lt;bool&gt;</code> to store <code class="language-plaintext highlighter-rouge">done_</code> variable which indicates whether the class is destructed.</p> <p><code class="language-plaintext highlighter-rouge">done_</code> variable is set to true without lock protection in destructor if its type is <code class="language-plaintext highlighter-rouge">std::atomic&lt;bool&gt;</code> which means that thread might miss the <code class="language-plaintext highlighter-rouge">notify_all()</code> call from destructor and those worker threads would never be woke up and exit .</p> <p>After change <code class="language-plaintext highlighter-rouge">done_</code> to type <code class="language-plaintext highlighter-rouge">bool</code>, we are guaranteed that all threads would receive the <code class="language-plaintext highlighter-rouge">notify_all()</code> call because the destructor holds the lock first and then set <code class="language-plaintext highlighter-rouge">done_</code> to <code class="language-plaintext highlighter-rouge">true</code> and then notify_all();</p> <p>The guarantees the order of instructions.</p> <p>Issue: Test can not pass with 4 threads.</p> <p>Investigation is ongoing.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TaskSystemParallelThreadPoolSleeping</span><span class="o">::~</span><span class="n">TaskSystemParallelThreadPoolSleeping</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">//</span>
    <span class="c1">// TODO: CS149 student implementations may decide to perform cleanup</span>
    <span class="c1">// operations (such as thread pool shutdown construction) here.</span>
    <span class="c1">// Implementations are free to add new class member variables</span>
    <span class="c1">// (requiring changes to tasksys.h).</span>
    <span class="c1">//</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mutex_</span><span class="p">);</span>
  <span class="n">done_</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span>
  <span class="n">lock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
  <span class="n">cv_</span><span class="p">.</span><span class="n">notify_all</span><span class="p">();</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"destructor</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">workers_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// cv_.notify_all();</span>
    <span class="k">if</span><span class="p">(</span><span class="n">workers_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">joinable</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">workers_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">join</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"exit</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>Worker code:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">TaskID</span> <span class="n">TaskSystemParallelThreadPoolSleeping</span><span class="o">::</span><span class="n">runAsyncWithDeps</span><span class="p">(</span><span class="n">IRunnable</span><span class="o">*</span> <span class="n">runnable</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_total_tasks</span><span class="p">,</span>
                                                    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TaskID</span><span class="o">&gt;&amp;</span> <span class="n">deps</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">//</span>
    <span class="c1">// TODO: CS149 students will implement this method in Part B.</span>
    <span class="c1">//</span>

  <span class="n">TaskID</span> <span class="n">new_task</span> <span class="o">=</span> <span class="n">task_dep_</span><span class="p">.</span><span class="n">GetNewTaskID</span><span class="p">();</span>
  <span class="n">mutex_</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
   <span class="n">taskid_remain_work_count_map_</span><span class="p">[</span><span class="n">new_task</span><span class="p">]</span> <span class="o">=</span> <span class="n">num_total_tasks</span><span class="p">;</span>
   <span class="k">for</span><span class="p">(</span><span class="n">TaskID</span> <span class="n">parent_task_id</span><span class="o">:</span> <span class="n">deps</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">dependent_children_</span><span class="p">[</span><span class="n">parent_task_id</span><span class="p">].</span><span class="n">insert</span><span class="p">(</span><span class="n">new_task</span><span class="p">);</span>
   <span class="p">}</span>
   <span class="n">TaskArg</span> <span class="nf">task_arg</span><span class="p">(</span><span class="n">new_task</span><span class="p">,</span> <span class="n">runnable</span><span class="p">,</span> <span class="n">num_total_tasks</span><span class="p">,</span>  <span class="n">deps</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"task: %d dep count: %ld</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">new_task</span><span class="p">,</span> <span class="n">deps</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
   <span class="n">task_id_remaining_dependent_parents_count_</span><span class="p">[</span><span class="n">new_task</span><span class="p">]</span> <span class="o">=</span> <span class="n">task_arg</span><span class="p">;</span>
  <span class="n">CheckAndNotify</span><span class="p">(</span><span class="n">new_task</span><span class="p">);</span>
  <span class="n">mutex_</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>


  <span class="k">return</span> <span class="n">new_task</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">TaskSystemParallelThreadPoolSleeping</span><span class="o">::</span><span class="n">threadTask</span><span class="p">(</span> <span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mutex_</span><span class="p">);</span>
  <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">done_</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">threadArg</span> <span class="n">arg</span> <span class="p">;</span> 
    <span class="kt">bool</span> <span class="n">get_task</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">ready_queue_</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">arg</span> <span class="o">=</span> <span class="n">ready_queue_</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
      <span class="n">ready_queue_</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
      <span class="n">get_task</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"get task</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"wait task</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
      <span class="n">cv_</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
      <span class="c1">// cv_.wait(lock, [this]{return !ready_queue_.empty() || done_ ;});</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">lock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="n">get_task</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">int</span> <span class="n">task_thread_id</span> <span class="o">=</span> <span class="n">arg</span><span class="p">.</span><span class="n">task_thread_id</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">task_id</span> <span class="o">=</span> <span class="n">arg</span><span class="p">.</span><span class="n">task_id</span><span class="p">;</span>
      <span class="n">arg</span><span class="p">.</span><span class="n">runnable</span><span class="o">-&gt;</span><span class="n">runTask</span><span class="p">(</span><span class="n">task_thread_id</span><span class="p">,</span> <span class="n">arg</span><span class="p">.</span><span class="n">num_total_tasks</span><span class="p">);</span>
      <span class="kt">bool</span> <span class="n">cur_task_finished</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
      <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">inner_lock</span><span class="p">(</span><span class="n">mutex_</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">task_remain_work_count</span> <span class="o">=</span> <span class="o">--</span><span class="n">taskid_remain_work_count_map_</span><span class="p">[</span><span class="n">task_id</span><span class="p">];</span>
        <span class="k">if</span><span class="p">(</span><span class="n">task_remain_work_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">printf</span><span class="p">(</span><span class="s">"task:%d finished</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">task_id</span><span class="p">);</span>
          <span class="n">cur_task_finished</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
          <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">children_task_ids</span> <span class="o">=</span> <span class="n">dependent_children_</span><span class="p">[</span><span class="n">task_id</span><span class="p">];</span>
          <span class="k">for</span><span class="p">(</span><span class="n">TaskID</span> <span class="n">child_task_id</span><span class="o">:</span> <span class="n">children_task_ids</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">task_id_remaining_dependent_parents_count_</span><span class="p">[</span><span class="n">child_task_id</span><span class="p">].</span><span class="n">remain_dep_parent_task_count</span><span class="o">--</span><span class="p">;</span>
            <span class="n">CheckAndMoveTaskToReadyQueue</span><span class="p">(</span><span class="n">child_task_id</span><span class="p">);</span>
          <span class="p">}</span>

        <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">if</span><span class="p">(</span><span class="n">cur_task_finished</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">finished_tasks_</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="c1">// extra notify all here for sync()</span>
        <span class="n">cv_</span><span class="p">.</span><span class="n">notify_all</span><span class="p">();</span>

      <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">lock</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Add another condition to notify_all() threads.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      if(cur_task_finished || moved_to_ready_queue) {
        finished_tasks_.fetch_add(1);
        // extra notify all here for sync()
        cv_.notify_all();

      }

</code></pre></div></div> <p>Task 1 is not moved to ready_queue</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>destructor
exit
wait task
wait task
task:0 moved to ready_queue
get task
get task
get task
wait task
task:0 finished
wait task
</code></pre></div></div> <p>Another issue: the deps parent task might have been finished when the new child task is pushed. Need to deal with this situation.</p> <p>So we should not use this structure for task schedule</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   std::unordered_map&lt;TaskID, std::unordered_set&lt;TaskID&gt;&gt; dependent_children_;
</code></pre></div></div> <p>This class structure is not right.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class TaskSystemParallelThreadPoolSleeping: public ITaskSystem {
    public:
        TaskSystemParallelThreadPoolSleeping(int num_threads);
        ~TaskSystemParallelThreadPoolSleeping();
        const char* name();
        void run(IRunnable* runnable, int num_total_tasks);
        TaskID runAsyncWithDeps(IRunnable* runnable, int num_total_tasks,
                                const std::vector&lt;TaskID&gt;&amp; deps);
        void sync();

private:
  void threadTask( );
  bool CheckAndMoveTaskToReadyQueue(TaskID child_task_id);
  void CheckAndNotify(TaskID child_task_id);
  std::vector&lt;std::thread&gt; workers_;
  int num_threads_;
  bool done_;
  std::mutex mutex_;
  std::condition_variable cv_;
  std::atomic&lt;TaskID&gt; task_id_;
  std::unordered_map&lt;TaskID, std::unordered_set&lt;TaskID&gt;&gt; dependent_children_;
  std::unordered_map&lt;TaskID, TaskArg&gt; task_id_remaining_dependent_parents_count_;
  std::deque&lt;threadArg&gt; ready_queue_;
  std::unordered_map&lt;TaskID, int&gt; taskid_remain_work_count_map_;
  std::atomic&lt;int&gt; finished_tasks_;
 

};
</code></pre></div></div> <h3 id="correct-implementaion">Correct implementaion</h3> <p>Code :</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">TaskSystemParallelThreadPoolSleeping</span><span class="o">::</span><span class="n">threadTask</span><span class="p">(</span> <span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mutex_</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TaskID</span><span class="o">&gt;</span> <span class="n">tasks</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">get_new_tasks_to_run</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="c1">// get_new_tasks_to_run = task_dep_.CheckAndGetRunnableTasks(tasks);</span>
  <span class="c1">// for(TaskID task_id : tasks){</span>
  <span class="c1">//   ScheduleTaskToReadyQueue(task_id);</span>
  <span class="c1">// }</span>
  <span class="c1">// tasks.clear();</span>

  <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">done_</span> <span class="o">||</span> <span class="o">!</span><span class="n">ready_queue_</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">||</span> <span class="n">task_dep_</span><span class="p">.</span><span class="n">HasTaskToSchedule</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">get_new_tasks_to_run</span> <span class="o">=</span> <span class="n">task_dep_</span><span class="p">.</span><span class="n">CheckAndGetRunnableTasks</span><span class="p">(</span><span class="n">tasks</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="n">TaskID</span> <span class="n">task_id</span><span class="o">:</span> <span class="n">tasks</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">ScheduleTaskToReadyQueue</span><span class="p">(</span><span class="n">task_id</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">tasks</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
    <span class="n">threadArg</span> <span class="n">arg</span> <span class="p">;</span> 
    <span class="kt">bool</span> <span class="n">get_task</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">ready_queue_</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">arg</span> <span class="o">=</span> <span class="n">ready_queue_</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
      <span class="n">ready_queue_</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
      <span class="n">get_task</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
      <span class="c1">// printf("get task\n");</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// printf("wait task\n");</span>
      <span class="n">cv_</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
      <span class="c1">// cv_.wait(lock, [this]{return !ready_queue_.empty() || done_ ;});</span>
    <span class="p">}</span>
    <span class="n">lock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="n">get_task</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">int</span> <span class="n">task_thread_id</span> <span class="o">=</span> <span class="n">arg</span><span class="p">.</span><span class="n">task_thread_id</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">task_id</span> <span class="o">=</span> <span class="n">arg</span><span class="p">.</span><span class="n">task_id</span><span class="p">;</span>
      <span class="n">arg</span><span class="p">.</span><span class="n">runnable</span><span class="o">-&gt;</span><span class="n">runTask</span><span class="p">(</span><span class="n">task_thread_id</span><span class="p">,</span> <span class="n">arg</span><span class="p">.</span><span class="n">num_total_tasks</span><span class="p">);</span>
      <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">inner_lock</span><span class="p">(</span><span class="n">mutex_</span><span class="p">);</span>
        <span class="c1">// printf("taskid: %d, thread_id: %d finished\n", task_id, task_thread_id);</span>
        <span class="n">FinishOneSubTask</span><span class="p">(</span><span class="n">task_id</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="c1">// Move notify_all out of mutex scope so that </span>
      <span class="c1">// other threads can wake up and do some work</span>
      <span class="c1">// if(cur_task_finished || has_moved_to_ready_queue) {</span>
      <span class="c1">//   cv_.notify_all();</span>
      <span class="c1">// }</span>
    <span class="n">cv_</span><span class="p">.</span><span class="n">notify_all</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">lock</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Prerequisite: mutex_ is held</span>
<span class="kt">void</span>  <span class="n">TaskSystemParallelThreadPoolSleeping</span><span class="o">::</span><span class="n">ScheduleTaskToReadyQueue</span><span class="p">(</span><span class="n">TaskID</span> <span class="n">task_id</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">TaskArg</span> <span class="n">task_arg</span><span class="p">;</span>
  <span class="n">task_dep_</span><span class="p">.</span><span class="n">GetTaskArg</span><span class="p">(</span><span class="n">task_id</span><span class="p">,</span> <span class="n">task_arg</span><span class="p">);</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">task_arg</span><span class="p">.</span><span class="n">num_total_tasks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">threadArg</span> <span class="n">ta</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">task_arg</span><span class="p">.</span><span class="n">num_total_tasks</span><span class="p">,</span> <span class="n">task_arg</span><span class="p">.</span><span class="n">runnable</span><span class="p">,</span> <span class="n">task_id</span><span class="p">);</span>
    <span class="n">taskid_remain_work_count_map_</span><span class="p">[</span><span class="n">task_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">task_arg</span><span class="p">.</span><span class="n">num_total_tasks</span><span class="p">;</span>
    <span class="n">ready_queue_</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">ta</span><span class="p">);</span>
  <span class="p">}</span>

<span class="p">}</span>
<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">TaskSystemParallelThreadPoolSleeping</span><span class="o">::</span><span class="n">name</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">"Parallel + Thread Pool + Sleep"</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">TaskSystemParallelThreadPoolSleeping</span><span class="o">::</span><span class="n">TaskSystemParallelThreadPoolSleeping</span><span class="p">(</span><span class="kt">int</span> <span class="n">num_threads</span><span class="p">)</span><span class="o">:</span> <span class="n">ITaskSystem</span><span class="p">(</span><span class="n">num_threads</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//</span>
    <span class="c1">// TODO: CS149 student implementations may decide to perform setup</span>
    <span class="c1">// operations (such as thread pool construction) here.</span>
    <span class="c1">// Implementations are free to add new class member variables</span>
    <span class="c1">// (requiring changes to tasksys.h).</span>
    <span class="c1">//</span>
  <span class="n">done_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="c1">// task_id_ = 0;</span>
  <span class="n">num_threads_</span> <span class="o">=</span> <span class="n">num_threads</span><span class="p">;</span>
  <span class="c1">// finished_tasks_ = 0;</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_threads_</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">workers_</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">([</span><span class="k">this</span><span class="p">]{</span>
      <span class="k">this</span><span class="o">-&gt;</span><span class="n">threadTask</span><span class="p">();</span>
    <span class="p">});</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="n">TaskSystemParallelThreadPoolSleeping</span><span class="o">::~</span><span class="n">TaskSystemParallelThreadPoolSleeping</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">//</span>
    <span class="c1">// TODO: CS149 student implementations may decide to perform cleanup</span>
    <span class="c1">// operations (such as thread pool shutdown construction) here.</span>
    <span class="c1">// Implementations are free to add new class member variables</span>
    <span class="c1">// (requiring changes to tasksys.h).</span>
    <span class="c1">//</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mutex_</span><span class="p">);</span>
  <span class="n">done_</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span>
  <span class="n">lock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
  <span class="n">cv_</span><span class="p">.</span><span class="n">notify_all</span><span class="p">();</span>
  <span class="c1">// printf("destructor\n");</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">workers_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// cv_.notify_all();</span>
    <span class="k">if</span><span class="p">(</span><span class="n">workers_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">joinable</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">workers_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">join</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="c1">// printf("exit\n");</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">TaskSystemParallelThreadPoolSleeping</span><span class="o">::</span><span class="n">run</span><span class="p">(</span><span class="n">IRunnable</span><span class="o">*</span> <span class="n">runnable</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_total_tasks</span><span class="p">)</span> <span class="p">{</span>


    <span class="c1">//</span>
    <span class="c1">// TODO: CS149 students will modify the implementation of this</span>
    <span class="c1">// method in Parts A and B.  The implementation provided below runs all</span>
    <span class="c1">// tasks sequentially on the calling thread.</span>
    <span class="c1">//</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_total_tasks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">runnable</span><span class="o">-&gt;</span><span class="n">runTask</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">num_total_tasks</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Two places to shcedule tasks and put tasks to ready_queue_ directly </span>
<span class="c1">// or move tasks in task_queue_ to ready_queue_ at the start of runAsyncWithDeps call</span>
<span class="c1">// or at threadTask where each TaskID is done</span>
<span class="n">TaskID</span> <span class="n">TaskSystemParallelThreadPoolSleeping</span><span class="o">::</span><span class="n">runAsyncWithDeps</span><span class="p">(</span><span class="n">IRunnable</span><span class="o">*</span> <span class="n">runnable</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_total_tasks</span><span class="p">,</span>
                                                    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TaskID</span><span class="o">&gt;&amp;</span> <span class="n">deps</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">//</span>
    <span class="c1">// TODO: CS149 students will implement this method in Part B.</span>
    <span class="c1">//</span>

  <span class="n">mutex_</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
  <span class="n">TaskID</span> <span class="n">new_task</span> <span class="o">=</span> <span class="n">task_dep_</span><span class="p">.</span><span class="n">GetNewTaskID</span><span class="p">();</span>
  <span class="n">task_dep_</span><span class="p">.</span><span class="n">AddTaskDep</span><span class="p">(</span><span class="n">new_task</span><span class="p">,</span> <span class="n">deps</span><span class="p">,</span> <span class="n">runnable</span><span class="p">,</span> <span class="n">num_total_tasks</span><span class="p">);</span>
  <span class="c1">// printf("task: %d dep count: %ld\n", new_task, deps.size());</span>
  <span class="n">mutex_</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
  <span class="n">cv_</span><span class="p">.</span><span class="n">notify_all</span><span class="p">();</span>


  <span class="k">return</span> <span class="n">new_task</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">TaskSystemParallelThreadPoolSleeping</span><span class="o">::</span><span class="n">sync</span><span class="p">()</span> <span class="p">{</span>

    <span class="c1">//</span>
    <span class="c1">// TODO: CS149 students will modify the implementation of this method in Part B.</span>
    <span class="c1">//</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mutex_</span><span class="p">);</span>
  <span class="c1">// In case all threads atre put to sleep</span>


  <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">ready_queue_</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">||</span> <span class="n">task_dep_</span><span class="p">.</span><span class="n">GetFinishedTaskCount</span><span class="p">()</span> <span class="o">!=</span> <span class="n">task_dep_</span><span class="p">.</span><span class="n">GetTotalTaskCount</span><span class="p">()</span>  <span class="p">)</span> <span class="p">{</span>
    <span class="c1">// printf("finished task count:%d, task_id:%d\n", finished_tasks_.load(), task_id_.load());</span>
    <span class="n">cv_</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
    <span class="c1">// printf("finished task count:%d, task_id:%d\n", finished_tasks_.load(), task_id_.load());</span>
  <span class="p">}</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">TaskDep</span><span class="o">::</span><span class="n">TaskDep</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">task_id_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">finished_tasks_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">TaskID</span> <span class="n">TaskDep</span><span class="o">::</span><span class="n">GetNewTaskID</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">task_id_</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="n">TaskDep</span><span class="o">::</span><span class="n">GetFinishedTaskCount</span><span class="p">()</span> <span class="k">const</span>  <span class="p">{</span>
  <span class="k">return</span> <span class="n">finished_tasks_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">TaskDep</span><span class="o">::</span><span class="n">FinishTask</span><span class="p">(</span><span class="n">TaskID</span> <span class="n">task_id</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">finished_task_ids_</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">task_id</span><span class="p">);</span>
  <span class="n">finished_tasks_</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">TaskSystemParallelThreadPoolSleeping</span><span class="o">::</span><span class="n">FinishOneSubTask</span><span class="p">(</span><span class="n">TaskID</span> <span class="n">task_id</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="o">--</span><span class="n">taskid_remain_work_count_map_</span><span class="p">[</span><span class="n">task_id</span><span class="p">]</span> <span class="o">==</span><span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
    <span class="c1">// printf("task:%d finished\n", task_id);</span>
    <span class="n">task_dep_</span><span class="p">.</span><span class="n">FinishTask</span><span class="p">(</span><span class="n">task_id</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">TaskDep</span><span class="o">::</span><span class="n">CheckAndGetRunnableTasks</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TaskID</span><span class="o">&gt;&amp;</span> <span class="n">tasks</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TaskID</span><span class="o">&gt;</span> <span class="n">to_erase</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">iter</span><span class="o">:</span> <span class="n">dependent_parents_</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">TaskID</span> <span class="n">child_task_id</span> <span class="o">=</span> <span class="n">iter</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
    <span class="c1">// printf("child task id:%d\n", child_task_id  );</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">parent_it</span><span class="o">=</span><span class="n">iter</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">parent_it</span><span class="o">!=</span><span class="n">iter</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">end</span><span class="p">();){</span>
      <span class="c1">// printf("   parent: %d, finished:%d\n", *parent_it, CheckTaskFinished(*parent_it));</span>
      <span class="k">if</span><span class="p">(</span> <span class="n">CheckTaskFinished</span><span class="p">(</span><span class="o">*</span><span class="n">parent_it</span><span class="p">)){</span>
        <span class="n">parent_it</span> <span class="o">=</span> <span class="n">iter</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">parent_it</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">parent_it</span><span class="o">++</span><span class="p">;</span>  
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="kt">bool</span> <span class="n">not_scheduled</span> <span class="o">=</span> <span class="n">scheduled_task_ids_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">child_task_id</span><span class="p">)</span> <span class="o">==</span> <span class="n">scheduled_task_ids_</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="p">;</span>
    <span class="kt">bool</span> <span class="n">parents_empty</span> <span class="o">=</span><span class="n">dependent_parents_</span><span class="p">[</span><span class="n">child_task_id</span><span class="p">].</span><span class="n">empty</span><span class="p">();</span> 
    <span class="k">if</span><span class="p">(</span><span class="n">not_scheduled</span> <span class="o">&amp;&amp;</span> <span class="n">parents_empty</span><span class="p">){</span>
      <span class="n">scheduled_task_ids_</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">child_task_id</span><span class="p">);</span>
      <span class="c1">// printf("new task schedule:%d\n", child_task_id);</span>
      <span class="n">tasks</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">child_task_id</span><span class="p">);</span>
      <span class="n">to_erase</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">child_task_id</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">for</span><span class="p">(</span><span class="n">TaskID</span> <span class="n">erase_id</span><span class="o">:</span> <span class="n">to_erase</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">dependent_parents_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">erase_id</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="o">!</span><span class="n">tasks</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">TaskDep</span><span class="o">::</span><span class="n">CheckTaskFinished</span><span class="p">(</span><span class="n">TaskID</span> <span class="n">task_id</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">finished_task_ids_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">task_id</span><span class="p">)</span> <span class="o">!=</span> <span class="n">finished_task_ids_</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>

<span class="p">}</span>

<span class="kt">void</span> <span class="n">TaskDep</span><span class="o">::</span><span class="n">GetTaskArg</span><span class="p">(</span><span class="n">TaskID</span> <span class="n">task_id</span><span class="p">,</span> <span class="n">TaskArg</span><span class="o">&amp;</span> <span class="n">task_arg</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">ta</span> <span class="o">=</span> <span class="n">task_args_</span><span class="p">[</span><span class="n">task_id</span><span class="p">];</span>
  <span class="n">task_arg</span><span class="p">.</span><span class="n">task_id</span> <span class="o">=</span> <span class="n">ta</span><span class="p">.</span><span class="n">task_id</span><span class="p">;</span>
  <span class="n">task_arg</span><span class="p">.</span><span class="n">num_total_tasks</span> <span class="o">=</span> <span class="n">ta</span><span class="p">.</span><span class="n">num_total_tasks</span><span class="p">;</span>
  <span class="n">task_arg</span><span class="p">.</span><span class="n">runnable</span> <span class="o">=</span> <span class="n">ta</span><span class="p">.</span><span class="n">runnable</span><span class="p">;</span>
  <span class="n">task_arg</span><span class="p">.</span><span class="n">remain_dep_parent_task_count</span> <span class="o">=</span> <span class="n">ta</span><span class="p">.</span><span class="n">remain_dep_parent_task_count</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">TaskDep</span><span class="o">::</span><span class="n">AddTaskDep</span><span class="p">(</span><span class="n">TaskID</span> <span class="n">child</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TaskID</span><span class="o">&gt;</span> <span class="n">deps</span><span class="p">,</span> <span class="n">IRunnable</span><span class="o">*</span> <span class="n">runnable</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_total_tasks</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">TaskArg</span> <span class="n">ta</span><span class="p">;</span>
  <span class="n">ta</span><span class="p">.</span><span class="n">task_id</span> <span class="o">=</span> <span class="n">child</span><span class="p">;</span>
  <span class="n">ta</span><span class="p">.</span><span class="n">remain_dep_parent_task_count</span> <span class="o">=</span> <span class="n">deps</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
  <span class="n">ta</span><span class="p">.</span><span class="n">runnable</span> <span class="o">=</span> <span class="n">runnable</span><span class="p">;</span>
  <span class="n">ta</span><span class="p">.</span><span class="n">num_total_tasks</span> <span class="o">=</span> <span class="n">num_total_tasks</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">deps</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
  <span class="k">for</span><span class="p">(</span><span class="n">TaskID</span> <span class="n">task_id</span><span class="o">:</span> <span class="n">deps</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">dependent_parents_</span><span class="p">[</span><span class="n">child</span><span class="p">].</span><span class="n">insert</span><span class="p">(</span><span class="n">task_id</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">dependent_parents_</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">=</span> <span class="p">{};</span>
  <span class="p">}</span>
  <span class="n">task_args_</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">=</span> <span class="n">ta</span><span class="p">;</span>

<span class="p">}</span>
</code></pre></div></div> <p>Notice the difference between code below</p> <p>The first piece of code would not work because it creates a copy of the elements of dependent_parents_</p> <p>so <code class="language-plaintext highlighter-rouge">dependent_parents_[child_task_id].empty()</code> would always return false</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  for(auto iter: dependent_parents_) {

    if(scheduled_task_ids_.find(child_task_id) == scheduled_task_ids_.end() &amp;&amp;dependent_parents_[child_task_id].empty()){
      scheduled_task_ids_.insert(child_task_id);
      printf("new task schedule:%d\n", child_task_id);
      tasks.emplace_back(child_task_id);
      to_erase.emplace_back(child_task_id);
      // dependent_parents_.erase(child_task_id);
    }
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  for(auto &amp;iter: dependent_parents_) {

    if(scheduled_task_ids_.find(child_task_id) == scheduled_task_ids_.end() &amp;&amp;dependent_parents_[child_task_id].empty()){
      scheduled_task_ids_.insert(child_task_id);
      printf("new task schedule:%d\n", child_task_id);
      tasks.emplace_back(child_task_id);
      to_erase.emplace_back(child_task_id);
      // dependent_parents_.erase(child_task_id);
    }
</code></pre></div></div> <p>Result:</p> <p>Not good. I think it’s because I wake up threads frequently.</p> <p>Try to reduce wake up time.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Executing test: super_super_light_async...
Reference binary: ./runtasks_ref_linux
Results for: super_super_light_async
                                        STUDENT   REFERENCE   PERF?
[Serial]                                8.706     12.433      0.70  (OK)
[Parallel + Always Spawn]               8.406     56.047      0.15  (OK)
[Parallel + Thread Pool + Spin]         8.27      25.412      0.33  (OK)
[Parallel + Thread Pool + Sleep]        224.619   24.681      9.10  (NOT OK)

================================================================================

Executing test: super_light_async...
Reference binary: ./runtasks_ref_linux
Results for: super_light_async
                                        STUDENT   REFERENCE   PERF?
[Serial]                                82.485    95.578      0.86  (OK)
[Parallel + Always Spawn]               81.039    81.133      1.00  (OK)
[Parallel + Thread Pool + Spin]         81.268    34.526      2.35  (NOT OK)
[Parallel + Thread Pool + Sleep]        408.665   31.755      12.87  (NOT OK)

================================================================================
Executing test: ping_pong_equal_async...
Reference binary: ./runtasks_ref_linux
Results for: ping_pong_equal_async
                                        STUDENT   REFERENCE   PERF?
[Serial]                                1313.035  1542.283    0.85  (OK)
[Parallel + Always Spawn]               1309.708  701.653     1.87  (NOT OK)
[Parallel + Thread Pool + Spin]         1313.704  227.62      5.77  (NOT OK)
[Parallel + Thread Pool + Sleep]        778.308   224.776     3.46  (NOT OK)
================================================================================

Executing test: ping_pong_unequal_async...
Reference binary: ./runtasks_ref_linux
Results for: ping_pong_unequal_async
                                        STUDENT   REFERENCE   PERF?
[Serial]                                2446.194  2402.307    1.02  (OK)
[Parallel + Always Spawn]               2456.503  976.121     2.52  (NOT OK)
[Parallel + Thread Pool + Spin]         2454.091  332.344     7.38  (NOT OK)
[Parallel + Thread Pool + Sleep]        506.64    330.938     1.53  (NOT OK)
================================================================================

Executing test: recursive_fibonacci_async...
Reference binary: ./runtasks_ref_linux
Results for: recursive_fibonacci_async
                                        STUDENT   REFERENCE   PERF?
[Serial]                                1310.101  1946.319    0.67  (OK)
[Parallel + Always Spawn]               1303.736  505.253     2.58  (NOT OK)
[Parallel + Thread Pool + Spin]         1306.294  261.702     4.99  (NOT OK)
[Parallel + Thread Pool + Sleep]        186.681   264.498     0.71  (OK)
================================================================================

Executing test: math_operations_in_tight_for_loop_async...
Reference binary: ./runtasks_ref_linux
Results for: math_operations_in_tight_for_loop_async
                                        STUDENT   REFERENCE   PERF?
[Serial]                                821.415   854.457     0.96  (OK)
[Parallel + Always Spawn]               822.081   697.755     1.18  (OK)
[Parallel + Thread Pool + Spin]         817.92    149.114     5.49  (NOT OK)
[Parallel + Thread Pool + Sleep]        7622.159  148.934     51.18  (NOT OK)
================================================================================
Executing test: math_operations_in_tight_for_loop_reduction_tree_async...
Reference binary: ./runtasks_ref_linux
Results for: math_operations_in_tight_for_loop_reduction_tree_async
                                        STUDENT   REFERENCE   PERF?
[Serial]                                419.026   439.384     0.95  (OK)
[Parallel + Always Spawn]               418.167   141.737     2.95  (NOT OK)
[Parallel + Thread Pool + Spin]         418.431   72.123      5.80  (NOT OK)
[Parallel + Thread Pool + Sleep]        70.724    71.191      0.99  (OK)
================================================================================
</code></pre></div></div> <h3 id="reduce-run-time">Reduce run time</h3> <p>Another change I want to make is that I can only schedule tasks at the begining of run call or when a task is finished. This means that there will be less check to get runnable task.</p> <p>Because there are only places where task is scheduled and they are</p> <ol> <li>The task is first inserted to system</li> <li>Another task is finished.</li> </ol> <p>Two possible state of parent task.</p> <ol> <li> <p>The parent task is finished. For this, we can erase the task dependency for child task when the child task is submitted.</p> </li> <li> <p>The parent task is not finished. For this, when parent task is finished, it will talk with task manager and tell it to erase parent task from taske dependency structure.</p> </li> </ol> <p>For both situation, check if child task can be scheduled.</p> <p>Code:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>TaskDep::TaskDep() {
  task_id_ = 0;
  finished_tasks_ = 0;
}
TaskID TaskDep::GetNewTaskID() {
  return task_id_.fetch_add(1);

}

int TaskDep::GetFinishedTaskCount() const  {
  return finished_tasks_.load();
}

void TaskDep::FinishTask(TaskID task_id, std::vector&lt;TaskID&gt;&amp; children_tasks) {
  finished_task_ids_.insert(task_id);
  finished_tasks_.fetch_add(1);
  // remove this parent from all of its children.
  for(TaskID child_task_id: dependent_children_[task_id] ) {
    dependent_parents_[child_task_id].erase(task_id);
    // If child has no parent dependency , we change schedule it
    if(dependent_parents_[child_task_id].empty()) {
      children_tasks.emplace_back(child_task_id);
    }
    // if(dependent_children_[child_task_id].find(task_id) != dependent_children_[child_task_id].end()) {
    //   dependent_children_[child_task_id].erase(task_id);
    // }
    // if(dependent_parents_[child_task_id].empty()) {
    //   children_tasks.emplace_back(child_task_id);
    // }

  }
}
bool TaskSystemParallelThreadPoolSleeping::FinishOneSubTask(TaskID task_id, std::vector&lt;TaskID&gt;&amp; children_tasks) {
  if(--taskid_remain_work_count_map_[task_id] ==0 ) {
    // printf("task:%d finished\n", task_id);
    task_dep_.FinishTask(task_id, children_tasks);
    return true;
    }
  return false; 
}

bool TaskDep::CheckAndGetRunnableTasks(std::vector&lt;TaskID&gt;&amp; tasks) {
  std::vector&lt;TaskID&gt; to_erase;
  for(auto &amp;iter: dependent_parents_) {
    TaskID child_task_id = iter.first;
    // printf("child task id:%d\n", child_task_id  );
    for(auto parent_it=iter.second.begin(); parent_it!=iter.second.end();){
      // printf("   parent: %d, finished:%d\n", *parent_it, CheckTaskFinished(*parent_it));
      if( CheckTaskFinished(*parent_it)){
        parent_it = iter.second.erase(parent_it);
      } else {
        parent_it++;  
      }
    }
    bool not_scheduled = scheduled_task_ids_.find(child_task_id) == scheduled_task_ids_.end() ;
    bool parents_empty =dependent_parents_[child_task_id].empty(); 
    if(not_scheduled &amp;&amp; parents_empty){
      scheduled_task_ids_.insert(child_task_id);
      // printf("new task schedule:%d\n", child_task_id);
      tasks.emplace_back(child_task_id);
      to_erase.emplace_back(child_task_id);
    }
  }
  for(TaskID erase_id: to_erase) {
    dependent_parents_.erase(erase_id);
  }
  return !tasks.empty();
}

bool TaskDep::CheckTaskFinished(TaskID task_id) {
  return finished_task_ids_.find(task_id) != finished_task_ids_.end();

}

void TaskDep::GetTaskArg(TaskID task_id, TaskArg&amp; task_arg) {
  const auto&amp; ta = task_args_[task_id];
  task_arg.task_id = ta.task_id;
  task_arg.num_total_tasks = ta.num_total_tasks;
  task_arg.runnable = ta.runnable;
  task_arg.remain_dep_parent_task_count = ta.remain_dep_parent_task_count;
}

void TaskDep::AddTaskDep(TaskID child, std::vector&lt;TaskID&gt; deps, IRunnable* runnable, int num_total_tasks) {
  TaskArg ta;
  ta.task_id = child;
  ta.remain_dep_parent_task_count = deps.size();
  ta.runnable = runnable;
  ta.num_total_tasks = num_total_tasks;
  if(!deps.empty()) {
  for(TaskID task_id: deps) {
    dependent_parents_[child].insert(task_id);
    dependent_children_[task_id].insert(child);
  }

  } else {
    dependent_parents_[child] = {};
  }
  task_args_[child] = ta;

}
void TaskSystemParallelThreadPoolSleeping::threadTask( ) {
  std::unique_lock&lt;std::mutex&gt; lock(mutex_);
  std::vector&lt;TaskID&gt; tasks;
  bool get_new_tasks_to_run = false;
    while(!done_ || !ready_queue_.empty() ) {
    threadArg arg ; 
    bool get_task = false;
    if(!ready_queue_.empty()) {
      arg = ready_queue_.front();
      ready_queue_.pop_front();
      get_task = true;
      // printf("get task\n");
    } else {
      // printf("wait task\n");
      cv_.wait(lock);
      // cv_.wait(lock, [this]{return !ready_queue_.empty() || done_ ;});
    }
    lock.unlock();
    if(get_task) {
      int task_thread_id = arg.task_thread_id;
      int task_id = arg.task_id;
      bool cur_task_finished = false;
      std::vector&lt;TaskID&gt; children_task_to_schedule;
      arg.runnable-&gt;runTask(task_thread_id, arg.num_total_tasks);
      {
        std::unique_lock&lt;std::mutex&gt; inner_lock(mutex_);
        // printf("taskid: %d, thread_id: %d finished\n", task_id, task_thread_id);
        cur_task_finished = FinishOneSubTask(task_id, children_task_to_schedule);
        if(!children_task_to_schedule.empty()) {
          for(TaskID child_task_id: children_task_to_schedule){
            ScheduleTaskToReadyQueue(child_task_id);
            // Is sthis ok ?
            // cv_.notify_all();
          }
        }
      }
      // Move notify_all out of mutex scope so that 
      // other threads can wake up and do some work
      // if(!ready_queue_.empty()  ) {
      // }
      if(!children_task_to_schedule.empty() || wait_sync_.load()) {
        cv_.notify_all();
      }
    }
    lock.lock();
  }
}

// bool TaskSystemParallelThreadPoolSleeping::CheckTaskAndMoveToReadyQueue() {
//   std::vector&lt;TaskID&gt; tasks;
//     bool get_new_tasks_to_run = task_dep_.CheckAndGetRunnableTasks(tasks);
//     for(TaskID task_id: tasks) {
//       ScheduleTaskToReadyQueue(task_id);
//     }
//     // tasks.clear();
//   return get_new_tasks_to_run;

// }
// Prerequisite: mutex_ is held
void  TaskSystemParallelThreadPoolSleeping::ScheduleTaskToReadyQueue(TaskID task_id) {
  TaskArg task_arg;
  task_dep_.GetTaskArg(task_id, task_arg);
  bool not_scheduled = scheduled_task_ids_.find(task_id) == scheduled_task_ids_.end() ;
  if(not_scheduled  ){
    scheduled_task_ids_.insert(task_id);
    // printf("new task schedule:%d\n", child_task_id);
    // to_erase.emplace_back(child_task_id);
  }
  for(int i=0; i &lt; task_arg.num_total_tasks; i++) {
    threadArg ta(i, task_arg.num_total_tasks, task_arg.runnable, task_id);
    taskid_remain_work_count_map_[task_id] = task_arg.num_total_tasks;
    ready_queue_.emplace_back(ta);
  }

}
const char* TaskSystemParallelThreadPoolSleeping::name() {
    return "Parallel + Thread Pool + Sleep";
}

TaskSystemParallelThreadPoolSleeping::TaskSystemParallelThreadPoolSleeping(int num_threads): ITaskSystem(num_threads) {
    //
    // TODO: CS149 student implementations may decide to perform setup
    // operations (such as thread pool construction) here.
    // Implementations are free to add new class member variables
    // (requiring changes to tasksys.h).
    //
  done_ = false;
  // task_id_ = 0;
  num_threads_ = num_threads;
  // finished_tasks_ = 0;
  for(int i=0; i &lt; num_threads_; i++) {
    workers_.emplace_back([this]{
      this-&gt;threadTask();
    });
  }
}

TaskSystemParallelThreadPoolSleeping::~TaskSystemParallelThreadPoolSleeping() {
    //
    // TODO: CS149 student implementations may decide to perform cleanup
    // operations (such as thread pool shutdown construction) here.
    // Implementations are free to add new class member variables
    // (requiring changes to tasksys.h).
    //
  std::unique_lock&lt;std::mutex&gt; lock(mutex_);
  done_=true;
  lock.unlock();
  cv_.notify_all();
  // printf("destructor\n");
  for(int i=0; i &lt; workers_.size(); i++) {
    // cv_.notify_all();
    if(workers_[i].joinable()) {
      workers_[i].join();
    }
  }
  // printf("exit\n");
}

void TaskSystemParallelThreadPoolSleeping::run(IRunnable* runnable, int num_total_tasks) {


    //
    // TODO: CS149 students will modify the implementation of this
    // method in Parts A and B.  The implementation provided below runs all
    // tasks sequentially on the calling thread.
    //

    for (int i = 0; i &lt; num_total_tasks; i++) {
        runnable-&gt;runTask(i, num_total_tasks);
    }
}

// Two places to shcedule tasks and put tasks to ready_queue_ directly 
// or move tasks in task_queue_ to ready_queue_ at the start of runAsyncWithDeps call
// or at threadTask where each TaskID is done
TaskID TaskSystemParallelThreadPoolSleeping::runAsyncWithDeps(IRunnable* runnable, int num_total_tasks,
                                                    const std::vector&lt;TaskID&gt;&amp; deps) {

    //
    // TODO: CS149 students will implement this method in Part B.
    //

  mutex_.lock();
  TaskID new_task = task_dep_.GetNewTaskID();
  printf("task: %d dep count: %ld, dep id:%d\n", new_task, deps.size(), deps.empty() ? 0 : deps[0]);
  // CheckTaskAndMoveToReadyQueue();
  std::vector&lt;TaskID&gt; new_deps;
  for(TaskID parent_task_id: deps) {
    if(!task_dep_.CheckTaskFinished(parent_task_id)) {
      new_deps.emplace_back(parent_task_id);

    }
  }
  task_dep_.AddTaskDep(new_task, new_deps, runnable, num_total_tasks);
  bool scheduled = false;
  if(new_deps.empty()) {
    ScheduleTaskToReadyQueue(new_task);
    scheduled = true;
  } 
  mutex_.unlock();
  if(scheduled) {
    cv_.notify_all();
  }


  return new_task;
}

void TaskSystemParallelThreadPoolSleeping::sync() {

    //
    // TODO: CS149 students will modify the implementation of this method in Part B.
    //
  std::unique_lock&lt;std::mutex&gt; lock(mutex_);
  // In case all threads atre put to sleep

  wait_sync_.store(true);

  while(!ready_queue_.empty() || task_dep_.GetFinishedTaskCount() != task_dep_.GetTotalTaskCount()  ) {
    // printf("finished task count:%d, task_id:%d\n", finished_tasks_.load(), task_id_.load());
    cv_.wait(lock);
    // printf("finished task count:%d, task_id:%d\n", task_dep_.GetFinishedTaskCount(), task_dep_.GetTotalTaskCount());
  }
  wait_sync_.store(false);
    return;
}
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class TaskDep{
public:
  TaskDep();
  void AddTaskDep(TaskID child, std::vector&lt;TaskID&gt; deps, IRunnable* runnable, int num_total_tasks);
  // Who is responsible for call this function?
  // I guess we should just iterate all task_id to see 
  // if we can schedule them.
  // void CheckAndRemoveDep(TaskID child_task_id);
  void FinishTask(TaskID task_id, std::vector&lt;TaskID&gt;&amp; children_tasks);
  TaskID GetNewTaskID();
  int GetFinishedTaskCount() const ;
  int GetTotalTaskCount() const { return task_id_.load();}
  bool CheckTaskFinished(TaskID task_id);
  bool CheckAndGetRunnableTasks(std::vector&lt;TaskID&gt;&amp; tasks);
  bool HasTaskToSchedule() const { return !dependent_parents_.empty();}
  void GetTaskArg(TaskID task_id, TaskArg&amp; task_arg);

private:
  std::atomic&lt;TaskID&gt; task_id_;
  std::unordered_map&lt;TaskID, std::unordered_set&lt;TaskID&gt;&gt; dependent_parents_;
  std::unordered_map&lt;TaskID, std::unordered_set&lt;TaskID&gt;&gt; dependent_children_;
  std::unordered_set&lt;TaskID&gt; finished_task_ids_;
  std::unordered_set&lt;TaskID&gt; scheduled_task_ids_;
  std::unordered_map&lt;TaskID, TaskArg&gt; task_args_;
  std::atomic&lt;int&gt; finished_tasks_;

 
};
/*
 * TaskSystemParallelThreadPoolSleeping: This class is the student's
 * optimized implementation of a parallel task execution engine that uses
 * a thread pool. See definition of ITaskSystem in
 * itasksys.h for documentation of the ITaskSystem interface.
 */
class TaskSystemParallelThreadPoolSleeping: public ITaskSystem {
    public:
        TaskSystemParallelThreadPoolSleeping(int num_threads);
        ~TaskSystemParallelThreadPoolSleeping();
        const char* name();
        void run(IRunnable* runnable, int num_total_tasks);
        TaskID runAsyncWithDeps(IRunnable* runnable, int num_total_tasks,
                                const std::vector&lt;TaskID&gt;&amp; deps);
        void sync();

private:
  void threadTask( );

  bool FinishOneSubTask(TaskID task_id, std::vector&lt;TaskID&gt;&amp; children_task) ;
  void ScheduleTaskToReadyQueue(TaskID task_id);
  std::vector&lt;std::thread&gt; workers_;
  int num_threads_;
  bool done_;
  std::atomic&lt;bool&gt; wait_sync_;
  std::mutex mutex_;
  std::condition_variable cv_;
  std::deque&lt;threadArg&gt; ready_queue_;
  std::unordered_map&lt;TaskID, int&gt; taskid_remain_work_count_map_;
  std::unordered_set&lt;TaskID&gt; scheduled_task_ids_;
  TaskDep task_dep_;


};


</code></pre></div></div> <p>Test Output:</p> <p>Run time is reduced a lot compared to previsou frequent wake up call.</p> <p>But it still does not have similar run time in some case compared to reference implemntation.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Executing test: super_super_light_async...
Reference binary: ./runtasks_ref_linux
Results for: super_super_light_async
                                        STUDENT   REFERENCE   PERF?
[Serial]                                8.756     12.191      0.72  (OK)
[Parallel + Always Spawn]               8.429     55.629      0.15  (OK)
[Parallel + Thread Pool + Spin]         8.556     26.492      0.32  (OK)
[Parallel + Thread Pool + Sleep]        30.866    15.692      1.97  (NOT OK)
================================================================================
Executing test: super_light_async...
Reference binary: ./runtasks_ref_linux
Results for: super_light_async
                                        STUDENT   REFERENCE   PERF?
[Serial]                                81.03     95.452      0.85  (OK)
[Parallel + Always Spawn]               79.448    80.543      0.99  (OK)
[Parallel + Thread Pool + Spin]         80.317    30.917      2.60  (NOT OK)
[Parallel + Thread Pool + Sleep]        37.437    28.054      1.33  (NOT OK)
================================================================================

Executing test: ping_pong_equal_async...
Reference binary: ./runtasks_ref_linux
Results for: ping_pong_equal_async
                                        STUDENT   REFERENCE   PERF?
[Serial]                                1294.45   1544.952    0.84  (OK)
[Parallel + Always Spawn]               1296.49   662.509     1.96  (NOT OK)
[Parallel + Thread Pool + Spin]         1293.489  226.582     5.71  (NOT OK)
[Parallel + Thread Pool + Sleep]        193.945   224.466     0.86  (OK)
================================================================================

Executing test: ping_pong_unequal_async...
Reference binary: ./runtasks_ref_linux
Results for: ping_pong_unequal_async
                                        STUDENT   REFERENCE   PERF?
[Serial]                                2429.01   2399.749    1.01  (OK)
[Parallel + Always Spawn]               2407.208  1001.25     2.40  (NOT OK)
[Parallel + Thread Pool + Spin]         2417.762  334.029     7.24  (NOT OK)
[Parallel + Thread Pool + Sleep]        344.299   328.969     1.05  (OK)

================================================================================
Executing test: recursive_fibonacci_async...
Reference binary: ./runtasks_ref_linux
Results for: recursive_fibonacci_async
                                        STUDENT   REFERENCE   PERF?
[Serial]                                1581.684  1939.945    0.82  (OK)
[Parallel + Always Spawn]               1585.249  556.636     2.85  (NOT OK)
[Parallel + Thread Pool + Spin]         1584.694  258.648     6.13  (NOT OK)
[Parallel + Thread Pool + Sleep]        220.133   254.85      0.86  (OK)

================================================================================
Executing test: math_operations_in_tight_for_loop_async...
Reference binary: ./runtasks_ref_linux
Results for: math_operations_in_tight_for_loop_async
                                        STUDENT   REFERENCE   PERF?
[Serial]                                808.41    856.84      0.94  (OK)
[Parallel + Always Spawn]               811.738   693.496     1.17  (OK)
[Parallel + Thread Pool + Spin]         808.998   145.345     5.57  (NOT OK)
[Parallel + Thread Pool + Sleep]        152.518   142.003     1.07  (OK)
================================================================================

Executing test: math_operations_in_tight_for_loop_fewer_tasks_async...
Reference binary: ./runtasks_ref_linux
Results for: math_operations_in_tight_for_loop_fewer_tasks_async
                                        STUDENT   REFERENCE   PERF?
[Serial]                                812.784   858.997     0.95  (OK)
[Parallel + Always Spawn]               812.874   811.4       1.00  (OK)
[Parallel + Thread Pool + Spin]         810.69    126.379     6.41  (NOT OK)
[Parallel + Thread Pool + Sleep]        122.005   126.256     0.97  (OK)
================================================================================

Executing test: math_operations_in_tight_for_loop_fan_in_async...
Reference binary: ./runtasks_ref_linux
Results for: math_operations_in_tight_for_loop_fan_in_async
                                        STUDENT   REFERENCE   PERF?
[Serial]                                417.681   435.005     0.96  (OK)
[Parallel + Always Spawn]               413.541   244.769     1.69  (NOT OK)
[Parallel + Thread Pool + Spin]         413.021   75.503      5.47  (NOT OK)
[Parallel + Thread Pool + Sleep]        73.391    65.41       1.12  (OK)
================================================================================

Executing test: math_operations_in_tight_for_loop_reduction_tree_async...
Reference binary: ./runtasks_ref_linux
Results for: math_operations_in_tight_for_loop_reduction_tree_async
                                        STUDENT   REFERENCE   PERF?
[Serial]                                413.848   438.395     0.94  (OK)
[Parallel + Always Spawn]               414.925   195.032     2.13  (NOT OK)
[Parallel + Thread Pool + Spin]         414.513   72.565      5.71  (NOT OK)
[Parallel + Thread Pool + Sleep]        59.153    65.233      0.91  (OK)
================================================================================
</code></pre></div></div> <p>So we can get rid of checking each tasks every time to see if it can be scheduled and put to ready queue.</p> <p>My code does not has comparable result compared to ref for super_light_async and super_super_light_async .</p> <p>I think this is because there is still opt space to reduce wake up frequency..</p> <p>I decide to move on with assign3 of cs149 and just leave the current code as it is.</p> <p>Just don’t want to spend time on this and want to spend time on learning some cuda writing.</p> <h3 id="side-knowkedge-buffering-in-python-command">Side knowkedge: buffering in python command</h3> <p><strong>Prompt ** why I don’t see any output from this command but when I remove | tee ./test.out there is output <br><br> python3 ../tests/run_test_harness.py -n 8 -a 2&gt;&amp;1 | tee ./test.out **Response</strong> The issue you’re encountering is likely due to buffering. When you use <code class="language-plaintext highlighter-rouge">tee</code> to redirect output to a file, the output may be buffered, causing it not to appear immediately on the screen.</p> <h3 id="explanation">Explanation:</h3> <ul> <li> <strong>Without <code class="language-plaintext highlighter-rouge">tee</code></strong>: The output is directly sent to the terminal, and you see it immediately.</li> <li> <strong>With <code class="language-plaintext highlighter-rouge">tee</code></strong>: The output is first written to a buffer, which is then written to the file and the terminal. This buffering can delay the appearance of the output.</li> </ul> <h3 id="solution">Solution:</h3> <p>You can use the <code class="language-plaintext highlighter-rouge">-u</code> option with <code class="language-plaintext highlighter-rouge">python3</code> to force the standard streams to be unbuffered. This will ensure that the output appears immediately.</p> <p>Revised command:</p> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python3 <span class="nt">-u</span> ../tests/run_test_harness.py <span class="nt">-n</span> 8 <span class="nt">-a</span> 2&gt;&amp;1 | <span class="nb">tee</span> ./test.out
</code></pre></div></div> <p>This should resolve the issue and allow you to see the output in real-time while still writing it to <code class="language-plaintext highlighter-rouge">test.out</code>.</p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2020/learning-based-memory-allocation-for-c-server-workloads-summary/">Learning-based memory allocation for C++ server workloads summary</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2020/my-question/">my question:</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2021/binary-search-algorithm-variant/">Binary search algorithm variant</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/docker-rocksdb-build/">Docker Rocksdb build</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/difference-between-dockerfile-and-docker-compose/">Difference between Dockerfile and Docker Compose</a> </li> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Zhutao Zhuang. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. Last updated: January 09, 2025. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?b7816bd189846d29eded8745f9c4cf77"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.min.js" integrity="sha256-rjmgmaB99riUNcdlrDtcAiwtLIojSxNyUFdl+Qh+rB4=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script async src="https://www.googletagmanager.com/gtag/js?id="></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","");</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> <script type="module" src="/assets/js/search/ninja-keys.min.js?601a2d3465e2a52bec38b600518d5f70"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script>let theme=determineComputedTheme();const ninjaKeys=document.querySelector("ninja-keys");"dark"===theme?ninjaKeys.classList.add("dark"):ninjaKeys.classList.remove("dark");const openSearchModal=()=>{const e=$("#navbarNav");e.hasClass("show")&&e.collapse("hide"),ninjaKeys.open()};</script> <script>const ninja=document.querySelector("ninja-keys");ninja.data=[{id:"nav-about",title:"about",section:"Navigation",handler:()=>{window.location.href="/"}},{id:"nav-blog",title:"blog",description:"",section:"Navigation",handler:()=>{window.location.href="/blog/"}},{id:"nav-publications",title:"publications",description:"publications by categories in reversed chronological order. generated by jekyll-scholar.",section:"Navigation",handler:()=>{window.location.href="/publications/"}},{id:"post-learned-idnex-survey",title:"Learned idnex survey",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2025/learned-index-survery/"}},{id:"post-chibicc-c-compiler-multi-char-variable-name",title:"chibicc C compiler - multi char variable name",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2025/chibicc-multi-char-var-name/"}},{id:"post-c-and-linux-kernel-memory-allocation",title:"C++ and linux kernel memory allocation",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2025/cpp-interview-questions/"}},{id:"post-chibicc-c-compiler-parser-review-and-expression-evaluator",title:"chibicc C compiler - parser review and expression evaluator",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2025/chibicc-parser-review-and-calculator/"}},{id:"post-imperative-programming-vs-declarative-programming",title:"Imperative programming vs. Declarative programming",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/imperative-programming/"}},{id:"post-autodiff-implementation-kernel-and-memory-management",title:"Autodiff implementation - kernel and memory management",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/uw-sysml-assign2/"}},{id:"post-hash-in-cpp",title:"Hash in cpp",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/hash-in-cpp/"}},{id:"post-computer-basics",title:"Computer basics",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/some-basic-computer-knowledge/"}},{id:"post-rdma",title:"Rdma",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/rdma/"}},{id:"post-topo-sort",title:"Topo sort",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/topo-sort/"}},{id:"post-autodiff-implementation",title:"Autodiff implementation",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/uw-sysml-assign/"}},{id:"post-palindrome-substring-partition",title:"palindrome substring partition",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/palindrome-substring-partition/"}},{id:"post-stf-cs149-flash-attention",title:"Stf CS149 flash attention",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/cs149gpt/"}},{id:"post-speed-up-matrix-multiplication-2",title:"Speed up matrix multiplication 2",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/matrix-mul-comparison/"}},{id:"post-elf-loading",title:"Elf Loading",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/elf-loading/"}},{id:"post-stf-cs149-parallel-programming-assign3",title:"Stf CS149 Parallel Programming - Assign3",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/cs149-assign3/"}},{id:"post-stf-cs149-parallel-programming-lecture11-cache-coherence",title:"Stf CS149 Parallel Programming - Lecture11 - Cache coherence",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/cs149-lecture11-cache-coherence/"}},{id:"post-stf-cs149-parallel-programming-lecture-7-cuda-programming-model",title:"Stf CS149 Parallel Programming - Lecture 7 - Cuda programming model",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/cs149-lecture7-cuda/"}},{id:"post-stf-cs149-parallel-programming-assign2",title:"Stf CS149 Parallel Programming - Assign2",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/cs149-assign2/"}},{id:"post-stf-cs149-parallel-programming-lecture-5-amp-6-performance-optimization",title:"Stf CS149 Parallel Programming - Lecture 5&amp;6 - Performance optimization",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/stf-cs149-lecture-takeaway/"}},{id:"post-stf-cs149-parallel-programming-assign1",title:"Stf CS149 Parallel Programming - Assign1",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/stf-cs149-assign1/"}},{id:"post-ssh-display-image-on-local-server",title:"ssh display image on local server",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/ssh-display-img/"}},{id:"post-c-compiler-single-letter-local-variable",title:"C compiler - single letter local variable",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/chibicc-single-letter-ident/"}},{id:"post-c-compiler-parse-example-walkthrough",title:"C compiler - parse example walkthrough",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/statement-and-comparison/"}},{id:"post-linux-get-cpu-time-and-wall-clock-time",title:"Linux get cpu time and wall clock time",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/get-function-cpu-time/"}},{id:"post-simple-c-compiler-unary",title:"Simple c compiler unary",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/chibicc-unary/"}},{id:"post-simple-c-compiler-gen-expr",title:"Simple c compiler gen expr",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/chibicc-gen-expr/"}},{id:"post-python-pyplot-trick",title:"Python pyplot trick",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/python-plot-trick/"}},{id:"post-simple-lru-cache-cpp-implementation",title:"Simple lru cache cpp implementation",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/lru-cache/"}},{id:"post-python-capture-function-print-output",title:"Python capture function print output",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/capture-output-python/"}},{id:"post-simple-c-compiler",title:"Simple c compiler",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/chibicc-compiler/"}},{id:"post-calloc-and-malloc",title:"calloc and malloc",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/calloc/"}},{id:"post-lightgbm-dataset",title:"LightGBM dataset",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/lightgbm-dataset/"}},{id:"post-difference-between-deep-copy-and-shallow-copy-in-python",title:"Difference between deep copy and shallow copy in python",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/python-deep-copy/"}},{id:"post-python-package-path",title:"Python Package Path",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/python-package-path/"}},{id:"post-micrograd",title:"micrograd",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/micrograd/"}},{id:"post-cpp-thread-local",title:"cpp thread local",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/cpp-thread-local/"}},{id:"post-cpp-async",title:"cpp async",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/cpp-async/"}},{id:"post-python-dataframe-drop-row",title:"python dataframe drop row",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/df-drop-row/"}},{id:"post-git-merge-file-from-another-branch",title:"Git merge file from another branch",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/git-merge-file-from-another-branch/"}},{id:"post-efficiency-tips",title:"Efficiency tips",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/efficiency-tips/"}},{id:"post-speed-up-matrix-multiplication",title:"Speed up matrix multiplication",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/matrix-multiplication/"}},{id:"post-how-to-write-research-paper",title:"How to write research paper",description:"How to write research paper",section:"Posts",handler:()=>{window.location.href="/blog/2024/how-to-write-research-paper/"}},{id:"post-fast-nano-gpt-training",title:"Fast nano-gpt training",description:"llm",section:"Posts",handler:()=>{window.location.href="/blog/2024/gpt-fast/"}},{id:"post-system-for-machine-learning-papers",title:"System for machine learning papers",description:"sysml papers",section:"Posts",handler:()=>{window.location.href="/blog/2024/sysml-papers/"}},{id:"post-nano-gpt-and-transformer",title:"nano-gpt and Transformer",description:"llm",section:"Posts",handler:()=>{window.location.href="/blog/2024/transformer/"}},{id:"post-pytorch-tensor-to",title:"pytorch tensor.to",description:"pytorch",section:"Posts",handler:()=>{window.location.href="/blog/2024/pytorch/"}},{id:"post-install-neovim-with-old-glibc",title:"Install neovim with old glibc",description:"vim",section:"Posts",handler:()=>{window.location.href="/blog/2024/install-neovim/"}},{id:"post-llm-c",title:"llm.c",description:"llm minikune",section:"Posts",handler:()=>{window.location.href="/blog/2024/llm-c/"}},{id:"post-basic-digital-electronic",title:"Basic digital electronic",description:"transistor",section:"Posts",handler:()=>{window.location.href="/blog/2024/digital-electronic/"}},{id:"post-k8s-advance",title:"K8s Advance",description:"k8s minikune",section:"Posts",handler:()=>{window.location.href="/blog/2024/k8s-advance/"}},{id:"post-difference-between-dockerfile-and-docker-compose",title:"Difference between Dockerfile and Docker Compose",description:"",section:"Posts",handler:()=>{window.open("https://bilyz.medium.com/difference-between-dockerfile-and-docker-compose-d6ebdc687785?source=rss-da1663a42461------2","_blank")}},{id:"post-docker-rocksdb-build",title:"Docker Rocksdb build",description:"",section:"Posts",handler:()=>{window.open("https://bilyz.medium.com/docker-rocksdb-build-18a0bf0e0bb0?source=rss-da1663a42461------2","_blank")}},{id:"post-k3s-beginner",title:"K3s beginner",description:"k3s",section:"Posts",handler:()=>{window.location.href="/blog/2024/k3s/"}},{id:"post-docker-rocksdb",title:"Docker RocksDB",description:"cloud",section:"Posts",handler:()=>{window.location.href="/blog/2024/docker-rocksdb/"}},{id:"post-docker-beginner",title:"Docker beginner",description:"cloud",section:"Posts",handler:()=>{window.location.href="/blog/2024/docker-file-compose-diff/"}},{id:"post-git",title:"Git",description:"git",section:"Posts",handler:()=>{window.location.href="/blog/2024/git/"}},{id:"post-lightgbm-usage-and-implementation",title:"LightGBM usage and implementation",description:"Artificial Intelligence",section:"Posts",handler:()=>{window.location.href="/blog/2024/lightgbm-usage/"}},{id:"post-backpropogation-c-implementation",title:"Backpropogation C++ Implementation",description:"Artificial Intelligence",section:"Posts",handler:()=>{window.location.href="/blog/2024/back-propagation/"}},{id:"post-conda-usage",title:"Conda usage",description:"Artificial Intelligence",section:"Posts",handler:()=>{window.location.href="/blog/2024/conda/"}},{id:"post-install-k8s-cluster-with-3-ubuntu-nodes",title:"Install K8s cluster with 3 ubuntu nodes",description:"cloud",section:"Posts",handler:()=>{window.location.href="/blog/2024/cloud/"}},{id:"post-convert-svg-figures-to-pdf-latex-before-submitting-to-arxiv",title:"Convert SVG figures to pdf_latex before submitting to arxiv",description:"Convert SVG figures to pdf_latex before submitting to arxiv",section:"Posts",handler:()=>{window.location.href="/blog/2024/arxiv-cleaner/"}},{id:"post-binary-search-algorithm-variant",title:"Binary search algorithm variant",description:"",section:"Posts",handler:()=>{window.open("https://bilyz.medium.com/binary-search-algorithm-variant-9b5310473471?source=rss-da1663a42461------2","_blank")}},{id:"post-my-question",title:"my question:",description:"",section:"Posts",handler:()=>{window.open("https://bilyz.medium.com/my-question-a69930f167f0?source=rss-da1663a42461------2","_blank")}},{id:"post-learning-based-memory-allocation-for-c-server-workloads-summary",title:"Learning-based memory allocation for C++ server workloads summary",description:"",section:"Posts",handler:()=>{window.open("https://bilyz.medium.com/learning-based-memory-allocation-for-c-server-workloads-summary-479e9cd6d6f6?source=rss-da1663a42461------2","_blank")}},{id:"post-a-post-with-formatting-and-links",title:"a post with formatting and links",description:"march &amp; april, looking forward to summer",section:"Posts",handler:()=>{window.location.href="/blog/2015/formatting-and-links/"}},{id:"news-a-paper-dumpkv-accepted-by-vldb-39-25",title:"A paper(DumpKV) accepted by VLDB&#39;25",description:"",section:"News"},{id:"projects-project-1",title:"project 1",description:"with background image",section:"Projects",handler:()=>{window.location.href="/projects/1_project/"}},{id:"projects-project-2",title:"project 2",description:"a project with a background image and giscus comments",section:"Projects",handler:()=>{window.location.href="/projects/2_project/"}},{id:"projects-project-3-with-very-long-name",title:"project 3 with very long name",description:"a project that redirects to another website",section:"Projects",handler:()=>{window.location.href="/projects/3_project/"}},{id:"projects-project-4",title:"project 4",description:"another without an image",section:"Projects",handler:()=>{window.location.href="/projects/4_project/"}},{id:"projects-project-5",title:"project 5",description:"a project with a background image",section:"Projects",handler:()=>{window.location.href="/projects/5_project/"}},{id:"projects-project-6",title:"project 6",description:"a project with no image",section:"Projects",handler:()=>{window.location.href="/projects/6_project/"}},{id:"socials-email",title:"Send email",section:"Socials",handler:()=>{window.open("mailto:%7A%68%75%61%6E%67%7A%68%75%74%61%6F@%67%6D%61%69%6C.%63%6F%6D","_blank")}},{id:"socials-github",title:"GitHub",section:"Socials",handler:()=>{window.open("https://github.com/BilyZ98","_blank")}},{id:"socials-rss",title:"RSS Feed",section:"Socials",handler:()=>{window.open("/feed.xml","_blank")}},{id:"light-theme",title:"Change theme to light",description:"Change the theme of the site to Light",section:"Theme",handler:()=>{setThemeSetting("light")}},{id:"dark-theme",title:"Change theme to dark",description:"Change the theme of the site to Dark",section:"Theme",handler:()=>{setThemeSetting("dark")}},{id:"system-theme",title:"Use system default theme",description:"Change the theme of the site to System Default",section:"Theme",handler:()=>{setThemeSetting("system")}}];</script> <script src="/assets/js/shortcut-key.js"></script> </body> </html>