<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"> <html><body> <p><a href="https://mp.weixin.qq.com/s/-9RJgcpamtXZOFflOkkt5w" rel="external nofollow noopener" target="_blank">lock free queue impl on wechat subscription post</a></p> <h2 id="why-lock-free">Why lock free?</h2> <p>To avoid lock contention between different threads.</p> <h2 id="how-to-implement-it-">How to implement it ?</h2> <h3 id="list-implementation">List implementation</h3> <p>Is this part of code necessary for correct lock free queue implementation ?</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">next</span><span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">tail</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">oldTail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
    <span class="k">continue</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>Yes, the following part of the code is <strong>necessary</strong> in a <strong>lock-free queue implementation</strong> to maintain correctness and avoid a stuck state:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">next</span><span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">tail</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">oldTail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
    <span class="k">continue</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="why-is-this-necessary"><strong>Why is this necessary?</strong></h3> <p>This block helps in <strong>correctly advancing the <code class="language-plaintext highlighter-rouge">tail</code> pointer</strong> when it <strong>lags behind</strong> the actual last node due to contention. Without it, the queue could become stuck in an inefficient state where the <code class="language-plaintext highlighter-rouge">tail</code> pointer does not point to the actual last node, which may cause issues in subsequent enqueue operations.</p> <hr> <h3 id="example-of-why-this-is-needed"><strong>Example of Why This Is Needed</strong></h3> <p>Assume a <strong>multi-threaded</strong> environment where multiple threads are enqueuing elements.</p> <h4 id="step-by-step-scenario"><strong>Step-by-Step Scenario</strong></h4> <ol> <li> <strong>Initial Queue State</strong> <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>Head ‚Üí A (tail) ‚Üí nullptr
</code></pre></div> </div> <ul> <li> <code class="language-plaintext highlighter-rouge">tail</code> points to <strong>A</strong>.</li> <li> <code class="language-plaintext highlighter-rouge">A-&gt;next</code> is <code class="language-plaintext highlighter-rouge">nullptr</code>.</li> </ul> </li> <li> <strong>Thread T1 begins enqueue(B)</strong> <ul> <li>It <strong>gets <code class="language-plaintext highlighter-rouge">oldTail = A</code></strong>.</li> <li>It <strong>gets <code class="language-plaintext highlighter-rouge">next = nullptr</code></strong>, so it proceeds to insert <code class="language-plaintext highlighter-rouge">B</code>.</li> </ul> </li> <li> <strong>Thread T1 is paused (context switch).</strong> <ul> <li> <code class="language-plaintext highlighter-rouge">oldTail-&gt;next.compare_exchange_weak(next, newNode)</code> is <strong>not executed yet</strong>.</li> <li>Queue state is unchanged.</li> </ul> </li> <li> <strong>Thread T2 starts enqueue(C)</strong> <ul> <li>It also <strong>gets <code class="language-plaintext highlighter-rouge">oldTail = A</code></strong>.</li> <li> <strong>Another Thread T3 already completed enqueue(B)</strong>, so now: <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>Head ‚Üí A ‚Üí B (tail) ‚Üí nullptr
</code></pre></div> </div> </li> <li>Now, <code class="language-plaintext highlighter-rouge">A-&gt;next</code> is <code class="language-plaintext highlighter-rouge">B</code>, but <code class="language-plaintext highlighter-rouge">tail</code> is <strong>still pointing to A</strong>.</li> </ul> </li> <li> <strong>Thread T2 sees that <code class="language-plaintext highlighter-rouge">next != nullptr</code> (<code class="language-plaintext highlighter-rouge">next = B</code>)</strong> <ul> <li>It executes: <div class="language-cpp highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="n">tail</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">oldTail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
</code></pre></div> </div> <ul> <li> <code class="language-plaintext highlighter-rouge">tail</code> is updated from <strong>A to B</strong>.</li> </ul> </li> </ul> </li> <li> <strong>Thread T2 retries the enqueue with <code class="language-plaintext highlighter-rouge">tail = B</code></strong>, allowing proper insertion of <code class="language-plaintext highlighter-rouge">C</code> after <code class="language-plaintext highlighter-rouge">B</code>.</li> </ol> <hr> <h3 id="what-happens-if-this-block-is-removed"><strong>What Happens If This Block Is Removed?</strong></h3> <ul> <li>If <code class="language-plaintext highlighter-rouge">tail.compare_exchange_weak(oldTail, next);</code> is <strong>not</strong> performed, <code class="language-plaintext highlighter-rouge">tail</code> would continue pointing to <strong>A</strong>, even though <code class="language-plaintext highlighter-rouge">A-&gt;next = B</code> exists.</li> <li>This means <strong>new enqueue attempts might repeatedly try inserting after A instead of after B</strong>.</li> <li>In extreme cases, this can lead to a <strong>stalled queue</strong> where elements are not appended correctly.</li> </ul> <hr> <h3 id="conclusion"><strong>Conclusion</strong></h3> <p>The block:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">next</span><span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">tail</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">oldTail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
    <span class="k">continue</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>is necessary to ensure that <code class="language-plaintext highlighter-rouge">tail</code> <strong>keeps up with the actual last node</strong>, preventing it from getting stuck in an outdated position, especially in a concurrent environment.</p> <p>Would you like me to clarify anything further? üöÄ</p> <p>My problematic implementation:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyLockFreeQueue</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">MyLockFreeQueue</span><span class="p">()</span>  <span class="p">{</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SimpleNode</span><span class="p">();</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="n">head_</span> <span class="o">=</span> <span class="n">tail_</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>

  <span class="p">}</span>

  <span class="kt">void</span> <span class="nf">enque</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">SimpleNode</span><span class="o">&gt;</span> <span class="n">node</span><span class="p">(</span><span class="k">new</span> <span class="n">SimpleNode</span><span class="p">());</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">old_tail</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">next</span>  <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>  
    <span class="k">do</span> <span class="p">{</span>
      <span class="n">old_tail</span> <span class="o">=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
      <span class="n">next</span> <span class="o">=</span> <span class="n">old_tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
      <span class="k">if</span><span class="p">(</span><span class="n">old_tail</span> <span class="o">!=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">continue</span><span class="p">;</span>
      
      <span class="p">}</span>

      <span class="k">if</span><span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>

    <span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="n">old_tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="o">==</span> <span class="nb">false</span><span class="p">);</span>
    <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">release</span><span class="p">());</span>
  <span class="p">}</span>

  <span class="kt">bool</span> <span class="nf">deque</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">old_head</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">old_tail</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">next</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="k">do</span> <span class="p">{</span>
      <span class="n">old_head</span> <span class="o">=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
      <span class="n">old_tail</span> <span class="o">=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>

      <span class="c1">// assert(old_head != nullptr);</span>
      <span class="c1">// This line of code is bug</span>
      <span class="n">next</span> <span class="o">=</span> <span class="n">old_head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
      <span class="k">if</span><span class="p">(</span><span class="n">old_head</span> <span class="o">!=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span><span class="p">(</span><span class="n">old_head</span> <span class="o">==</span> <span class="n">old_tail</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">next</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">val</span> <span class="o">=</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="n">head_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_head</span><span class="p">,</span> <span class="n">next</span><span class="p">)</span> <span class="o">==</span> <span class="nb">false</span><span class="p">);</span>
    <span class="k">delete</span> <span class="n">old_head</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>


  <span class="kt">bool</span> <span class="nf">empty</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">()</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">;</span>
  <span class="p">}</span>


  <span class="k">private</span><span class="o">:</span>
  <span class="c1">// size</span>
  <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">size_</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">SimpleNode</span><span class="o">*&gt;</span> <span class="n">head_</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">SimpleNode</span><span class="o">*&gt;</span> <span class="n">tail_</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div> <p>The problem is at deque part. enque has bug in it.</p> <p>Fixed code given by gpt Your <code class="language-plaintext highlighter-rouge">enque()</code> function has <strong>several serious bugs</strong> related to <strong>memory management, atomic operations, and ABA problems</strong>. Let‚Äôs analyze and fix them.</p> <hr> <h2 id="-identified-bugs"><strong>üîç Identified Bugs</strong></h2> <h3 id="1-memory-leak-due-to-stdunique_ptrrelease"><strong>1. Memory Leak Due to <code class="language-plaintext highlighter-rouge">std::unique_ptr::release()</code></strong></h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">SimpleNode</span><span class="o">&gt;</span> <span class="n">node</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">SimpleNode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
</code></pre></div></div> <ul> <li> <code class="language-plaintext highlighter-rouge">node.release()</code> transfers ownership but <strong>does not delete the old pointer</strong> if the enqueue operation fails.</li> <li>If <code class="language-plaintext highlighter-rouge">compare_exchange_weak()</code> fails, the <code class="language-plaintext highlighter-rouge">SimpleNode</code> is <strong>lost</strong> ‚Üí <strong>memory leak</strong>.</li> </ul> <p>‚úÖ <strong>Fix:</strong> Use <code class="language-plaintext highlighter-rouge">std::shared_ptr</code> or manually manage deletion.</p> <hr> <h3 id="2-aba-problem-in-tail_compare_exchange_weak"><strong>2. ABA Problem in <code class="language-plaintext highlighter-rouge">tail_.compare_exchange_weak()</code></strong></h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
    <span class="k">continue</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <ul> <li>If another thread modifies <code class="language-plaintext highlighter-rouge">tail_</code> between these operations, it <strong>could still hold the same value</strong>, leading to a <strong>stale pointer reference</strong>.</li> <li>This introduces <strong>undefined behavior</strong>.</li> </ul> <p>‚úÖ <strong>Fix:</strong> Use a <strong>hazard pointer</strong> (complex) or ensure <code class="language-plaintext highlighter-rouge">next</code> is updated <strong>before</strong> modifying <code class="language-plaintext highlighter-rouge">tail_</code>.</p> <hr> <h3 id="3-incorrect-order-of-compare_exchange_weak"><strong>3. Incorrect Order of <code class="language-plaintext highlighter-rouge">compare_exchange_weak()</code></strong></h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span><span class="p">(</span><span class="n">old_tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="o">==</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div></div> <ul> <li>This assumes <code class="language-plaintext highlighter-rouge">next</code> remains the same between checks, but <strong>other threads could modify it</strong>.</li> <li>This can lead to an <strong>infinite loop or inconsistent state</strong>.</li> </ul> <p>‚úÖ <strong>Fix:</strong> Re-load <code class="language-plaintext highlighter-rouge">next</code> before retrying.</p> <hr> <h3 id="4-potential-infinite-loop-if-tail_-changes-midway"><strong>4. Potential Infinite Loop if <code class="language-plaintext highlighter-rouge">tail_</code> Changes Midway</strong></h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="n">old_tail</span> <span class="o">!=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">continue</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <ul> <li>This check is <strong>not enough</strong> to prevent starvation, as <code class="language-plaintext highlighter-rouge">tail_</code> may change <strong>again</strong> before re-entering the loop.</li> </ul> <p>‚úÖ <strong>Fix:</strong> Ensure a strong atomic operation.</p> <hr> <h2 id="-fixed-code"><strong>‚úÖ Fixed Code</strong></h2> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">enque</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Allocate the new node</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">SimpleNode</span><span class="o">&gt;</span> <span class="n">node</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">SimpleNode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>

    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">old_tail</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">next</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">old_tail</span> <span class="o">=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
        <span class="n">next</span> <span class="o">=</span> <span class="n">old_tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">old_tail</span> <span class="o">!=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span> <span class="c1">// Retry if tail changed</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Help advance tail if it's stale</span>
            <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// Try to attach the new node</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">old_tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">get</span><span class="p">()))</span> <span class="p">{</span>
            <span class="c1">// Successfully linked, now update tail_</span>
            <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">release</span><span class="p">());</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <hr> <h2 id="-summary-of-fixes"><strong>üîë Summary of Fixes</strong></h2> <p>| <strong>Bug</strong> | <strong>Issue</strong> | <strong>Fix</strong> | |‚Äî‚Äî‚Äî|‚Äî‚Äî‚Äî-|‚Äî‚Äî‚Äî| | <strong>Memory Leak</strong> | <code class="language-plaintext highlighter-rouge">node.release()</code> without cleanup | Use <code class="language-plaintext highlighter-rouge">std::unique_ptr</code> safely | | <strong>ABA Problem</strong> | <code class="language-plaintext highlighter-rouge">tail_.compare_exchange_weak()</code> fails if another thread modifies <code class="language-plaintext highlighter-rouge">tail_</code> | Ensure <code class="language-plaintext highlighter-rouge">next</code> is updated before modifying <code class="language-plaintext highlighter-rouge">tail_</code> | | <strong>Order of Operations</strong> | <code class="language-plaintext highlighter-rouge">compare_exchange_weak()</code> on <code class="language-plaintext highlighter-rouge">next</code> may lead to an <strong>infinite loop</strong> | Always reload <code class="language-plaintext highlighter-rouge">next</code> before retrying | | <strong>Stale <code class="language-plaintext highlighter-rouge">tail_</code> Pointer</strong> | <code class="language-plaintext highlighter-rouge">if (old_tail != tail_.load())</code> check is <strong>not strong enough</strong> | Use proper atomic operations |</p> <p>This new implementation <strong>ensures correctness, prevents memory leaks, and avoids infinite loops</strong>. üöÄ</p> <h3 id="what-is-aba-problem-">What is ABA problem ?</h3> <p>The <strong>ABA problem</strong> in software engineering is a well-known issue in <strong>concurrent programming</strong>, particularly in <strong>lock-free data structures</strong> that rely on <strong>compare-and-swap (CAS) operations</strong>.</p> <h3 id="understanding-the-aba-problem"><strong>Understanding the ABA Problem</strong></h3> <ol> <li> <strong>CAS (Compare-And-Swap) Basics</strong> <ul> <li>CAS is an atomic operation used in multi-threading to update a variable only if its value hasn‚Äôt changed since the last check.</li> <li>Example: <div class="language-c highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">atomic_value</span> <span class="o">==</span> <span class="n">expected_value</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">atomic_value</span> <span class="o">=</span> <span class="n">new_value</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> </div> </li> <li>It ensures that updates happen only when no other thread has modified the value.</li> </ul> </li> <li> <strong>The Problem</strong> <ul> <li>If one thread (Thread 1) reads a value (e.g., <strong>A</strong>) from a shared variable, another thread (Thread 2) might change it to <strong>B</strong> and then back to <strong>A</strong> before Thread 1 proceeds.</li> <li>CAS sees <strong>A</strong> as unchanged and allows Thread 1 to proceed, even though the value was modified in between.</li> <li>This can lead to <strong>unexpected behavior</strong> and <strong>data inconsistencies</strong>.</li> </ul> </li> </ol> <h3 id="example-of-the-aba-problem"><strong>Example of the ABA Problem</strong></h3> <h4 id="scenario"><strong>Scenario</strong></h4> <ol> <li> <strong>Thread 1</strong> reads a value <strong>A</strong> from memory.</li> <li> <strong>Thread 2</strong> changes <strong>A ‚Üí B ‚Üí A</strong> (some operation happens in between).</li> <li> <strong>Thread 1</strong> now uses CAS to update <strong>A ‚Üí C</strong>, thinking nothing changed.</li> <li>CAS succeeds because the value is still <strong>A</strong>, but the actual data has been modified!</li> </ol> <h4 id="why-is-this-dangerous"><strong>Why is this Dangerous?</strong></h4> <ul> <li>If a data structure (like a linked list) relies on CAS for safe updates, the ABA problem may lead to <strong>memory corruption</strong>, <strong>lost updates</strong>, or <strong>dangling pointers</strong>.</li> </ul> <h3 id="solutions-to-the-aba-problem"><strong>Solutions to the ABA Problem</strong></h3> <ol> <li> <strong>Tagged Pointers (Version Numbers)</strong> <ul> <li>Instead of just storing <strong>A</strong>, store a <strong>version number</strong> along with the value (e.g., <code class="language-plaintext highlighter-rouge">A1</code>, <code class="language-plaintext highlighter-rouge">B2</code>, <code class="language-plaintext highlighter-rouge">A3</code>).</li> <li>When CAS checks, it verifies both the <strong>value</strong> and the <strong>version</strong>.</li> <li>Example: <div class="language-c highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">AtomicValue</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">version</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div> </div> </li> <li>Even if the value is back to <strong>A</strong>, the version number ensures CAS detects the change.</li> </ul> </li> <li> <strong>Hazard Pointers</strong> <ul> <li>Used in <strong>memory reclamation</strong> to track objects that are still being accessed by threads, preventing premature deletion.</li> </ul> </li> <li> <strong>Read-Copy-Update (RCU)</strong> <ul> <li>Instead of modifying shared data directly, RCU allows <strong>readers to access old versions</strong> while writers update a new copy.</li> </ul> </li> <li> <strong>Double Compare-And-Swap (Double CAS or DCAS)</strong> <ul> <li>Some architectures support <strong>checking two variables at once</strong> (e.g., the value + a version counter).</li> </ul> </li> </ol> <h3 id="where-is-the-aba-problem-common"><strong>Where is the ABA Problem Common?</strong></h3> <ul> <li><strong>Lock-free stacks, queues, and linked lists</strong></li> <li><strong>Garbage collection mechanisms</strong></li> <li><strong>Reference counting</strong></li> <li><strong>Memory allocators</strong></li> </ul> <h2 id="why-continue-is-necessary-in-the-second-if-statement-">Why continue is necessary in the second if statement ?</h2> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">void</span> <span class="nf">enque</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">SimpleNode</span><span class="o">&gt;</span> <span class="n">node</span><span class="p">(</span><span class="k">new</span> <span class="n">SimpleNode</span><span class="p">());</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">old_tail</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">next</span>  <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>  
    <span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">old_tail</span> <span class="o">=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
      <span class="n">next</span> <span class="o">=</span> <span class="n">old_tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
      <span class="k">if</span><span class="p">(</span><span class="n">old_tail</span> <span class="o">!=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">continue</span><span class="p">;</span>
      
      <span class="p">}</span>
      <span class="k">if</span><span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="k">if</span><span class="p">(</span><span class="n">old_tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">get</span><span class="p">()))</span> <span class="p">{</span>

      <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">release</span><span class="p">());</span>
        <span class="k">return</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span> 
  <span class="p">}</span>
</code></pre></div></div> <p>The <strong><code class="language-plaintext highlighter-rouge">continue</code></strong> statement in the second <code class="language-plaintext highlighter-rouge">if</code> condition is necessary to ensure that the <code class="language-plaintext highlighter-rouge">while(true)</code> loop properly retries the enqueue operation when the <code class="language-plaintext highlighter-rouge">tail_</code> pointer is updated asynchronously by another thread.</p> <h3 id="breaking-down-the-code"><strong>Breaking Down the Code</strong></h3> <p>This function implements a <strong>lock-free queue enqueue operation</strong> using <strong>atomic operations</strong> (<code class="language-plaintext highlighter-rouge">compare_exchange_weak</code>) to avoid locks.</p> <h4 id="key-elements-in-the-code"><strong>Key Elements in the Code:</strong></h4> <ul> <li> <code class="language-plaintext highlighter-rouge">tail_</code>: A <strong>lock-free atomic pointer</strong> to the last node in the queue.</li> <li> <code class="language-plaintext highlighter-rouge">next</code>: The next node after <code class="language-plaintext highlighter-rouge">old_tail</code>, used to check if <code class="language-plaintext highlighter-rouge">tail_</code> is up-to-date.</li> <li> <code class="language-plaintext highlighter-rouge">compare_exchange_weak</code>: Used for <strong>atomic updates</strong>, but it may fail if another thread modifies the value simultaneously.</li> </ul> <h3 id="understanding-the-aba-problem-and-the-need-for-continue"><strong>Understanding the ABA Problem and the Need for <code class="language-plaintext highlighter-rouge">continue</code></strong></h3> <ol> <li> <strong>First <code class="language-plaintext highlighter-rouge">if</code>: Detects Stale <code class="language-plaintext highlighter-rouge">tail_</code></strong> <div class="language-cpp highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="n">old_tail</span> <span class="o">!=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">continue</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> </div> <ul> <li>This check ensures that <code class="language-plaintext highlighter-rouge">old_tail</code> is still the actual tail.</li> <li>If another thread updates <code class="language-plaintext highlighter-rouge">tail_</code> during execution, the loop <strong>retries</strong> to reload the new tail.</li> </ul> </li> <li> <strong>Second <code class="language-plaintext highlighter-rouge">if</code>: If <code class="language-plaintext highlighter-rouge">next != nullptr</code>, Another Thread is Advancing <code class="language-plaintext highlighter-rouge">tail_</code></strong> <div class="language-cpp highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
    <span class="k">continue</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> </div> <ul> <li>This means <strong>another thread is in the middle of an enqueue operation</strong> but hasn‚Äôt yet updated <code class="language-plaintext highlighter-rouge">tail_</code> completely.</li> <li>The queue is <strong>inconsistent</strong> at this point: <ul> <li> <code class="language-plaintext highlighter-rouge">old_tail-&gt;next</code> points to <code class="language-plaintext highlighter-rouge">next</code>, but <code class="language-plaintext highlighter-rouge">tail_</code> still points to <code class="language-plaintext highlighter-rouge">old_tail</code>.</li> <li>Our thread helps move <code class="language-plaintext highlighter-rouge">tail_</code> forward to <code class="language-plaintext highlighter-rouge">next</code> before retrying.</li> </ul> </li> <li>The <code class="language-plaintext highlighter-rouge">continue</code> ensures that we <strong>restart</strong> the loop with a fresh state.</li> </ul> </li> <li> <strong>Final Atomic Insert Attempt</strong> <div class="language-cpp highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="n">old_tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">get</span><span class="p">()))</span> <span class="p">{</span>
    <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">release</span><span class="p">());</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> </div> <ul> <li>If <code class="language-plaintext highlighter-rouge">next</code> is <code class="language-plaintext highlighter-rouge">nullptr</code>, we attempt to attach the new node.</li> <li>If successful, we update <code class="language-plaintext highlighter-rouge">tail_</code>.</li> </ul> </li> </ol> <h3 id="why-is-continue-necessary"><strong>Why is <code class="language-plaintext highlighter-rouge">continue</code> Necessary?</strong></h3> <p>Without <code class="language-plaintext highlighter-rouge">continue</code>, after <code class="language-plaintext highlighter-rouge">tail_.compare_exchange_weak(old_tail, next)</code>, the function would <strong>proceed</strong> without restarting the loop. This could result in:</p> <ul> <li> <strong>Using stale values</strong> of <code class="language-plaintext highlighter-rouge">old_tail</code> and <code class="language-plaintext highlighter-rouge">next</code>, potentially leading to incorrect behavior.</li> <li> <strong>A missed enqueue operation</strong>, as we wouldn‚Äôt retry with the new tail node. Which means that the <code class="language-plaintext highlighter-rouge">tail_</code> is not moved forward.</li> </ul> <h3 id="summary"><strong>Summary</strong></h3> <p>The <code class="language-plaintext highlighter-rouge">continue</code> ensures that if <code class="language-plaintext highlighter-rouge">tail_</code> was not pointing to the correct node (due to concurrent updates), the loop <strong>retries from the beginning</strong> with updated values. This is critical for maintaining the correctness of the <strong>lock-free queue</strong> and avoiding race conditions.</p> <h2 id="correct-vs-incorrect-deque">Correct vs. incorrect deque</h2> <p>Correct:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">deque</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">result</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">oldHead</span><span class="p">;</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
    
    <span class="k">do</span> <span class="p">{</span>
        <span class="n">oldHead</span> <span class="o">=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
        <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">oldTail</span> <span class="o">=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
        <span class="n">next</span> <span class="o">=</span> <span class="n">oldHead</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">oldHead</span> <span class="o">!=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span> <span class="c1">// Restart loop if head changed</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">oldHead</span> <span class="o">==</span> <span class="n">oldTail</span><span class="p">)</span> <span class="p">{</span> 
            <span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// Queue is empty</span>
            <span class="p">}</span>
            <span class="c1">// Help advance the tail if it's stuck (optional optimization)</span>
            <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">oldTail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
        <span class="p">}</span>
        
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">head_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">oldHead</span><span class="p">,</span> <span class="n">next</span><span class="p">));</span>

    <span class="c1">// Ensure next is valid before accessing it</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="k">delete</span> <span class="n">oldHead</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// Failsafe check, should not be reached</span>
<span class="p">}</span>
</code></pre></div></div> <p>Incorrect:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">bool</span> <span class="nf">deque</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">old_head</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">old_tail</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">next</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="k">do</span> <span class="p">{</span>
      <span class="n">old_head</span> <span class="o">=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
      <span class="n">old_tail</span> <span class="o">=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
      <span class="n">assert</span><span class="p">(</span><span class="n">old_head</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">);</span>
      <span class="n">next</span> <span class="o">=</span> <span class="n">old_head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
      <span class="k">if</span><span class="p">(</span><span class="n">old_head</span> <span class="o">!=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span><span class="p">(</span><span class="n">old_head</span> <span class="o">==</span> <span class="n">old_tail</span> <span class="o">&amp;&amp;</span> <span class="n">next</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="n">head_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_head</span><span class="p">,</span> <span class="n">next</span><span class="p">)</span> <span class="o">==</span> <span class="nb">false</span><span class="p">);</span>

    <span class="n">val</span> <span class="o">=</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">old_head</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div></div> <p>Explanation from gpt. Basically it means that we need to whether next is nullptr or not. Your <code class="language-plaintext highlighter-rouge">deque</code> function has a <strong>bug that can cause a segmentation fault (crash)</strong> due to <strong>dereferencing a null pointer (<code class="language-plaintext highlighter-rouge">next</code>)</strong> when the queue is empty. Here‚Äôs what happens:</p> <h3 id="identified-bugs"><strong>Identified Bugs:</strong></h3> <ol> <li> <strong>Null Dereference of <code class="language-plaintext highlighter-rouge">next</code></strong> <ul> <li>When <code class="language-plaintext highlighter-rouge">oldHead == oldTail</code> and <code class="language-plaintext highlighter-rouge">next == nullptr</code>, the queue is empty.</li> <li>However, the loop continues, and <code class="language-plaintext highlighter-rouge">next</code> (which is <code class="language-plaintext highlighter-rouge">nullptr</code>) is used in <code class="language-plaintext highlighter-rouge">head_.compare_exchange_weak(oldHead, next)</code>, leading to <strong>undefined behavior</strong>.</li> <li>Also, <code class="language-plaintext highlighter-rouge">result = std::move(next-&gt;val);</code> will crash if <code class="language-plaintext highlighter-rouge">next</code> is <code class="language-plaintext highlighter-rouge">nullptr</code>.</li> </ul> </li> </ol> <h3 id="fixed-code"><strong>Fixed Code</strong></h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">deque</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">result</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">oldHead</span><span class="p">;</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
    
    <span class="k">do</span> <span class="p">{</span>
        <span class="n">oldHead</span> <span class="o">=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
        <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">oldTail</span> <span class="o">=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
        <span class="n">next</span> <span class="o">=</span> <span class="n">oldHead</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">oldHead</span> <span class="o">!=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span> <span class="c1">// Restart loop if head changed</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">oldHead</span> <span class="o">==</span> <span class="n">oldTail</span><span class="p">)</span> <span class="p">{</span> 
            <span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// Queue is empty</span>
            <span class="p">}</span>
            <span class="c1">// Help advance the tail if it's stuck (optional optimization)</span>
            <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">oldTail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
        <span class="p">}</span>
        
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">head_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">oldHead</span><span class="p">,</span> <span class="n">next</span><span class="p">));</span>

    <span class="c1">// Ensure next is valid before accessing it</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="k">delete</span> <span class="n">oldHead</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// Failsafe check, should not be reached</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="fixes--improvements"><strong>Fixes &amp; Improvements</strong></h3> <ol> <li> <strong>Ensured <code class="language-plaintext highlighter-rouge">next</code> is not null before accessing it</strong> <ul> <li>We only proceed if <code class="language-plaintext highlighter-rouge">next</code> is valid.</li> </ul> </li> <li> <strong>Added a tail advancement step</strong> <em>(optional but improves performance)</em> <ul> <li>If <code class="language-plaintext highlighter-rouge">tail_</code> is outdated (<code class="language-plaintext highlighter-rouge">oldTail == oldHead &amp;&amp; next != nullptr</code>), update it to avoid slow tail progression.</li> </ul> </li> <li> <strong>Handled the empty queue case properly</strong> <ul> <li>Now correctly returns <code class="language-plaintext highlighter-rouge">false</code> when the queue is empty without further processing.</li> </ul> </li> </ol> <p>This prevents <strong>segmentation faults</strong>, ensures correct behavior, and slightly optimizes the tail update. üöÄ</p> <h2 id="the-difference-between-two-enque-implementation">The difference between two enque implementation</h2> <p>First one, correct</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">void</span> <span class="nf">enque</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">SimpleNode</span><span class="o">&gt;</span> <span class="n">node</span><span class="p">(</span><span class="k">new</span> <span class="n">SimpleNode</span><span class="p">());</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">old_tail</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">next</span>  <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>  
    <span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">old_tail</span> <span class="o">=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
      <span class="n">next</span> <span class="o">=</span> <span class="n">old_tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
      <span class="k">if</span><span class="p">(</span><span class="n">old_tail</span> <span class="o">!=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">continue</span><span class="p">;</span>
      
      <span class="p">}</span>
      <span class="k">if</span><span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="k">if</span><span class="p">(</span><span class="n">old_tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">get</span><span class="p">()))</span> <span class="p">{</span>

      <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">release</span><span class="p">());</span>
        <span class="k">return</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span> 
  <span class="p">}</span>
</code></pre></div></div> <p>Second one, incorrect</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">void</span> <span class="nf">enque</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SimpleNode</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
        <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">old_tail</span><span class="p">;</span>
        <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>

        <span class="k">do</span> <span class="p">{</span>
            <span class="n">old_tail</span> <span class="o">=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
            <span class="n">next</span> <span class="o">=</span> <span class="n">old_tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">old_tail</span> <span class="o">!=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">())</span> <span class="p">{</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">old_tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">node</span><span class="p">));</span>

        <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
        <span class="n">size_</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div></div> <h3 id="key-difference-when-tail_-is-updated"><strong>Key Difference: When <code class="language-plaintext highlighter-rouge">tail_</code> is Updated</strong></h3> <p>You‚Äôre correct that <strong>both implementations update <code class="language-plaintext highlighter-rouge">tail_</code> only once when successfully adding a node</strong>. However, <strong>the crucial difference is what happens when <code class="language-plaintext highlighter-rouge">next != nullptr</code></strong> (i.e., when another thread is already modifying the queue).</p> <h3 id="first-implementation-correct"><strong>First Implementation (Correct)</strong></h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
    <span class="k">continue</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>üîπ <strong>If another thread is already enqueueing a node (<code class="language-plaintext highlighter-rouge">next != nullptr</code>), we help move <code class="language-plaintext highlighter-rouge">tail_</code> forward before retrying.</strong><br> üîπ This prevents <code class="language-plaintext highlighter-rouge">tail_</code> from becoming stale and ensures it always points to the latest node.</p> <h3 id="second-implementation-incorrect"><strong>Second Implementation (Incorrect)</strong></h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
    <span class="k">continue</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>üîπ <strong>This part is identical</strong>, but <strong>the retry loop does not guarantee that <code class="language-plaintext highlighter-rouge">tail_</code> is updated correctly at the end</strong>.<br> üîπ Since <code class="language-plaintext highlighter-rouge">tail_.compare_exchange_weak(old_tail, node);</code> is <strong>only executed once, outside the loop</strong>, it might miss updates when multiple threads are enqueueing.</p> <hr> <h2 id="example-the-core-issue-in-the-second-implementation"><strong>Example: The Core Issue in the Second Implementation</strong></h2> <p>Let‚Äôs break it down step by step <strong>with two threads (<code class="language-plaintext highlighter-rouge">Thread 1</code> and <code class="language-plaintext highlighter-rouge">Thread 2</code>) enqueuing at the same time</strong>.</p> <h3 id="initial-queue-state"><strong>Initial Queue State</strong></h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HEAD -&gt; Node(A) -&gt; (TAIL)
</code></pre></div></div> <p>Both <code class="language-plaintext highlighter-rouge">head_</code> and <code class="language-plaintext highlighter-rouge">tail_</code> point to <code class="language-plaintext highlighter-rouge">Node(A)</code>.<br> Now, <strong>Thread 1 enqueues <code class="language-plaintext highlighter-rouge">Node(B)</code>, and Thread 2 enqueues <code class="language-plaintext highlighter-rouge">Node(C)</code>.</strong></p> <hr> <h3 id="step-1-both-threads-read-tail_"><strong>Step 1: Both Threads Read <code class="language-plaintext highlighter-rouge">tail_</code></strong></h3> <ul> <li> <strong>Thread 1</strong> reads <code class="language-plaintext highlighter-rouge">tail_ = Node(A)</code>, sees <code class="language-plaintext highlighter-rouge">next = nullptr</code>, and creates <code class="language-plaintext highlighter-rouge">Node(B)</code>.</li> <li> <strong>Thread 2</strong> reads <code class="language-plaintext highlighter-rouge">tail_ = Node(A)</code>, sees <code class="language-plaintext highlighter-rouge">next = nullptr</code>, and creates <code class="language-plaintext highlighter-rouge">Node(C)</code>.</li> </ul> <hr> <h3 id="step-2-thread-1-successfully-adds-nodeb"><strong>Step 2: Thread 1 Successfully Adds <code class="language-plaintext highlighter-rouge">Node(B)</code></strong></h3> <ul> <li> <strong>Thread 1 succeeds</strong> in: <div class="language-cpp highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="n">old_tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">node_B</span><span class="p">);</span>
</code></pre></div> </div> <ul> <li>Now, the queue looks like: <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>HEAD -&gt; Node(A) -&gt; Node(B)
</code></pre></div> </div> </li> </ul> </li> <li><strong>Thread 2 retries because <code class="language-plaintext highlighter-rouge">next</code> is no longer <code class="language-plaintext highlighter-rouge">nullptr</code>!</strong></li> </ul> <hr> <h3 id="step-3-thread-1-updates-tail_"><strong>Step 3: Thread 1 Updates <code class="language-plaintext highlighter-rouge">tail_</code></strong></h3> <ul> <li> <strong>Thread 1 successfully updates <code class="language-plaintext highlighter-rouge">tail_</code> to point to <code class="language-plaintext highlighter-rouge">Node(B)</code>.</strong> <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>HEAD -&gt; Node(A) -&gt; Node(B) -&gt; (TAIL)
</code></pre></div> </div> </li> </ul> <hr> <h3 id="step-4-thread-2-retries"><strong>Step 4: Thread 2 Retries</strong></h3> <ul> <li> <strong>Thread 2 now reads <code class="language-plaintext highlighter-rouge">tail_ = Node(B)</code>, next = <code class="language-plaintext highlighter-rouge">nullptr</code>, and successfully adds <code class="language-plaintext highlighter-rouge">Node(C)</code>.</strong> <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>HEAD -&gt; Node(A) -&gt; Node(B) -&gt; Node(C)
</code></pre></div> </div> </li> <li> <strong>But here‚Äôs the bug in the second implementation:</strong> <ul> <li> <code class="language-plaintext highlighter-rouge">tail_</code> is updated <strong>only once, outside the loop</strong>.</li> <li>If another thread starts enqueueing at the same time, <code class="language-plaintext highlighter-rouge">tail_</code> <strong>might still point to <code class="language-plaintext highlighter-rouge">Node(B)</code> instead of <code class="language-plaintext highlighter-rouge">Node(C)</code>!</strong> </li> <li><strong>Future enqueue operations might have to retry unnecessarily because <code class="language-plaintext highlighter-rouge">tail_</code> is stale.</strong></li> </ul> </li> </ul> <hr> <h3 id="step-5-the-problem-stale-tail_"><strong>Step 5: The Problem (Stale <code class="language-plaintext highlighter-rouge">tail_</code>)</strong></h3> <ul> <li>If a new thread tries to enqueue <code class="language-plaintext highlighter-rouge">Node(D)</code>, it <strong>may still see <code class="language-plaintext highlighter-rouge">tail_ = Node(B)</code>, instead of <code class="language-plaintext highlighter-rouge">Node(C)</code>.</strong> </li> <li>This forces unnecessary retries, slowing down the queue.</li> </ul> <hr> <h2 id="why-the-first-implementation-avoids-this"><strong>Why the First Implementation Avoids This</strong></h2> <p>In the <strong>first implementation</strong>, if another thread is already in the middle of an enqueue (i.e., <code class="language-plaintext highlighter-rouge">next != nullptr</code>), it <strong>helps move <code class="language-plaintext highlighter-rouge">tail_</code> forward before retrying.</strong></p> <h3 id="why-this-matters"><strong>Why This Matters</strong></h3> <p>Imagine <code class="language-plaintext highlighter-rouge">Thread 1</code> enqueues <code class="language-plaintext highlighter-rouge">Node(B)</code>, and <code class="language-plaintext highlighter-rouge">Thread 2</code> enqueues <code class="language-plaintext highlighter-rouge">Node(C)</code>.</p> <ul> <li><strong>In the first implementation, <code class="language-plaintext highlighter-rouge">Thread 2</code> would help move <code class="language-plaintext highlighter-rouge">tail_</code> to <code class="language-plaintext highlighter-rouge">Node(B)</code> before proceeding.</strong></li> <li><strong>This guarantees that when it enqueues <code class="language-plaintext highlighter-rouge">Node(C)</code>, <code class="language-plaintext highlighter-rouge">tail_</code> will be updated correctly.</strong></li> </ul> <p>By continuously ensuring that <code class="language-plaintext highlighter-rouge">tail_</code> is moved forward <strong>before retrying</strong>, the first implementation guarantees that <code class="language-plaintext highlighter-rouge">tail_</code> <strong>always</strong> points to the most recently enqueued node.</p> <hr> <h2 id="summary-of-the-core-difference"><strong>Summary of the Core Difference</strong></h2> <p>| Feature | <strong>First Implementation (Correct)</strong> | <strong>Second Implementation (Incorrect)</strong> | |‚Äî‚Äî‚Äî|‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî-|‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî-| | <strong>What happens when <code class="language-plaintext highlighter-rouge">next != nullptr</code>?</strong> | Moves <code class="language-plaintext highlighter-rouge">tail_</code> forward before retrying. | Just retries without ensuring <code class="language-plaintext highlighter-rouge">tail_</code> is updated correctly. | | <strong>Ensures <code class="language-plaintext highlighter-rouge">tail_</code> always points to the latest node?</strong> | ‚úÖ Yes | ‚ùå No, <code class="language-plaintext highlighter-rouge">tail_</code> might point to an old node. | | <strong>Potential issue?</strong> | No inefficiencies, always correct. | <code class="language-plaintext highlighter-rouge">tail_</code> can become stale, causing unnecessary retries. | | <strong>Performance impact</strong> | More efficient, fewer retries. | Less efficient, more retries needed. |</p> <hr> <h3 id="final-takeaway"><strong>Final Takeaway</strong></h3> <p><strong>The key reason the first implementation is correct is that it ensures <code class="language-plaintext highlighter-rouge">tail_</code> is always moved forward before retrying.</strong><br> Without this, the second implementation <strong>allows <code class="language-plaintext highlighter-rouge">tail_</code> to become stale</strong>, which slows down the queue by forcing unnecessary retries.</p> <hr> <p>I still don‚Äôt get it. Why the second implementation is incorrect ?</p> <p>You‚Äôre absolutely right that <strong>other threads can help move <code class="language-plaintext highlighter-rouge">tail_</code> forward</strong>‚Äîthis is the whole idea behind a lock-free queue! However, the second implementation <strong>still has a correctness issue</strong> because it does not ensure that <code class="language-plaintext highlighter-rouge">tail_</code> is updated reliably <strong>before finishing the enqueue operation</strong>.</p> <p>Let‚Äôs clarify <strong>why this is a problem even though other threads can help move <code class="language-plaintext highlighter-rouge">tail_</code> forward.</strong></p> <hr> <h2 id="key-question"><strong>Key Question</strong></h2> <p>Since other threads can update <code class="language-plaintext highlighter-rouge">tail_</code>, why is the second implementation still incorrect?</p> <h3 id="answer"><strong>Answer:</strong></h3> <p>Even though other threads <strong>may</strong> update <code class="language-plaintext highlighter-rouge">tail_</code>, the second implementation <strong>relies on them to fix the issue rather than guaranteeing correctness itself.</strong><br> This creates a <strong>non-deterministic behavior</strong> where <code class="language-plaintext highlighter-rouge">tail_</code> <strong>might or might not</strong> point to the latest node, depending on thread timing.</p> <hr> <h2 id="breaking-it-down-step-by-step"><strong>Breaking It Down Step by Step</strong></h2> <p>Let‚Äôs assume <strong>three threads (<code class="language-plaintext highlighter-rouge">T1</code>, <code class="language-plaintext highlighter-rouge">T2</code>, and <code class="language-plaintext highlighter-rouge">T3</code>) are enqueuing at the same time</strong> to see where the second implementation fails.</p> <h3 id="initial-state"><strong>Initial State</strong></h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HEAD -&gt; Node(A) (tail_)
</code></pre></div></div> <ul> <li> <code class="language-plaintext highlighter-rouge">head_</code> and <code class="language-plaintext highlighter-rouge">tail_</code> both point to <code class="language-plaintext highlighter-rouge">Node(A)</code>.</li> <li>Now three threads start enqueueing.</li> </ul> <hr> <h3 id="step-1-t1-successfully-enqueues-nodeb"><strong>Step 1: T1 Successfully Enqueues <code class="language-plaintext highlighter-rouge">Node(B)</code></strong></h3> <ul> <li> <code class="language-plaintext highlighter-rouge">T1</code> successfully attaches <code class="language-plaintext highlighter-rouge">Node(B)</code>: <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>HEAD -&gt; Node(A) -&gt; Node(B)
</code></pre></div> </div> </li> <li>But <code class="language-plaintext highlighter-rouge">tail_</code> is <strong>still pointing to <code class="language-plaintext highlighter-rouge">Node(A)</code></strong>.</li> <li>Before <code class="language-plaintext highlighter-rouge">T1</code> can update <code class="language-plaintext highlighter-rouge">tail_</code>, <strong>T2 and T3 start running.</strong> </li> </ul> <hr> <h3 id="step-2-t2-reads-stale-tail_--nodea-tries-to-enqueue-nodec"><strong>Step 2: T2 Reads Stale <code class="language-plaintext highlighter-rouge">tail_ = Node(A)</code>, Tries to Enqueue <code class="language-plaintext highlighter-rouge">Node(C)</code></strong></h3> <ul> <li> <code class="language-plaintext highlighter-rouge">T2</code> reads: <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>old_tail = Node(A), next = Node(B)
</code></pre></div> </div> </li> <li>Since <code class="language-plaintext highlighter-rouge">next != nullptr</code>, <strong>it helps move <code class="language-plaintext highlighter-rouge">tail_</code> to <code class="language-plaintext highlighter-rouge">Node(B)</code>, then retries.</strong> </li> <li><strong>Now <code class="language-plaintext highlighter-rouge">tail_ = Node(B)</code>.</strong></li> </ul> <hr> <h3 id="step-3-t2-successfully-enqueues-nodec"><strong>Step 3: T2 Successfully Enqueues <code class="language-plaintext highlighter-rouge">Node(C)</code></strong></h3> <ul> <li> <code class="language-plaintext highlighter-rouge">T2</code> now enqueues <code class="language-plaintext highlighter-rouge">Node(C)</code>: <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>HEAD -&gt; Node(A) -&gt; Node(B) -&gt; Node(C)
</code></pre></div> </div> </li> <li>But <code class="language-plaintext highlighter-rouge">tail_</code> <strong>is still pointing to <code class="language-plaintext highlighter-rouge">Node(B)</code></strong>.</li> <li>Before <code class="language-plaintext highlighter-rouge">T2</code> updates <code class="language-plaintext highlighter-rouge">tail_</code>, <strong>T3 starts running.</strong> </li> </ul> <hr> <h3 id="step-4-t3-reads-stale-tail_--nodeb-tries-to-enqueue-noded"><strong>Step 4: T3 Reads Stale <code class="language-plaintext highlighter-rouge">tail_ = Node(B)</code>, Tries to Enqueue <code class="language-plaintext highlighter-rouge">Node(D)</code></strong></h3> <ul> <li> <code class="language-plaintext highlighter-rouge">T3</code> reads: <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>old_tail = Node(B), next = Node(C)
</code></pre></div> </div> </li> <li>Since <code class="language-plaintext highlighter-rouge">next != nullptr</code>, <strong>it helps move <code class="language-plaintext highlighter-rouge">tail_</code> to <code class="language-plaintext highlighter-rouge">Node(C)</code>, then retries.</strong> </li> <li><strong>Now <code class="language-plaintext highlighter-rouge">tail_ = Node(C)</code>.</strong></li> </ul> <hr> <h3 id="step-5-t3-successfully-enqueues-noded"><strong>Step 5: T3 Successfully Enqueues <code class="language-plaintext highlighter-rouge">Node(D)</code></strong></h3> <ul> <li> <code class="language-plaintext highlighter-rouge">T3</code> enqueues <code class="language-plaintext highlighter-rouge">Node(D)</code>: <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>HEAD -&gt; Node(A) -&gt; Node(B) -&gt; Node(C) -&gt; Node(D)
</code></pre></div> </div> </li> <li>But <code class="language-plaintext highlighter-rouge">tail_</code> is <strong>still pointing to <code class="language-plaintext highlighter-rouge">Node(C)</code></strong>.</li> <li>If <strong>no other thread updates <code class="language-plaintext highlighter-rouge">tail_</code> now, it remains stale!</strong> </li> </ul> <hr> <h2 id="the-core-problem-in-the-second-implementation"><strong>The Core Problem in the Second Implementation</strong></h2> <p>If <strong>all threads finish</strong> and no new thread is enqueueing, <code class="language-plaintext highlighter-rouge">tail_</code> <strong>might be stuck at an old node</strong> (e.g., <code class="language-plaintext highlighter-rouge">Node(C)</code> instead of <code class="language-plaintext highlighter-rouge">Node(D)</code>).</p> <p>This <strong>isn‚Äôt guaranteed to cause a failure immediately</strong>, but it creates two major issues:</p> <ol> <li> <strong>Future threads must do extra retries to move <code class="language-plaintext highlighter-rouge">tail_</code> forward.</strong> <ul> <li>If <code class="language-plaintext highlighter-rouge">tail_</code> lags behind, future enqueue operations will see <code class="language-plaintext highlighter-rouge">next != nullptr</code> and must <strong>repeatedly help move <code class="language-plaintext highlighter-rouge">tail_</code> forward before enqueuing.</strong> </li> <li>This <strong>adds unnecessary contention and performance overhead.</strong> </li> </ul> </li> <li> <strong>If a dequeue operation runs now, it may have to traverse multiple nodes before reaching <code class="language-plaintext highlighter-rouge">tail_</code>.</strong> <ul> <li>A correct <code class="language-plaintext highlighter-rouge">tail_</code> should always point to the last node, minimizing the traversal cost for future operations.</li> </ul> </li> </ol> <h3 id="why-doesnt-this-happen-in-the-first-implementation"><strong>Why Doesn‚Äôt This Happen in the First Implementation?</strong></h3> <p>The <strong>first implementation guarantees that <code class="language-plaintext highlighter-rouge">tail_</code> always points to the latest node before returning</strong>:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
    <span class="k">continue</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <ul> <li>If <code class="language-plaintext highlighter-rouge">next != nullptr</code>, we <strong>keep updating <code class="language-plaintext highlighter-rouge">tail_</code> and retrying until we attach our node to the latest position</strong>.</li> <li>This ensures that when the function exits, <code class="language-plaintext highlighter-rouge">tail_</code> <strong>always points to the correct last node</strong>.</li> </ul> <hr> <h2 id="final-takeaway-1"><strong>Final Takeaway</strong></h2> <p>üîπ <strong>Yes, other threads can update <code class="language-plaintext highlighter-rouge">tail_</code>, but the second implementation relies on this happening rather than guaranteeing correctness itself.</strong><br> üîπ <strong>If no other thread updates <code class="language-plaintext highlighter-rouge">tail_</code>, <code class="language-plaintext highlighter-rouge">tail_</code> can become stale, leading to inefficiencies and unnecessary retries.</strong><br> üîπ The <strong>first implementation actively ensures <code class="language-plaintext highlighter-rouge">tail_</code> is always updated before returning</strong>, making it more robust and efficient.</p> <p>I still don‚Äôt get it. I will just give up then. At least I learn what‚Äôs the correct implementaion of lock free queue.</p> </body></html>