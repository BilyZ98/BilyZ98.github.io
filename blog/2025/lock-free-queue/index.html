<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Lock free queue implementation cpp | Zhutao Zhuang </title> <meta name="author" content="Zhutao Zhuang"> <meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. "> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://bilyz98.github.io/blog/2025/lock-free-queue/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Zhutao</span> Zhuang </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Lock free queue implementation cpp</h1> <p class="post-meta"> Created in January 19, 2025 </p> <p class="post-tags"> <a href="/blog/2025"> <i class="fa-solid fa-calendar fa-sm"></i> 2025 </a> ¬† ¬∑ ¬† <a href="/blog/tag/cpp"> <i class="fa-solid fa-hashtag fa-sm"></i> cpp</a> ¬† <a href="/blog/tag/queue"> <i class="fa-solid fa-hashtag fa-sm"></i> queue</a> ¬† ¬∑ ¬† <a href="/blog/category/backend"> <i class="fa-solid fa-tag fa-sm"></i> backend</a> ¬† <a href="/blog/category/concurrent-programming"> <i class="fa-solid fa-tag fa-sm"></i> concurrent-programming</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <p><a href="https://mp.weixin.qq.com/s/-9RJgcpamtXZOFflOkkt5w" rel="external nofollow noopener" target="_blank">lock free queue impl on wechat subscription post</a></p> <h2 id="why-lock-free">Why lock free?</h2> <p>To avoid lock contention between different threads.</p> <h2 id="how-to-implement-it-">How to implement it ?</h2> <h3 id="list-implementation">List implementation</h3> <p>Is this part of code necessary for correct lock free queue implementation ?</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">next</span><span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">tail</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">oldTail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
    <span class="k">continue</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>Yes, the following part of the code is <strong>necessary</strong> in a <strong>lock-free queue implementation</strong> to maintain correctness and avoid a stuck state:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">next</span><span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">tail</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">oldTail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
    <span class="k">continue</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="why-is-this-necessary"><strong>Why is this necessary?</strong></h3> <p>This block helps in <strong>correctly advancing the <code class="language-plaintext highlighter-rouge">tail</code> pointer</strong> when it <strong>lags behind</strong> the actual last node due to contention. Without it, the queue could become stuck in an inefficient state where the <code class="language-plaintext highlighter-rouge">tail</code> pointer does not point to the actual last node, which may cause issues in subsequent enqueue operations.</p> <hr> <h3 id="example-of-why-this-is-needed"><strong>Example of Why This Is Needed</strong></h3> <p>Assume a <strong>multi-threaded</strong> environment where multiple threads are enqueuing elements.</p> <h4 id="step-by-step-scenario"><strong>Step-by-Step Scenario</strong></h4> <ol> <li> <strong>Initial Queue State</strong> <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>Head ‚Üí A (tail) ‚Üí nullptr
</code></pre></div> </div> <ul> <li> <code class="language-plaintext highlighter-rouge">tail</code> points to <strong>A</strong>.</li> <li> <code class="language-plaintext highlighter-rouge">A-&gt;next</code> is <code class="language-plaintext highlighter-rouge">nullptr</code>.</li> </ul> </li> <li> <strong>Thread T1 begins enqueue(B)</strong> <ul> <li>It <strong>gets <code class="language-plaintext highlighter-rouge">oldTail = A</code></strong>.</li> <li>It <strong>gets <code class="language-plaintext highlighter-rouge">next = nullptr</code></strong>, so it proceeds to insert <code class="language-plaintext highlighter-rouge">B</code>.</li> </ul> </li> <li> <strong>Thread T1 is paused (context switch).</strong> <ul> <li> <code class="language-plaintext highlighter-rouge">oldTail-&gt;next.compare_exchange_weak(next, newNode)</code> is <strong>not executed yet</strong>.</li> <li>Queue state is unchanged.</li> </ul> </li> <li> <strong>Thread T2 starts enqueue(C)</strong> <ul> <li>It also <strong>gets <code class="language-plaintext highlighter-rouge">oldTail = A</code></strong>.</li> <li> <strong>Another Thread T3 already completed enqueue(B)</strong>, so now: <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>Head ‚Üí A ‚Üí B (tail) ‚Üí nullptr
</code></pre></div> </div> </li> <li>Now, <code class="language-plaintext highlighter-rouge">A-&gt;next</code> is <code class="language-plaintext highlighter-rouge">B</code>, but <code class="language-plaintext highlighter-rouge">tail</code> is <strong>still pointing to A</strong>.</li> </ul> </li> <li> <strong>Thread T2 sees that <code class="language-plaintext highlighter-rouge">next != nullptr</code> (<code class="language-plaintext highlighter-rouge">next = B</code>)</strong> <ul> <li>It executes: <div class="language-cpp highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="n">tail</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">oldTail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
</code></pre></div> </div> <ul> <li> <code class="language-plaintext highlighter-rouge">tail</code> is updated from <strong>A to B</strong>.</li> </ul> </li> </ul> </li> <li> <strong>Thread T2 retries the enqueue with <code class="language-plaintext highlighter-rouge">tail = B</code></strong>, allowing proper insertion of <code class="language-plaintext highlighter-rouge">C</code> after <code class="language-plaintext highlighter-rouge">B</code>.</li> </ol> <hr> <h3 id="what-happens-if-this-block-is-removed"><strong>What Happens If This Block Is Removed?</strong></h3> <ul> <li>If <code class="language-plaintext highlighter-rouge">tail.compare_exchange_weak(oldTail, next);</code> is <strong>not</strong> performed, <code class="language-plaintext highlighter-rouge">tail</code> would continue pointing to <strong>A</strong>, even though <code class="language-plaintext highlighter-rouge">A-&gt;next = B</code> exists.</li> <li>This means <strong>new enqueue attempts might repeatedly try inserting after A instead of after B</strong>.</li> <li>In extreme cases, this can lead to a <strong>stalled queue</strong> where elements are not appended correctly.</li> </ul> <hr> <h3 id="conclusion"><strong>Conclusion</strong></h3> <p>The block:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">next</span><span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">tail</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">oldTail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
    <span class="k">continue</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>is necessary to ensure that <code class="language-plaintext highlighter-rouge">tail</code> <strong>keeps up with the actual last node</strong>, preventing it from getting stuck in an outdated position, especially in a concurrent environment.</p> <p>Would you like me to clarify anything further? üöÄ</p> <p>My problematic implementation:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyLockFreeQueue</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">MyLockFreeQueue</span><span class="p">()</span>  <span class="p">{</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SimpleNode</span><span class="p">();</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="n">head_</span> <span class="o">=</span> <span class="n">tail_</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>

  <span class="p">}</span>

  <span class="kt">void</span> <span class="nf">enque</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">SimpleNode</span><span class="o">&gt;</span> <span class="n">node</span><span class="p">(</span><span class="k">new</span> <span class="n">SimpleNode</span><span class="p">());</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">old_tail</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">next</span>  <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>  
    <span class="k">do</span> <span class="p">{</span>
      <span class="n">old_tail</span> <span class="o">=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
      <span class="n">next</span> <span class="o">=</span> <span class="n">old_tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
      <span class="k">if</span><span class="p">(</span><span class="n">old_tail</span> <span class="o">!=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">continue</span><span class="p">;</span>
      
      <span class="p">}</span>

      <span class="k">if</span><span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>

    <span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="n">old_tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="o">==</span> <span class="nb">false</span><span class="p">);</span>
    <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">release</span><span class="p">());</span>
  <span class="p">}</span>

  <span class="kt">bool</span> <span class="nf">deque</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">old_head</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">old_tail</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">next</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="k">do</span> <span class="p">{</span>
      <span class="n">old_head</span> <span class="o">=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
      <span class="n">old_tail</span> <span class="o">=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>

      <span class="c1">// assert(old_head != nullptr);</span>
      <span class="c1">// This line of code is bug</span>
      <span class="n">next</span> <span class="o">=</span> <span class="n">old_head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
      <span class="k">if</span><span class="p">(</span><span class="n">old_head</span> <span class="o">!=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span><span class="p">(</span><span class="n">old_head</span> <span class="o">==</span> <span class="n">old_tail</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">next</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">val</span> <span class="o">=</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="n">head_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_head</span><span class="p">,</span> <span class="n">next</span><span class="p">)</span> <span class="o">==</span> <span class="nb">false</span><span class="p">);</span>
    <span class="k">delete</span> <span class="n">old_head</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>


  <span class="kt">bool</span> <span class="nf">empty</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">()</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">;</span>
  <span class="p">}</span>


  <span class="k">private</span><span class="o">:</span>
  <span class="c1">// size</span>
  <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">size_</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">SimpleNode</span><span class="o">*&gt;</span> <span class="n">head_</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">SimpleNode</span><span class="o">*&gt;</span> <span class="n">tail_</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div> <p>The problem is at deque part. enque has bug in it.</p> <p>Fixed code given by gpt Your <code class="language-plaintext highlighter-rouge">enque()</code> function has <strong>several serious bugs</strong> related to <strong>memory management, atomic operations, and ABA problems</strong>. Let‚Äôs analyze and fix them.</p> <hr> <h2 id="-identified-bugs"><strong>üîç Identified Bugs</strong></h2> <h3 id="1-memory-leak-due-to-stdunique_ptrrelease"><strong>1. Memory Leak Due to <code class="language-plaintext highlighter-rouge">std::unique_ptr::release()</code></strong></h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">SimpleNode</span><span class="o">&gt;</span> <span class="n">node</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">SimpleNode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
</code></pre></div></div> <ul> <li> <code class="language-plaintext highlighter-rouge">node.release()</code> transfers ownership but <strong>does not delete the old pointer</strong> if the enqueue operation fails.</li> <li>If <code class="language-plaintext highlighter-rouge">compare_exchange_weak()</code> fails, the <code class="language-plaintext highlighter-rouge">SimpleNode</code> is <strong>lost</strong> ‚Üí <strong>memory leak</strong>.</li> </ul> <p>‚úÖ <strong>Fix:</strong> Use <code class="language-plaintext highlighter-rouge">std::shared_ptr</code> or manually manage deletion.</p> <hr> <h3 id="2-aba-problem-in-tail_compare_exchange_weak"><strong>2. ABA Problem in <code class="language-plaintext highlighter-rouge">tail_.compare_exchange_weak()</code></strong></h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
    <span class="k">continue</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <ul> <li>If another thread modifies <code class="language-plaintext highlighter-rouge">tail_</code> between these operations, it <strong>could still hold the same value</strong>, leading to a <strong>stale pointer reference</strong>.</li> <li>This introduces <strong>undefined behavior</strong>.</li> </ul> <p>‚úÖ <strong>Fix:</strong> Use a <strong>hazard pointer</strong> (complex) or ensure <code class="language-plaintext highlighter-rouge">next</code> is updated <strong>before</strong> modifying <code class="language-plaintext highlighter-rouge">tail_</code>.</p> <hr> <h3 id="3-incorrect-order-of-compare_exchange_weak"><strong>3. Incorrect Order of <code class="language-plaintext highlighter-rouge">compare_exchange_weak()</code></strong></h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span><span class="p">(</span><span class="n">old_tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="o">==</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div></div> <ul> <li>This assumes <code class="language-plaintext highlighter-rouge">next</code> remains the same between checks, but <strong>other threads could modify it</strong>.</li> <li>This can lead to an <strong>infinite loop or inconsistent state</strong>.</li> </ul> <p>‚úÖ <strong>Fix:</strong> Re-load <code class="language-plaintext highlighter-rouge">next</code> before retrying.</p> <hr> <h3 id="4-potential-infinite-loop-if-tail_-changes-midway"><strong>4. Potential Infinite Loop if <code class="language-plaintext highlighter-rouge">tail_</code> Changes Midway</strong></h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="n">old_tail</span> <span class="o">!=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">continue</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <ul> <li>This check is <strong>not enough</strong> to prevent starvation, as <code class="language-plaintext highlighter-rouge">tail_</code> may change <strong>again</strong> before re-entering the loop.</li> </ul> <p>‚úÖ <strong>Fix:</strong> Ensure a strong atomic operation.</p> <hr> <h2 id="-fixed-code"><strong>‚úÖ Fixed Code</strong></h2> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">enque</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Allocate the new node</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">SimpleNode</span><span class="o">&gt;</span> <span class="n">node</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">SimpleNode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>

    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">old_tail</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">next</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">old_tail</span> <span class="o">=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
        <span class="n">next</span> <span class="o">=</span> <span class="n">old_tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">old_tail</span> <span class="o">!=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span> <span class="c1">// Retry if tail changed</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Help advance tail if it's stale</span>
            <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// Try to attach the new node</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">old_tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">get</span><span class="p">()))</span> <span class="p">{</span>
            <span class="c1">// Successfully linked, now update tail_</span>
            <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">release</span><span class="p">());</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <hr> <h2 id="-summary-of-fixes"><strong>üîë Summary of Fixes</strong></h2> <p>| <strong>Bug</strong> | <strong>Issue</strong> | <strong>Fix</strong> | |‚Äî‚Äî‚Äî|‚Äî‚Äî‚Äî-|‚Äî‚Äî‚Äî| | <strong>Memory Leak</strong> | <code class="language-plaintext highlighter-rouge">node.release()</code> without cleanup | Use <code class="language-plaintext highlighter-rouge">std::unique_ptr</code> safely | | <strong>ABA Problem</strong> | <code class="language-plaintext highlighter-rouge">tail_.compare_exchange_weak()</code> fails if another thread modifies <code class="language-plaintext highlighter-rouge">tail_</code> | Ensure <code class="language-plaintext highlighter-rouge">next</code> is updated before modifying <code class="language-plaintext highlighter-rouge">tail_</code> | | <strong>Order of Operations</strong> | <code class="language-plaintext highlighter-rouge">compare_exchange_weak()</code> on <code class="language-plaintext highlighter-rouge">next</code> may lead to an <strong>infinite loop</strong> | Always reload <code class="language-plaintext highlighter-rouge">next</code> before retrying | | <strong>Stale <code class="language-plaintext highlighter-rouge">tail_</code> Pointer</strong> | <code class="language-plaintext highlighter-rouge">if (old_tail != tail_.load())</code> check is <strong>not strong enough</strong> | Use proper atomic operations |</p> <p>This new implementation <strong>ensures correctness, prevents memory leaks, and avoids infinite loops</strong>. üöÄ</p> <h3 id="what-is-aba-problem-">What is ABA problem ?</h3> <p>The <strong>ABA problem</strong> in software engineering is a well-known issue in <strong>concurrent programming</strong>, particularly in <strong>lock-free data structures</strong> that rely on <strong>compare-and-swap (CAS) operations</strong>.</p> <h3 id="understanding-the-aba-problem"><strong>Understanding the ABA Problem</strong></h3> <ol> <li> <strong>CAS (Compare-And-Swap) Basics</strong> <ul> <li>CAS is an atomic operation used in multi-threading to update a variable only if its value hasn‚Äôt changed since the last check.</li> <li>Example: <div class="language-c highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">atomic_value</span> <span class="o">==</span> <span class="n">expected_value</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">atomic_value</span> <span class="o">=</span> <span class="n">new_value</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> </div> </li> <li>It ensures that updates happen only when no other thread has modified the value.</li> </ul> </li> <li> <strong>The Problem</strong> <ul> <li>If one thread (Thread 1) reads a value (e.g., <strong>A</strong>) from a shared variable, another thread (Thread 2) might change it to <strong>B</strong> and then back to <strong>A</strong> before Thread 1 proceeds.</li> <li>CAS sees <strong>A</strong> as unchanged and allows Thread 1 to proceed, even though the value was modified in between.</li> <li>This can lead to <strong>unexpected behavior</strong> and <strong>data inconsistencies</strong>.</li> </ul> </li> </ol> <h3 id="example-of-the-aba-problem"><strong>Example of the ABA Problem</strong></h3> <h4 id="scenario"><strong>Scenario</strong></h4> <ol> <li> <strong>Thread 1</strong> reads a value <strong>A</strong> from memory.</li> <li> <strong>Thread 2</strong> changes <strong>A ‚Üí B ‚Üí A</strong> (some operation happens in between).</li> <li> <strong>Thread 1</strong> now uses CAS to update <strong>A ‚Üí C</strong>, thinking nothing changed.</li> <li>CAS succeeds because the value is still <strong>A</strong>, but the actual data has been modified!</li> </ol> <h4 id="why-is-this-dangerous"><strong>Why is this Dangerous?</strong></h4> <ul> <li>If a data structure (like a linked list) relies on CAS for safe updates, the ABA problem may lead to <strong>memory corruption</strong>, <strong>lost updates</strong>, or <strong>dangling pointers</strong>.</li> </ul> <h3 id="solutions-to-the-aba-problem"><strong>Solutions to the ABA Problem</strong></h3> <ol> <li> <strong>Tagged Pointers (Version Numbers)</strong> <ul> <li>Instead of just storing <strong>A</strong>, store a <strong>version number</strong> along with the value (e.g., <code class="language-plaintext highlighter-rouge">A1</code>, <code class="language-plaintext highlighter-rouge">B2</code>, <code class="language-plaintext highlighter-rouge">A3</code>).</li> <li>When CAS checks, it verifies both the <strong>value</strong> and the <strong>version</strong>.</li> <li>Example: <div class="language-c highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">AtomicValue</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">version</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div> </div> </li> <li>Even if the value is back to <strong>A</strong>, the version number ensures CAS detects the change.</li> </ul> </li> <li> <strong>Hazard Pointers</strong> <ul> <li>Used in <strong>memory reclamation</strong> to track objects that are still being accessed by threads, preventing premature deletion.</li> </ul> </li> <li> <strong>Read-Copy-Update (RCU)</strong> <ul> <li>Instead of modifying shared data directly, RCU allows <strong>readers to access old versions</strong> while writers update a new copy.</li> </ul> </li> <li> <strong>Double Compare-And-Swap (Double CAS or DCAS)</strong> <ul> <li>Some architectures support <strong>checking two variables at once</strong> (e.g., the value + a version counter).</li> </ul> </li> </ol> <h3 id="where-is-the-aba-problem-common"><strong>Where is the ABA Problem Common?</strong></h3> <ul> <li><strong>Lock-free stacks, queues, and linked lists</strong></li> <li><strong>Garbage collection mechanisms</strong></li> <li><strong>Reference counting</strong></li> <li><strong>Memory allocators</strong></li> </ul> <h2 id="why-continue-is-necessary-in-the-second-if-statement-">Why continue is necessary in the second if statement ?</h2> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">void</span> <span class="nf">enque</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">SimpleNode</span><span class="o">&gt;</span> <span class="n">node</span><span class="p">(</span><span class="k">new</span> <span class="n">SimpleNode</span><span class="p">());</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">old_tail</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">next</span>  <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>  
    <span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">old_tail</span> <span class="o">=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
      <span class="n">next</span> <span class="o">=</span> <span class="n">old_tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
      <span class="k">if</span><span class="p">(</span><span class="n">old_tail</span> <span class="o">!=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">continue</span><span class="p">;</span>
      
      <span class="p">}</span>
      <span class="k">if</span><span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="k">if</span><span class="p">(</span><span class="n">old_tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">get</span><span class="p">()))</span> <span class="p">{</span>

      <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">release</span><span class="p">());</span>
        <span class="k">return</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span> 
  <span class="p">}</span>
</code></pre></div></div> <p>The <strong><code class="language-plaintext highlighter-rouge">continue</code></strong> statement in the second <code class="language-plaintext highlighter-rouge">if</code> condition is necessary to ensure that the <code class="language-plaintext highlighter-rouge">while(true)</code> loop properly retries the enqueue operation when the <code class="language-plaintext highlighter-rouge">tail_</code> pointer is updated asynchronously by another thread.</p> <h3 id="breaking-down-the-code"><strong>Breaking Down the Code</strong></h3> <p>This function implements a <strong>lock-free queue enqueue operation</strong> using <strong>atomic operations</strong> (<code class="language-plaintext highlighter-rouge">compare_exchange_weak</code>) to avoid locks.</p> <h4 id="key-elements-in-the-code"><strong>Key Elements in the Code:</strong></h4> <ul> <li> <code class="language-plaintext highlighter-rouge">tail_</code>: A <strong>lock-free atomic pointer</strong> to the last node in the queue.</li> <li> <code class="language-plaintext highlighter-rouge">next</code>: The next node after <code class="language-plaintext highlighter-rouge">old_tail</code>, used to check if <code class="language-plaintext highlighter-rouge">tail_</code> is up-to-date.</li> <li> <code class="language-plaintext highlighter-rouge">compare_exchange_weak</code>: Used for <strong>atomic updates</strong>, but it may fail if another thread modifies the value simultaneously.</li> </ul> <h3 id="understanding-the-aba-problem-and-the-need-for-continue"><strong>Understanding the ABA Problem and the Need for <code class="language-plaintext highlighter-rouge">continue</code></strong></h3> <ol> <li> <strong>First <code class="language-plaintext highlighter-rouge">if</code>: Detects Stale <code class="language-plaintext highlighter-rouge">tail_</code></strong> <div class="language-cpp highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="n">old_tail</span> <span class="o">!=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">continue</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> </div> <ul> <li>This check ensures that <code class="language-plaintext highlighter-rouge">old_tail</code> is still the actual tail.</li> <li>If another thread updates <code class="language-plaintext highlighter-rouge">tail_</code> during execution, the loop <strong>retries</strong> to reload the new tail.</li> </ul> </li> <li> <strong>Second <code class="language-plaintext highlighter-rouge">if</code>: If <code class="language-plaintext highlighter-rouge">next != nullptr</code>, Another Thread is Advancing <code class="language-plaintext highlighter-rouge">tail_</code></strong> <div class="language-cpp highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
    <span class="k">continue</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> </div> <ul> <li>This means <strong>another thread is in the middle of an enqueue operation</strong> but hasn‚Äôt yet updated <code class="language-plaintext highlighter-rouge">tail_</code> completely.</li> <li>The queue is <strong>inconsistent</strong> at this point: <ul> <li> <code class="language-plaintext highlighter-rouge">old_tail-&gt;next</code> points to <code class="language-plaintext highlighter-rouge">next</code>, but <code class="language-plaintext highlighter-rouge">tail_</code> still points to <code class="language-plaintext highlighter-rouge">old_tail</code>.</li> <li>Our thread helps move <code class="language-plaintext highlighter-rouge">tail_</code> forward to <code class="language-plaintext highlighter-rouge">next</code> before retrying.</li> </ul> </li> <li>The <code class="language-plaintext highlighter-rouge">continue</code> ensures that we <strong>restart</strong> the loop with a fresh state.</li> </ul> </li> <li> <strong>Final Atomic Insert Attempt</strong> <div class="language-cpp highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="n">old_tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">get</span><span class="p">()))</span> <span class="p">{</span>
    <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">release</span><span class="p">());</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> </div> <ul> <li>If <code class="language-plaintext highlighter-rouge">next</code> is <code class="language-plaintext highlighter-rouge">nullptr</code>, we attempt to attach the new node.</li> <li>If successful, we update <code class="language-plaintext highlighter-rouge">tail_</code>.</li> </ul> </li> </ol> <h3 id="why-is-continue-necessary"><strong>Why is <code class="language-plaintext highlighter-rouge">continue</code> Necessary?</strong></h3> <p>Without <code class="language-plaintext highlighter-rouge">continue</code>, after <code class="language-plaintext highlighter-rouge">tail_.compare_exchange_weak(old_tail, next)</code>, the function would <strong>proceed</strong> without restarting the loop. This could result in:</p> <ul> <li> <strong>Using stale values</strong> of <code class="language-plaintext highlighter-rouge">old_tail</code> and <code class="language-plaintext highlighter-rouge">next</code>, potentially leading to incorrect behavior.</li> <li> <strong>A missed enqueue operation</strong>, as we wouldn‚Äôt retry with the new tail node. Which means that the <code class="language-plaintext highlighter-rouge">tail_</code> is not moved forward.</li> </ul> <h3 id="summary"><strong>Summary</strong></h3> <p>The <code class="language-plaintext highlighter-rouge">continue</code> ensures that if <code class="language-plaintext highlighter-rouge">tail_</code> was not pointing to the correct node (due to concurrent updates), the loop <strong>retries from the beginning</strong> with updated values. This is critical for maintaining the correctness of the <strong>lock-free queue</strong> and avoiding race conditions.</p> <h2 id="correct-vs-incorrect-deque">Correct vs. incorrect deque</h2> <p>Correct:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">deque</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">result</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">oldHead</span><span class="p">;</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
    
    <span class="k">do</span> <span class="p">{</span>
        <span class="n">oldHead</span> <span class="o">=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
        <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">oldTail</span> <span class="o">=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
        <span class="n">next</span> <span class="o">=</span> <span class="n">oldHead</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">oldHead</span> <span class="o">!=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span> <span class="c1">// Restart loop if head changed</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">oldHead</span> <span class="o">==</span> <span class="n">oldTail</span><span class="p">)</span> <span class="p">{</span> 
            <span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// Queue is empty</span>
            <span class="p">}</span>
            <span class="c1">// Help advance the tail if it's stuck (optional optimization)</span>
            <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">oldTail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
        <span class="p">}</span>
        
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">head_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">oldHead</span><span class="p">,</span> <span class="n">next</span><span class="p">));</span>

    <span class="c1">// Ensure next is valid before accessing it</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="k">delete</span> <span class="n">oldHead</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// Failsafe check, should not be reached</span>
<span class="p">}</span>
</code></pre></div></div> <p>Incorrect:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">bool</span> <span class="nf">deque</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">old_head</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">old_tail</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">next</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="k">do</span> <span class="p">{</span>
      <span class="n">old_head</span> <span class="o">=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
      <span class="n">old_tail</span> <span class="o">=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
      <span class="n">assert</span><span class="p">(</span><span class="n">old_head</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">);</span>
      <span class="n">next</span> <span class="o">=</span> <span class="n">old_head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
      <span class="k">if</span><span class="p">(</span><span class="n">old_head</span> <span class="o">!=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span><span class="p">(</span><span class="n">old_head</span> <span class="o">==</span> <span class="n">old_tail</span> <span class="o">&amp;&amp;</span> <span class="n">next</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="n">head_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_head</span><span class="p">,</span> <span class="n">next</span><span class="p">)</span> <span class="o">==</span> <span class="nb">false</span><span class="p">);</span>

    <span class="n">val</span> <span class="o">=</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">old_head</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div></div> <p>Explanation from gpt. Basically it means that we need to whether next is nullptr or not. Your <code class="language-plaintext highlighter-rouge">deque</code> function has a <strong>bug that can cause a segmentation fault (crash)</strong> due to <strong>dereferencing a null pointer (<code class="language-plaintext highlighter-rouge">next</code>)</strong> when the queue is empty. Here‚Äôs what happens:</p> <h3 id="identified-bugs"><strong>Identified Bugs:</strong></h3> <ol> <li> <strong>Null Dereference of <code class="language-plaintext highlighter-rouge">next</code></strong> <ul> <li>When <code class="language-plaintext highlighter-rouge">oldHead == oldTail</code> and <code class="language-plaintext highlighter-rouge">next == nullptr</code>, the queue is empty.</li> <li>However, the loop continues, and <code class="language-plaintext highlighter-rouge">next</code> (which is <code class="language-plaintext highlighter-rouge">nullptr</code>) is used in <code class="language-plaintext highlighter-rouge">head_.compare_exchange_weak(oldHead, next)</code>, leading to <strong>undefined behavior</strong>.</li> <li>Also, <code class="language-plaintext highlighter-rouge">result = std::move(next-&gt;val);</code> will crash if <code class="language-plaintext highlighter-rouge">next</code> is <code class="language-plaintext highlighter-rouge">nullptr</code>.</li> </ul> </li> </ol> <h3 id="fixed-code"><strong>Fixed Code</strong></h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">deque</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">result</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">oldHead</span><span class="p">;</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
    
    <span class="k">do</span> <span class="p">{</span>
        <span class="n">oldHead</span> <span class="o">=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
        <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">oldTail</span> <span class="o">=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
        <span class="n">next</span> <span class="o">=</span> <span class="n">oldHead</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">oldHead</span> <span class="o">!=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span> <span class="c1">// Restart loop if head changed</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">oldHead</span> <span class="o">==</span> <span class="n">oldTail</span><span class="p">)</span> <span class="p">{</span> 
            <span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// Queue is empty</span>
            <span class="p">}</span>
            <span class="c1">// Help advance the tail if it's stuck (optional optimization)</span>
            <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">oldTail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
        <span class="p">}</span>
        
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">head_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">oldHead</span><span class="p">,</span> <span class="n">next</span><span class="p">));</span>

    <span class="c1">// Ensure next is valid before accessing it</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="k">delete</span> <span class="n">oldHead</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// Failsafe check, should not be reached</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="fixes--improvements"><strong>Fixes &amp; Improvements</strong></h3> <ol> <li> <strong>Ensured <code class="language-plaintext highlighter-rouge">next</code> is not null before accessing it</strong> <ul> <li>We only proceed if <code class="language-plaintext highlighter-rouge">next</code> is valid.</li> </ul> </li> <li> <strong>Added a tail advancement step</strong> <em>(optional but improves performance)</em> <ul> <li>If <code class="language-plaintext highlighter-rouge">tail_</code> is outdated (<code class="language-plaintext highlighter-rouge">oldTail == oldHead &amp;&amp; next != nullptr</code>), update it to avoid slow tail progression.</li> </ul> </li> <li> <strong>Handled the empty queue case properly</strong> <ul> <li>Now correctly returns <code class="language-plaintext highlighter-rouge">false</code> when the queue is empty without further processing.</li> </ul> </li> </ol> <p>This prevents <strong>segmentation faults</strong>, ensures correct behavior, and slightly optimizes the tail update. üöÄ</p> <h2 id="the-difference-between-two-enque-implementation">The difference between two enque implementation</h2> <p>First one, correct</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">void</span> <span class="nf">enque</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">SimpleNode</span><span class="o">&gt;</span> <span class="n">node</span><span class="p">(</span><span class="k">new</span> <span class="n">SimpleNode</span><span class="p">());</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">old_tail</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">next</span>  <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>  
    <span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">old_tail</span> <span class="o">=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
      <span class="n">next</span> <span class="o">=</span> <span class="n">old_tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
      <span class="k">if</span><span class="p">(</span><span class="n">old_tail</span> <span class="o">!=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">continue</span><span class="p">;</span>
      
      <span class="p">}</span>
      <span class="k">if</span><span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="k">if</span><span class="p">(</span><span class="n">old_tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">get</span><span class="p">()))</span> <span class="p">{</span>

      <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">release</span><span class="p">());</span>
        <span class="k">return</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span> 
  <span class="p">}</span>
</code></pre></div></div> <p>Second one, incorrect</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">void</span> <span class="nf">enque</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SimpleNode</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
        <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">old_tail</span><span class="p">;</span>
        <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>

        <span class="k">do</span> <span class="p">{</span>
            <span class="n">old_tail</span> <span class="o">=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
            <span class="n">next</span> <span class="o">=</span> <span class="n">old_tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">old_tail</span> <span class="o">!=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">())</span> <span class="p">{</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">old_tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">node</span><span class="p">));</span>

        <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
        <span class="n">size_</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div></div> <h3 id="key-difference-when-tail_-is-updated"><strong>Key Difference: When <code class="language-plaintext highlighter-rouge">tail_</code> is Updated</strong></h3> <p>You‚Äôre correct that <strong>both implementations update <code class="language-plaintext highlighter-rouge">tail_</code> only once when successfully adding a node</strong>. However, <strong>the crucial difference is what happens when <code class="language-plaintext highlighter-rouge">next != nullptr</code></strong> (i.e., when another thread is already modifying the queue).</p> <h3 id="first-implementation-correct"><strong>First Implementation (Correct)</strong></h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
    <span class="k">continue</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>üîπ <strong>If another thread is already enqueueing a node (<code class="language-plaintext highlighter-rouge">next != nullptr</code>), we help move <code class="language-plaintext highlighter-rouge">tail_</code> forward before retrying.</strong><br> üîπ This prevents <code class="language-plaintext highlighter-rouge">tail_</code> from becoming stale and ensures it always points to the latest node.</p> <h3 id="second-implementation-incorrect"><strong>Second Implementation (Incorrect)</strong></h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
    <span class="k">continue</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>üîπ <strong>This part is identical</strong>, but <strong>the retry loop does not guarantee that <code class="language-plaintext highlighter-rouge">tail_</code> is updated correctly at the end</strong>.<br> üîπ Since <code class="language-plaintext highlighter-rouge">tail_.compare_exchange_weak(old_tail, node);</code> is <strong>only executed once, outside the loop</strong>, it might miss updates when multiple threads are enqueueing.</p> <hr> <h2 id="example-the-core-issue-in-the-second-implementation"><strong>Example: The Core Issue in the Second Implementation</strong></h2> <p>Let‚Äôs break it down step by step <strong>with two threads (<code class="language-plaintext highlighter-rouge">Thread 1</code> and <code class="language-plaintext highlighter-rouge">Thread 2</code>) enqueuing at the same time</strong>.</p> <h3 id="initial-queue-state"><strong>Initial Queue State</strong></h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HEAD -&gt; Node(A) -&gt; (TAIL)
</code></pre></div></div> <p>Both <code class="language-plaintext highlighter-rouge">head_</code> and <code class="language-plaintext highlighter-rouge">tail_</code> point to <code class="language-plaintext highlighter-rouge">Node(A)</code>.<br> Now, <strong>Thread 1 enqueues <code class="language-plaintext highlighter-rouge">Node(B)</code>, and Thread 2 enqueues <code class="language-plaintext highlighter-rouge">Node(C)</code>.</strong></p> <hr> <h3 id="step-1-both-threads-read-tail_"><strong>Step 1: Both Threads Read <code class="language-plaintext highlighter-rouge">tail_</code></strong></h3> <ul> <li> <strong>Thread 1</strong> reads <code class="language-plaintext highlighter-rouge">tail_ = Node(A)</code>, sees <code class="language-plaintext highlighter-rouge">next = nullptr</code>, and creates <code class="language-plaintext highlighter-rouge">Node(B)</code>.</li> <li> <strong>Thread 2</strong> reads <code class="language-plaintext highlighter-rouge">tail_ = Node(A)</code>, sees <code class="language-plaintext highlighter-rouge">next = nullptr</code>, and creates <code class="language-plaintext highlighter-rouge">Node(C)</code>.</li> </ul> <hr> <h3 id="step-2-thread-1-successfully-adds-nodeb"><strong>Step 2: Thread 1 Successfully Adds <code class="language-plaintext highlighter-rouge">Node(B)</code></strong></h3> <ul> <li> <strong>Thread 1 succeeds</strong> in: <div class="language-cpp highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="n">old_tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">node_B</span><span class="p">);</span>
</code></pre></div> </div> <ul> <li>Now, the queue looks like: <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>HEAD -&gt; Node(A) -&gt; Node(B)
</code></pre></div> </div> </li> </ul> </li> <li><strong>Thread 2 retries because <code class="language-plaintext highlighter-rouge">next</code> is no longer <code class="language-plaintext highlighter-rouge">nullptr</code>!</strong></li> </ul> <hr> <h3 id="step-3-thread-1-updates-tail_"><strong>Step 3: Thread 1 Updates <code class="language-plaintext highlighter-rouge">tail_</code></strong></h3> <ul> <li> <strong>Thread 1 successfully updates <code class="language-plaintext highlighter-rouge">tail_</code> to point to <code class="language-plaintext highlighter-rouge">Node(B)</code>.</strong> <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>HEAD -&gt; Node(A) -&gt; Node(B) -&gt; (TAIL)
</code></pre></div> </div> </li> </ul> <hr> <h3 id="step-4-thread-2-retries"><strong>Step 4: Thread 2 Retries</strong></h3> <ul> <li> <strong>Thread 2 now reads <code class="language-plaintext highlighter-rouge">tail_ = Node(B)</code>, next = <code class="language-plaintext highlighter-rouge">nullptr</code>, and successfully adds <code class="language-plaintext highlighter-rouge">Node(C)</code>.</strong> <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>HEAD -&gt; Node(A) -&gt; Node(B) -&gt; Node(C)
</code></pre></div> </div> </li> <li> <strong>But here‚Äôs the bug in the second implementation:</strong> <ul> <li> <code class="language-plaintext highlighter-rouge">tail_</code> is updated <strong>only once, outside the loop</strong>.</li> <li>If another thread starts enqueueing at the same time, <code class="language-plaintext highlighter-rouge">tail_</code> <strong>might still point to <code class="language-plaintext highlighter-rouge">Node(B)</code> instead of <code class="language-plaintext highlighter-rouge">Node(C)</code>!</strong> </li> <li><strong>Future enqueue operations might have to retry unnecessarily because <code class="language-plaintext highlighter-rouge">tail_</code> is stale.</strong></li> </ul> </li> </ul> <hr> <h3 id="step-5-the-problem-stale-tail_"><strong>Step 5: The Problem (Stale <code class="language-plaintext highlighter-rouge">tail_</code>)</strong></h3> <ul> <li>If a new thread tries to enqueue <code class="language-plaintext highlighter-rouge">Node(D)</code>, it <strong>may still see <code class="language-plaintext highlighter-rouge">tail_ = Node(B)</code>, instead of <code class="language-plaintext highlighter-rouge">Node(C)</code>.</strong> </li> <li>This forces unnecessary retries, slowing down the queue.</li> </ul> <hr> <h2 id="why-the-first-implementation-avoids-this"><strong>Why the First Implementation Avoids This</strong></h2> <p>In the <strong>first implementation</strong>, if another thread is already in the middle of an enqueue (i.e., <code class="language-plaintext highlighter-rouge">next != nullptr</code>), it <strong>helps move <code class="language-plaintext highlighter-rouge">tail_</code> forward before retrying.</strong></p> <h3 id="why-this-matters"><strong>Why This Matters</strong></h3> <p>Imagine <code class="language-plaintext highlighter-rouge">Thread 1</code> enqueues <code class="language-plaintext highlighter-rouge">Node(B)</code>, and <code class="language-plaintext highlighter-rouge">Thread 2</code> enqueues <code class="language-plaintext highlighter-rouge">Node(C)</code>.</p> <ul> <li><strong>In the first implementation, <code class="language-plaintext highlighter-rouge">Thread 2</code> would help move <code class="language-plaintext highlighter-rouge">tail_</code> to <code class="language-plaintext highlighter-rouge">Node(B)</code> before proceeding.</strong></li> <li><strong>This guarantees that when it enqueues <code class="language-plaintext highlighter-rouge">Node(C)</code>, <code class="language-plaintext highlighter-rouge">tail_</code> will be updated correctly.</strong></li> </ul> <p>By continuously ensuring that <code class="language-plaintext highlighter-rouge">tail_</code> is moved forward <strong>before retrying</strong>, the first implementation guarantees that <code class="language-plaintext highlighter-rouge">tail_</code> <strong>always</strong> points to the most recently enqueued node.</p> <hr> <h2 id="summary-of-the-core-difference"><strong>Summary of the Core Difference</strong></h2> <p>| Feature | <strong>First Implementation (Correct)</strong> | <strong>Second Implementation (Incorrect)</strong> | |‚Äî‚Äî‚Äî|‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî-|‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî-| | <strong>What happens when <code class="language-plaintext highlighter-rouge">next != nullptr</code>?</strong> | Moves <code class="language-plaintext highlighter-rouge">tail_</code> forward before retrying. | Just retries without ensuring <code class="language-plaintext highlighter-rouge">tail_</code> is updated correctly. | | <strong>Ensures <code class="language-plaintext highlighter-rouge">tail_</code> always points to the latest node?</strong> | ‚úÖ Yes | ‚ùå No, <code class="language-plaintext highlighter-rouge">tail_</code> might point to an old node. | | <strong>Potential issue?</strong> | No inefficiencies, always correct. | <code class="language-plaintext highlighter-rouge">tail_</code> can become stale, causing unnecessary retries. | | <strong>Performance impact</strong> | More efficient, fewer retries. | Less efficient, more retries needed. |</p> <hr> <h3 id="final-takeaway"><strong>Final Takeaway</strong></h3> <p><strong>The key reason the first implementation is correct is that it ensures <code class="language-plaintext highlighter-rouge">tail_</code> is always moved forward before retrying.</strong><br> Without this, the second implementation <strong>allows <code class="language-plaintext highlighter-rouge">tail_</code> to become stale</strong>, which slows down the queue by forcing unnecessary retries.</p> <hr> <p>I still don‚Äôt get it. Why the second implementation is incorrect ?</p> <p>You‚Äôre absolutely right that <strong>other threads can help move <code class="language-plaintext highlighter-rouge">tail_</code> forward</strong>‚Äîthis is the whole idea behind a lock-free queue! However, the second implementation <strong>still has a correctness issue</strong> because it does not ensure that <code class="language-plaintext highlighter-rouge">tail_</code> is updated reliably <strong>before finishing the enqueue operation</strong>.</p> <p>Let‚Äôs clarify <strong>why this is a problem even though other threads can help move <code class="language-plaintext highlighter-rouge">tail_</code> forward.</strong></p> <hr> <h2 id="key-question"><strong>Key Question</strong></h2> <p>Since other threads can update <code class="language-plaintext highlighter-rouge">tail_</code>, why is the second implementation still incorrect?</p> <h3 id="answer"><strong>Answer:</strong></h3> <p>Even though other threads <strong>may</strong> update <code class="language-plaintext highlighter-rouge">tail_</code>, the second implementation <strong>relies on them to fix the issue rather than guaranteeing correctness itself.</strong><br> This creates a <strong>non-deterministic behavior</strong> where <code class="language-plaintext highlighter-rouge">tail_</code> <strong>might or might not</strong> point to the latest node, depending on thread timing.</p> <hr> <h2 id="breaking-it-down-step-by-step"><strong>Breaking It Down Step by Step</strong></h2> <p>Let‚Äôs assume <strong>three threads (<code class="language-plaintext highlighter-rouge">T1</code>, <code class="language-plaintext highlighter-rouge">T2</code>, and <code class="language-plaintext highlighter-rouge">T3</code>) are enqueuing at the same time</strong> to see where the second implementation fails.</p> <h3 id="initial-state"><strong>Initial State</strong></h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HEAD -&gt; Node(A) (tail_)
</code></pre></div></div> <ul> <li> <code class="language-plaintext highlighter-rouge">head_</code> and <code class="language-plaintext highlighter-rouge">tail_</code> both point to <code class="language-plaintext highlighter-rouge">Node(A)</code>.</li> <li>Now three threads start enqueueing.</li> </ul> <hr> <h3 id="step-1-t1-successfully-enqueues-nodeb"><strong>Step 1: T1 Successfully Enqueues <code class="language-plaintext highlighter-rouge">Node(B)</code></strong></h3> <ul> <li> <code class="language-plaintext highlighter-rouge">T1</code> successfully attaches <code class="language-plaintext highlighter-rouge">Node(B)</code>: <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>HEAD -&gt; Node(A) -&gt; Node(B)
</code></pre></div> </div> </li> <li>But <code class="language-plaintext highlighter-rouge">tail_</code> is <strong>still pointing to <code class="language-plaintext highlighter-rouge">Node(A)</code></strong>.</li> <li>Before <code class="language-plaintext highlighter-rouge">T1</code> can update <code class="language-plaintext highlighter-rouge">tail_</code>, <strong>T2 and T3 start running.</strong> </li> </ul> <hr> <h3 id="step-2-t2-reads-stale-tail_--nodea-tries-to-enqueue-nodec"><strong>Step 2: T2 Reads Stale <code class="language-plaintext highlighter-rouge">tail_ = Node(A)</code>, Tries to Enqueue <code class="language-plaintext highlighter-rouge">Node(C)</code></strong></h3> <ul> <li> <code class="language-plaintext highlighter-rouge">T2</code> reads: <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>old_tail = Node(A), next = Node(B)
</code></pre></div> </div> </li> <li>Since <code class="language-plaintext highlighter-rouge">next != nullptr</code>, <strong>it helps move <code class="language-plaintext highlighter-rouge">tail_</code> to <code class="language-plaintext highlighter-rouge">Node(B)</code>, then retries.</strong> </li> <li><strong>Now <code class="language-plaintext highlighter-rouge">tail_ = Node(B)</code>.</strong></li> </ul> <hr> <h3 id="step-3-t2-successfully-enqueues-nodec"><strong>Step 3: T2 Successfully Enqueues <code class="language-plaintext highlighter-rouge">Node(C)</code></strong></h3> <ul> <li> <code class="language-plaintext highlighter-rouge">T2</code> now enqueues <code class="language-plaintext highlighter-rouge">Node(C)</code>: <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>HEAD -&gt; Node(A) -&gt; Node(B) -&gt; Node(C)
</code></pre></div> </div> </li> <li>But <code class="language-plaintext highlighter-rouge">tail_</code> <strong>is still pointing to <code class="language-plaintext highlighter-rouge">Node(B)</code></strong>.</li> <li>Before <code class="language-plaintext highlighter-rouge">T2</code> updates <code class="language-plaintext highlighter-rouge">tail_</code>, <strong>T3 starts running.</strong> </li> </ul> <hr> <h3 id="step-4-t3-reads-stale-tail_--nodeb-tries-to-enqueue-noded"><strong>Step 4: T3 Reads Stale <code class="language-plaintext highlighter-rouge">tail_ = Node(B)</code>, Tries to Enqueue <code class="language-plaintext highlighter-rouge">Node(D)</code></strong></h3> <ul> <li> <code class="language-plaintext highlighter-rouge">T3</code> reads: <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>old_tail = Node(B), next = Node(C)
</code></pre></div> </div> </li> <li>Since <code class="language-plaintext highlighter-rouge">next != nullptr</code>, <strong>it helps move <code class="language-plaintext highlighter-rouge">tail_</code> to <code class="language-plaintext highlighter-rouge">Node(C)</code>, then retries.</strong> </li> <li><strong>Now <code class="language-plaintext highlighter-rouge">tail_ = Node(C)</code>.</strong></li> </ul> <hr> <h3 id="step-5-t3-successfully-enqueues-noded"><strong>Step 5: T3 Successfully Enqueues <code class="language-plaintext highlighter-rouge">Node(D)</code></strong></h3> <ul> <li> <code class="language-plaintext highlighter-rouge">T3</code> enqueues <code class="language-plaintext highlighter-rouge">Node(D)</code>: <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>HEAD -&gt; Node(A) -&gt; Node(B) -&gt; Node(C) -&gt; Node(D)
</code></pre></div> </div> </li> <li>But <code class="language-plaintext highlighter-rouge">tail_</code> is <strong>still pointing to <code class="language-plaintext highlighter-rouge">Node(C)</code></strong>.</li> <li>If <strong>no other thread updates <code class="language-plaintext highlighter-rouge">tail_</code> now, it remains stale!</strong> </li> </ul> <hr> <h2 id="the-core-problem-in-the-second-implementation"><strong>The Core Problem in the Second Implementation</strong></h2> <p>If <strong>all threads finish</strong> and no new thread is enqueueing, <code class="language-plaintext highlighter-rouge">tail_</code> <strong>might be stuck at an old node</strong> (e.g., <code class="language-plaintext highlighter-rouge">Node(C)</code> instead of <code class="language-plaintext highlighter-rouge">Node(D)</code>).</p> <p>This <strong>isn‚Äôt guaranteed to cause a failure immediately</strong>, but it creates two major issues:</p> <ol> <li> <strong>Future threads must do extra retries to move <code class="language-plaintext highlighter-rouge">tail_</code> forward.</strong> <ul> <li>If <code class="language-plaintext highlighter-rouge">tail_</code> lags behind, future enqueue operations will see <code class="language-plaintext highlighter-rouge">next != nullptr</code> and must <strong>repeatedly help move <code class="language-plaintext highlighter-rouge">tail_</code> forward before enqueuing.</strong> </li> <li>This <strong>adds unnecessary contention and performance overhead.</strong> </li> </ul> </li> <li> <strong>If a dequeue operation runs now, it may have to traverse multiple nodes before reaching <code class="language-plaintext highlighter-rouge">tail_</code>.</strong> <ul> <li>A correct <code class="language-plaintext highlighter-rouge">tail_</code> should always point to the last node, minimizing the traversal cost for future operations.</li> </ul> </li> </ol> <h3 id="why-doesnt-this-happen-in-the-first-implementation"><strong>Why Doesn‚Äôt This Happen in the First Implementation?</strong></h3> <p>The <strong>first implementation guarantees that <code class="language-plaintext highlighter-rouge">tail_</code> always points to the latest node before returning</strong>:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
    <span class="k">continue</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <ul> <li>If <code class="language-plaintext highlighter-rouge">next != nullptr</code>, we <strong>keep updating <code class="language-plaintext highlighter-rouge">tail_</code> and retrying until we attach our node to the latest position</strong>.</li> <li>This ensures that when the function exits, <code class="language-plaintext highlighter-rouge">tail_</code> <strong>always points to the correct last node</strong>.</li> </ul> <hr> <h2 id="final-takeaway-1"><strong>Final Takeaway</strong></h2> <p>üîπ <strong>Yes, other threads can update <code class="language-plaintext highlighter-rouge">tail_</code>, but the second implementation relies on this happening rather than guaranteeing correctness itself.</strong><br> üîπ <strong>If no other thread updates <code class="language-plaintext highlighter-rouge">tail_</code>, <code class="language-plaintext highlighter-rouge">tail_</code> can become stale, leading to inefficiencies and unnecessary retries.</strong><br> üîπ The <strong>first implementation actively ensures <code class="language-plaintext highlighter-rouge">tail_</code> is always updated before returning</strong>, making it more robust and efficient.</p> <p>I still don‚Äôt get it. I will just give up then. At least I learn what‚Äôs the correct implementaion of lock free queue.</p> <h2 id="full-test-code">Full test code</h2> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cassert&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp">
</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">Node</span><span class="p">{</span>
  <span class="n">Node</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
    <span class="n">next</span> <span class="o">=</span> <span class="n">prev</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">prev</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Queue</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Queue</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">head_</span> <span class="o">=</span> <span class="n">tail_</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">size_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">head_</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">tail_</span><span class="p">;</span>
    <span class="n">tail_</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">head_</span><span class="p">;</span>


  <span class="p">}</span>

  <span class="kt">void</span> <span class="nf">enque</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">tail_</span><span class="p">;</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">tail_</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>
    <span class="n">tail_</span><span class="o">-&gt;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
    <span class="n">tail_</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
    <span class="n">size_</span><span class="o">++</span><span class="p">;</span>


  <span class="p">}</span>

  <span class="kt">bool</span> <span class="nf">deque</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">size_</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">head_</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
    <span class="n">head_</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">head_</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">node</span><span class="p">;</span>
    <span class="n">size_</span><span class="o">--</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

  <span class="p">}</span>

  <span class="kt">bool</span> <span class="nf">empty</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">size_</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>

  <span class="p">}</span>

  <span class="kt">int</span> <span class="nf">front</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">head_</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>

  <span class="p">}</span>


<span class="k">private</span><span class="o">:</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">head_</span><span class="p">;</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">tail_</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">size_</span><span class="p">;</span>


<span class="p">};</span>


<span class="k">struct</span> <span class="nc">SimpleNode</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">SimpleNode</span><span class="o">*&gt;</span> <span class="n">next</span><span class="p">;</span>
  <span class="n">SimpleNode</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">next</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">SimpleNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
    <span class="n">next</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
  <span class="p">}</span>

<span class="p">};</span>


<span class="k">class</span> <span class="nc">MyLockFreeQueue</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">MyLockFreeQueue</span><span class="p">()</span>  <span class="p">{</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SimpleNode</span><span class="p">();</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="n">head_</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
    <span class="n">tail_</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>

  <span class="p">}</span>
<span class="c1">// void enque(int val) {</span>
<span class="c1">//     // Allocate the new node</span>
<span class="c1">//     std::unique_ptr&lt;SimpleNode&gt; node = std::make_unique&lt;SimpleNode&gt;(val);</span>

<span class="c1">//     SimpleNode* old_tail = nullptr;</span>
<span class="c1">//     SimpleNode* next = nullptr;</span>

<span class="c1">//     while (true) {</span>
<span class="c1">//         old_tail = tail_.load();</span>
<span class="c1">//         next = old_tail-&gt;next.load();</span>

<span class="c1">//         if (old_tail != tail_.load()) {</span>
<span class="c1">//             continue; // Retry if tail changed</span>
<span class="c1">//         }</span>

<span class="c1">//         if (next != nullptr) {</span>
<span class="c1">//             // Help advance tail if it's stale</span>
<span class="c1">//             tail_.compare_exchange_weak(old_tail, next);</span>
<span class="c1">//             continue;</span>
<span class="c1">//         }</span>

<span class="c1">//         // Try to attach the new node</span>
<span class="c1">//         if (old_tail-&gt;next.compare_exchange_weak(next, node.get())) {</span>
<span class="c1">//             // Successfully linked, now update tail_</span>
<span class="c1">//             tail_.compare_exchange_weak(old_tail, node.release());</span>
<span class="c1">//             return;</span>
<span class="c1">//         }</span>
<span class="c1">//     }</span>
<span class="c1">// }</span>

  <span class="kt">void</span> <span class="nf">enque</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">SimpleNode</span><span class="o">&gt;</span> <span class="n">node</span><span class="p">(</span><span class="k">new</span> <span class="n">SimpleNode</span><span class="p">());</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">old_tail</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">next</span>  <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>  
    <span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">old_tail</span> <span class="o">=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
      <span class="n">next</span> <span class="o">=</span> <span class="n">old_tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
      <span class="k">if</span><span class="p">(</span><span class="n">old_tail</span> <span class="o">!=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">continue</span><span class="p">;</span>
      
      <span class="p">}</span>
      <span class="k">if</span><span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="k">if</span><span class="p">(</span><span class="n">old_tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">get</span><span class="p">()))</span> <span class="p">{</span>

      <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">release</span><span class="p">());</span>
        <span class="k">return</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span> 
  <span class="p">}</span>

    <span class="kt">int</span> <span class="nf">size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">node</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">node</span> <span class="o">!=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">count</span><span class="o">++</span><span class="p">;</span>
      <span class="k">if</span><span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"node is null, count is "</span> <span class="o">&lt;&lt;</span> <span class="n">count</span><span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

      <span class="p">}</span>
      <span class="n">assert</span><span class="p">(</span><span class="n">node</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">);</span>
      <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// bool deque(int&amp; val) {</span>
  <span class="c1">//   SimpleNode* old_head = nullptr;</span>
  <span class="c1">//   SimpleNode* old_tail = nullptr;</span>
  <span class="c1">//   SimpleNode* next = nullptr;</span>
  <span class="c1">//   do {</span>
  <span class="c1">//     old_head = head_.load();</span>
  <span class="c1">//     old_tail = tail_.load();</span>
  <span class="c1">//     assert(old_head != nullptr);</span>
  <span class="c1">//     next = old_head-&gt;next.load();</span>
  <span class="c1">//     if(old_head != head_.load()) {</span>
  <span class="c1">//       continue;</span>
  <span class="c1">//     }</span>
  <span class="c1">//     if(old_head == old_tail &amp;&amp; next == nullptr) {</span>
  <span class="c1">//       return false;</span>
  <span class="c1">//     }</span>
  <span class="c1">//   } while(head_.compare_exchange_weak(old_head, next) == false);</span>

  <span class="c1">//   val = next-&gt;val;</span>
  <span class="c1">//   delete old_head;</span>
  <span class="c1">//   return true;</span>
  <span class="c1">// }</span>

<span class="kt">bool</span> <span class="nf">deque</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">result</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">oldHead</span><span class="p">;</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
    
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">oldHead</span> <span class="o">=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
        <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">oldTail</span> <span class="o">=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
        <span class="n">next</span> <span class="o">=</span> <span class="n">oldHead</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">oldHead</span> <span class="o">!=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span> <span class="c1">// Restart loop if head changed</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">oldHead</span> <span class="o">==</span> <span class="n">oldTail</span><span class="p">)</span> <span class="p">{</span> 
            <span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// Queue is empty</span>
            <span class="p">}</span>
            <span class="c1">// Help advance the tail if it's stuck (optional optimization)</span>
            <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">oldTail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
        <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="n">head_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">oldHead</span><span class="p">,</span> <span class="n">next</span><span class="p">))</span> <span class="p">{</span>
          <span class="c1">// Ensure next is valid before accessing it</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
              <span class="n">result</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
              <span class="k">delete</span> <span class="n">oldHead</span><span class="p">;</span>
              <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
          <span class="p">}</span>


          <span class="p">}</span>
        
    <span class="p">}</span> 

    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// Failsafe check, should not be reached</span>
<span class="p">}</span>

    <span class="c1">// bool deque(int&amp; result) {</span>
    <span class="c1">//     SimpleNode* oldHead;</span>
    <span class="c1">//     SimpleNode* next;</span>
    <span class="c1">//     do {</span>
    <span class="c1">//         oldHead = head_.load();</span>
    <span class="c1">//         SimpleNode* oldTail = tail_.load();</span>
    <span class="c1">//         next = oldHead-&gt;next.load();</span>
    <span class="c1">//         if (oldHead!= head_.load()) {</span>
    <span class="c1">//             continue;</span>
    <span class="c1">//         }</span>
    <span class="c1">//         if (oldHead == oldTail &amp;&amp; next == nullptr) {</span>
    <span class="c1">//             return false;</span>
    <span class="c1">//         }</span>
    <span class="c1">//     } while (!head_.compare_exchange_weak(oldHead, next));</span>
    <span class="c1">//     result = std::move(next-&gt;val);</span>
    <span class="c1">//     delete oldHead;</span>
    <span class="c1">//     return true;</span>
    <span class="c1">// }</span>


  <span class="kt">bool</span> <span class="nf">empty</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">()</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">;</span>
  <span class="p">}</span>


  <span class="k">private</span><span class="o">:</span>
  <span class="c1">// size</span>
  <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">size_</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">SimpleNode</span><span class="o">*&gt;</span> <span class="n">head_</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">SimpleNode</span><span class="o">*&gt;</span> <span class="n">tail_</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">MyLockFreeQueue2</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">MyLockFreeQueue2</span><span class="p">()</span> <span class="o">:</span> <span class="n">size_</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SimpleNode</span><span class="p">();</span>
        <span class="n">head_</span> <span class="o">=</span> <span class="n">tail_</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">enque</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SimpleNode</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
        <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">old_tail</span><span class="p">;</span>
        <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>

        <span class="k">do</span> <span class="p">{</span>
            <span class="n">old_tail</span> <span class="o">=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
            <span class="n">next</span> <span class="o">=</span> <span class="n">old_tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">old_tail</span> <span class="o">!=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">())</span> <span class="p">{</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">old_tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">node</span><span class="p">));</span>

        <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
        <span class="n">size_</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="nf">deque</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">old_head</span><span class="p">;</span>
        <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">old_tail</span><span class="p">;</span>
        <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>

        <span class="k">do</span> <span class="p">{</span>
            <span class="n">old_head</span> <span class="o">=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
            <span class="n">old_tail</span> <span class="o">=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
            <span class="n">next</span> <span class="o">=</span> <span class="n">old_head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">old_head</span> <span class="o">!=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">())</span> <span class="p">{</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">old_head</span> <span class="o">==</span> <span class="n">old_tail</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="c1">// tail_.compare_exchange_weak(old_tail, next);</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">val</span> <span class="o">=</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">head_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_head</span><span class="p">,</span> <span class="n">next</span><span class="p">));</span>

        <span class="n">safe_delete</span><span class="p">(</span><span class="n">old_head</span><span class="p">);</span> <span class="c1">// Use a safe delete method</span>
        <span class="n">size_</span><span class="p">.</span><span class="n">fetch_sub</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="nf">empty</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">()</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="p">}</span>

  <span class="kt">int</span> <span class="nf">size</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">size_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
  <span class="p">}</span>


<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">size_</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">SimpleNode</span><span class="o">*&gt;</span> <span class="n">head_</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">SimpleNode</span><span class="o">*&gt;</span> <span class="n">tail_</span><span class="p">;</span>

    <span class="kt">void</span> <span class="nf">safe_delete</span><span class="p">(</span><span class="n">SimpleNode</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">delete</span> <span class="n">node</span><span class="p">;</span>
        <span class="c1">// Implement a safe deletion mechanism to prevent use-after-free issues</span>
        <span class="c1">// This could be done with a garbage collector or hazard pointers.</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">LockFreeQueue</span><span class="p">{</span>

<span class="nl">public:</span>
  <span class="n">LockFreeQueue</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">head_</span> <span class="o">=</span> <span class="n">tail_</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">head_</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">tail_</span><span class="p">;</span>
    <span class="n">tail_</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">head_</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="nf">enque</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">tail_</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Node</span><span class="o">*</span> <span class="n">next</span> <span class="o">=</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
      <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
      <span class="n">node</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">__sync_bool_compare_and_swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">node</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">bool</span> <span class="nf">deque</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">node</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">node</span> <span class="o">=</span> <span class="n">head_</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="n">tail_</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">Node</span><span class="o">*</span> <span class="n">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">__sync_bool_compare_and_swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head_</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">next</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">head_</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">node</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">bool</span> <span class="nf">empty</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">head_</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="n">tail_</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">int</span> <span class="nf">front</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">head_</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
  <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">head_</span><span class="p">;</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">tail_</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">test_my_lock_free_queue</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// enque 100 times concurrently and dequeue 100 times concurrently</span>
  <span class="n">MyLockFreeQueue</span> <span class="n">q</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">num_threads</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">num_ops</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">threads</span><span class="p">[</span><span class="n">num_threads</span><span class="p">];</span>
  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">dequeue_threads</span><span class="p">[</span><span class="n">num_threads</span><span class="p">];</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_threads</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">([</span><span class="o">&amp;</span><span class="n">q</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">num_ops</span><span class="p">]</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">num_ops</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">q</span><span class="p">.</span><span class="n">enque</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">num_ops</span> <span class="o">+</span> <span class="n">j</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_threads</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">join</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">" hello "</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="c1">// get queue size</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"size "</span> <span class="o">&lt;&lt;</span> <span class="n">q</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>


  <span class="c1">// return;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_threads</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">dequeue_threads</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">([</span><span class="o">&amp;</span><span class="n">q</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">num_ops</span><span class="p">]</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">num_ops</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">res</span> <span class="o">=</span>  <span class="n">q</span><span class="p">.</span><span class="n">deque</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
        <span class="c1">// cout &lt;&lt; "cur val " &lt;&lt; val &lt;&lt; endl;</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"cur num "</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">" cur ops "</span> <span class="o">&lt;&lt;</span> <span class="n">j</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
          <span class="n">assert</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_threads</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">dequeue_threads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">join</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">());</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"All tests pass"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

<span class="p">}</span>

<span class="kt">void</span> <span class="nf">testnormalqueue</span><span class="p">()</span> <span class="p">{</span>
<span class="n">Queue</span> <span class="n">q</span><span class="p">;</span>
  <span class="n">q</span><span class="p">.</span><span class="n">enque</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">q</span><span class="p">.</span><span class="n">enque</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="n">q</span><span class="p">.</span><span class="n">enque</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
  <span class="n">q</span><span class="p">.</span><span class="n">deque</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
  <span class="n">q</span><span class="p">.</span><span class="n">enque</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span><span class="p">);</span>
  <span class="n">q</span><span class="p">.</span><span class="n">deque</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">()</span> <span class="o">==</span> <span class="mi">3</span><span class="p">);</span>
  <span class="n">q</span><span class="p">.</span><span class="n">deque</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">()</span> <span class="o">==</span> <span class="mi">4</span><span class="p">);</span>
  <span class="n">q</span><span class="p">.</span><span class="n">deque</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">());</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"All tests pass"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

<span class="p">}</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cassert&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">test_concurrent_lock_free_queue</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">MyLockFreeQueue</span> <span class="n">q</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">num_threads</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">num_ops</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">enqueue_threads</span><span class="p">[</span><span class="n">num_threads</span><span class="p">];</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">dequeue_threads</span><span class="p">[</span><span class="n">num_threads</span><span class="p">];</span>

    <span class="c1">// Enqueue and dequeue concurrently</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_threads</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">enqueue_threads</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">([</span><span class="o">&amp;</span><span class="n">q</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">num_ops</span><span class="p">]</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">num_ops</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">q</span><span class="p">.</span><span class="n">enque</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">num_ops</span> <span class="o">+</span> <span class="n">j</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">});</span>

        <span class="n">dequeue_threads</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">([</span><span class="o">&amp;</span><span class="n">q</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">num_ops</span><span class="p">]</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">num_ops</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">deque</span><span class="p">(</span><span class="n">val</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// Check return value to avoid undefined behavior</span>
                    <span class="c1">// Process val (optional)</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">});</span>
    <span class="p">}</span>

    <span class="c1">// Join all threads</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_threads</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">enqueue_threads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">join</span><span class="p">();</span>
        <span class="n">dequeue_threads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">join</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="c1">// Ensure queue is empty</span>
    <span class="c1">// assert(q.empty());</span>

    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">cout_mutex</span><span class="p">;</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">cout_mutex</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">q</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"test concurrent lock free queue All tests pass"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// test_concurrent_lock_free_queue();</span>
  <span class="n">test_my_lock_free_queue</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="references">References</h2> <p><a href="https://book-of-gehn.github.io/articles/2020/04/28/Lock-Free-Queue-Part-II.html" rel="external nofollow noopener" target="_blank">https://book-of-gehn.github.io/articles/2020/04/28/Lock-Free-Queue-Part-II.html</a> I don‚Äôt fully get the idea in this article.</p> <p><a href="https://mp.weixin.qq.com/s?__biz=Mzg4NDQ0OTI4Ng==&amp;mid=2247490953&amp;idx=1&amp;sn=00dd064b978d2bae85939f5e387d1022&amp;chksm=cfb954e0f8ceddf641401126ad96bb5ca8ec37d206f66792aaae9f48decdc1292eef2c296f16&amp;cur_album_id=3140091333123276802&amp;scene=189#wechat_redirect" rel="external nofollow noopener" target="_blank">https://mp.weixin.qq.com/s?__biz=Mzg4NDQ0OTI4Ng==&amp;mid=2247490953&amp;idx=1&amp;sn=00dd064b978d2bae85939f5e387d1022&amp;chksm=cfb954e0f8ceddf641401126ad96bb5ca8ec37d206f66792aaae9f48decdc1292eef2c296f16&amp;cur_album_id=3140091333123276802&amp;scene=189#wechat_redirect</a> This article talks about licked list implementaion and array implementaion which is useful.</p> <p><a href="https://github.com/cameron314/concurrentqueue" rel="external nofollow noopener" target="_blank">https://github.com/cameron314/concurrentqueue</a></p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2020/learning-based-memory-allocation-for-c-server-workloads-summary/">Learning-based memory allocation for C++ server workloads summary</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2020/my-question/">my question:</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2021/binary-search-algorithm-variant/">Binary search algorithm variant</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/docker-rocksdb-build/">Docker Rocksdb build</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/difference-between-dockerfile-and-docker-compose/">Difference between Dockerfile and Docker Compose</a> </li> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> ¬© Copyright 2025 Zhutao Zhuang. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. Last updated: February 04, 2025. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?b7816bd189846d29eded8745f9c4cf77"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.min.js" integrity="sha256-rjmgmaB99riUNcdlrDtcAiwtLIojSxNyUFdl+Qh+rB4=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script async src="https://www.googletagmanager.com/gtag/js?id="></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","");</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> <script type="module" src="/assets/js/search/ninja-keys.min.js?601a2d3465e2a52bec38b600518d5f70"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script>let theme=determineComputedTheme();const ninjaKeys=document.querySelector("ninja-keys");"dark"===theme?ninjaKeys.classList.add("dark"):ninjaKeys.classList.remove("dark");const openSearchModal=()=>{const e=$("#navbarNav");e.hasClass("show")&&e.collapse("hide"),ninjaKeys.open()};</script> <script>const ninja=document.querySelector("ninja-keys");ninja.data=[{id:"nav-about",title:"about",section:"Navigation",handler:()=>{window.location.href="/"}},{id:"nav-blog",title:"blog",description:"",section:"Navigation",handler:()=>{window.location.href="/blog/"}},{id:"nav-publications",title:"publications",description:"publications by categories in reversed chronological order. generated by jekyll-scholar.",section:"Navigation",handler:()=>{window.location.href="/publications/"}},{id:"post-tokenizer",title:"Tokenizer",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2025/tokenizer/"}},{id:"post-lock-free-queue-implementation-cpp",title:"Lock free queue implementation cpp",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2025/lock-free-queue/"}},{id:"post-nanogpt-kv-cache-first-attempt",title:"nanogpt kv cache first attempt",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2025/llm-kv-cache-first-attempt/"}},{id:"post-set-up-vim-in-vscode",title:"Set up vim in vscode",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2025/set-up-vim-in-vscode/"}},{id:"post-chibicc-simple-c-compiler-for-statement",title:"chibicc - Simple c compiler for statement",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2025/chibicc-for-statement/"}},{id:"post-chibicc-simple-c-compiler-if-statement",title:"chibicc - Simple c compiler if statement",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2025/chibicc-if-statement/"}},{id:"post-chibicc-simple-c-compiler-block-node",title:"chibicc - Simple c compiler block {} node",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2025/chibicc-block/"}},{id:"post-chibicc-simple-c-compiler-return-keyword",title:"chibicc - Simple c compiler return keyword",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2025/chibicc-return-keyword/"}},{id:"post-learned-idnex-survey",title:"Learned idnex survey",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2025/learned-index-survery/"}},{id:"post-chibicc-c-compiler-multi-char-variable-name",title:"chibicc C compiler - multi char variable name",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2025/chibicc-multi-char-var-name/"}},{id:"post-c-and-linux-kernel-memory-allocation",title:"C++ and linux kernel memory allocation",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2025/cpp-interview-questions/"}},{id:"post-chibicc-c-compiler-parser-review-and-expression-evaluator",title:"chibicc C compiler - parser review and expression evaluator",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2025/chibicc-parser-review-and-calculator/"}},{id:"post-imperative-programming-vs-declarative-programming",title:"Imperative programming vs. Declarative programming",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/imperative-programming/"}},{id:"post-autodiff-implementation-kernel-and-memory-management",title:"Autodiff implementation - kernel and memory management",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/uw-sysml-assign2/"}},{id:"post-hash-in-cpp",title:"Hash in cpp",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/hash-in-cpp/"}},{id:"post-computer-basics",title:"Computer basics",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/some-basic-computer-knowledge/"}},{id:"post-rdma",title:"Rdma",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/rdma/"}},{id:"post-topo-sort",title:"Topo sort",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/topo-sort/"}},{id:"post-autodiff-implementation",title:"Autodiff implementation",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/uw-sysml-assign/"}},{id:"post-palindrome-substring-partition",title:"palindrome substring partition",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/palindrome-substring-partition/"}},{id:"post-stf-cs149-flash-attention",title:"Stf CS149 flash attention",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/cs149gpt/"}},{id:"post-speed-up-matrix-multiplication-2",title:"Speed up matrix multiplication 2",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/matrix-mul-comparison/"}},{id:"post-elf-loading",title:"Elf Loading",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/elf-loading/"}},{id:"post-stf-cs149-parallel-programming-assign3",title:"Stf CS149 Parallel Programming - Assign3",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/cs149-assign3/"}},{id:"post-stf-cs149-parallel-programming-lecture11-cache-coherence",title:"Stf CS149 Parallel Programming - Lecture11 - Cache coherence",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/cs149-lecture11-cache-coherence/"}},{id:"post-stf-cs149-parallel-programming-lecture-7-cuda-programming-model",title:"Stf CS149 Parallel Programming - Lecture 7 - Cuda programming model",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/cs149-lecture7-cuda/"}},{id:"post-stf-cs149-parallel-programming-assign2",title:"Stf CS149 Parallel Programming - Assign2",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/cs149-assign2/"}},{id:"post-stf-cs149-parallel-programming-lecture-5-amp-6-performance-optimization",title:"Stf CS149 Parallel Programming - Lecture 5&amp;6 - Performance optimization",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/stf-cs149-lecture-takeaway/"}},{id:"post-stf-cs149-parallel-programming-assign1",title:"Stf CS149 Parallel Programming - Assign1",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/stf-cs149-assign1/"}},{id:"post-ssh-display-image-on-local-server",title:"ssh display image on local server",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/ssh-display-img/"}},{id:"post-c-compiler-single-letter-local-variable",title:"C compiler - single letter local variable",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/chibicc-single-letter-ident/"}},{id:"post-c-compiler-parse-example-walkthrough",title:"C compiler - parse example walkthrough",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/statement-and-comparison/"}},{id:"post-linux-get-cpu-time-and-wall-clock-time",title:"Linux get cpu time and wall clock time",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/get-function-cpu-time/"}},{id:"post-simple-c-compiler-unary",title:"Simple c compiler unary",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/chibicc-unary/"}},{id:"post-simple-c-compiler-gen-expr",title:"Simple c compiler gen expr",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/chibicc-gen-expr/"}},{id:"post-python-pyplot-trick",title:"Python pyplot trick",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/python-plot-trick/"}},{id:"post-simple-lru-cache-cpp-implementation",title:"Simple lru cache cpp implementation",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/lru-cache/"}},{id:"post-python-capture-function-print-output",title:"Python capture function print output",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/capture-output-python/"}},{id:"post-simple-c-compiler",title:"Simple c compiler",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/chibicc-compiler/"}},{id:"post-calloc-and-malloc",title:"calloc and malloc",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/calloc/"}},{id:"post-lightgbm-dataset",title:"LightGBM dataset",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/lightgbm-dataset/"}},{id:"post-difference-between-deep-copy-and-shallow-copy-in-python",title:"Difference between deep copy and shallow copy in python",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/python-deep-copy/"}},{id:"post-python-package-path",title:"Python Package Path",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/python-package-path/"}},{id:"post-micrograd",title:"micrograd",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/micrograd/"}},{id:"post-cpp-thread-local",title:"cpp thread local",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/cpp-thread-local/"}},{id:"post-cpp-async",title:"cpp async",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/cpp-async/"}},{id:"post-python-dataframe-drop-row",title:"python dataframe drop row",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/df-drop-row/"}},{id:"post-git-merge-file-from-another-branch",title:"Git merge file from another branch",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/git-merge-file-from-another-branch/"}},{id:"post-efficiency-tips",title:"Efficiency tips",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/efficiency-tips/"}},{id:"post-speed-up-matrix-multiplication",title:"Speed up matrix multiplication",description:"",section:"Posts",handler:()=>{window.location.href="/blog/2024/matrix-multiplication/"}},{id:"post-how-to-write-research-paper",title:"How to write research paper",description:"How to write research paper",section:"Posts",handler:()=>{window.location.href="/blog/2024/how-to-write-research-paper/"}},{id:"post-fast-nano-gpt-training",title:"Fast nano-gpt training",description:"llm",section:"Posts",handler:()=>{window.location.href="/blog/2024/gpt-fast/"}},{id:"post-system-for-machine-learning-papers",title:"System for machine learning papers",description:"sysml papers",section:"Posts",handler:()=>{window.location.href="/blog/2024/sysml-papers/"}},{id:"post-nano-gpt-and-transformer",title:"nano-gpt and Transformer",description:"llm",section:"Posts",handler:()=>{window.location.href="/blog/2024/transformer/"}},{id:"post-pytorch-tensor-to",title:"pytorch tensor.to",description:"pytorch",section:"Posts",handler:()=>{window.location.href="/blog/2024/pytorch/"}},{id:"post-install-neovim-with-old-glibc",title:"Install neovim with old glibc",description:"vim",section:"Posts",handler:()=>{window.location.href="/blog/2024/install-neovim/"}},{id:"post-llm-c",title:"llm.c",description:"llm minikune",section:"Posts",handler:()=>{window.location.href="/blog/2024/llm-c/"}},{id:"post-basic-digital-electronic",title:"Basic digital electronic",description:"transistor",section:"Posts",handler:()=>{window.location.href="/blog/2024/digital-electronic/"}},{id:"post-k8s-advance",title:"K8s Advance",description:"k8s minikune",section:"Posts",handler:()=>{window.location.href="/blog/2024/k8s-advance/"}},{id:"post-difference-between-dockerfile-and-docker-compose",title:"Difference between Dockerfile and Docker Compose",description:"",section:"Posts",handler:()=>{window.open("https://bilyz.medium.com/difference-between-dockerfile-and-docker-compose-d6ebdc687785?source=rss-da1663a42461------2","_blank")}},{id:"post-docker-rocksdb-build",title:"Docker Rocksdb build",description:"",section:"Posts",handler:()=>{window.open("https://bilyz.medium.com/docker-rocksdb-build-18a0bf0e0bb0?source=rss-da1663a42461------2","_blank")}},{id:"post-k3s-beginner",title:"K3s beginner",description:"k3s",section:"Posts",handler:()=>{window.location.href="/blog/2024/k3s/"}},{id:"post-docker-rocksdb",title:"Docker RocksDB",description:"cloud",section:"Posts",handler:()=>{window.location.href="/blog/2024/docker-rocksdb/"}},{id:"post-docker-beginner",title:"Docker beginner",description:"cloud",section:"Posts",handler:()=>{window.location.href="/blog/2024/docker-file-compose-diff/"}},{id:"post-git",title:"Git",description:"git",section:"Posts",handler:()=>{window.location.href="/blog/2024/git/"}},{id:"post-lightgbm-usage-and-implementation",title:"LightGBM usage and implementation",description:"Artificial Intelligence",section:"Posts",handler:()=>{window.location.href="/blog/2024/lightgbm-usage/"}},{id:"post-backpropogation-c-implementation",title:"Backpropogation C++ Implementation",description:"Artificial Intelligence",section:"Posts",handler:()=>{window.location.href="/blog/2024/back-propagation/"}},{id:"post-conda-usage",title:"Conda usage",description:"Artificial Intelligence",section:"Posts",handler:()=>{window.location.href="/blog/2024/conda/"}},{id:"post-install-k8s-cluster-with-3-ubuntu-nodes",title:"Install K8s cluster with 3 ubuntu nodes",description:"cloud",section:"Posts",handler:()=>{window.location.href="/blog/2024/cloud/"}},{id:"post-convert-svg-figures-to-pdf-latex-before-submitting-to-arxiv",title:"Convert SVG figures to pdf_latex before submitting to arxiv",description:"Convert SVG figures to pdf_latex before submitting to arxiv",section:"Posts",handler:()=>{window.location.href="/blog/2024/arxiv-cleaner/"}},{id:"post-binary-search-algorithm-variant",title:"Binary search algorithm variant",description:"",section:"Posts",handler:()=>{window.open("https://bilyz.medium.com/binary-search-algorithm-variant-9b5310473471?source=rss-da1663a42461------2","_blank")}},{id:"post-my-question",title:"my question:",description:"",section:"Posts",handler:()=>{window.open("https://bilyz.medium.com/my-question-a69930f167f0?source=rss-da1663a42461------2","_blank")}},{id:"post-learning-based-memory-allocation-for-c-server-workloads-summary",title:"Learning-based memory allocation for C++ server workloads summary",description:"",section:"Posts",handler:()=>{window.open("https://bilyz.medium.com/learning-based-memory-allocation-for-c-server-workloads-summary-479e9cd6d6f6?source=rss-da1663a42461------2","_blank")}},{id:"post-a-post-with-formatting-and-links",title:"a post with formatting and links",description:"march &amp; april, looking forward to summer",section:"Posts",handler:()=>{window.location.href="/blog/2015/formatting-and-links/"}},{id:"news-a-paper-dumpkv-accepted-by-vldb-39-25",title:"A paper(DumpKV) accepted by VLDB&#39;25",description:"",section:"News"},{id:"projects-project-1",title:"project 1",description:"with background image",section:"Projects",handler:()=>{window.location.href="/projects/1_project/"}},{id:"projects-project-2",title:"project 2",description:"a project with a background image and giscus comments",section:"Projects",handler:()=>{window.location.href="/projects/2_project/"}},{id:"projects-project-3-with-very-long-name",title:"project 3 with very long name",description:"a project that redirects to another website",section:"Projects",handler:()=>{window.location.href="/projects/3_project/"}},{id:"projects-project-4",title:"project 4",description:"another without an image",section:"Projects",handler:()=>{window.location.href="/projects/4_project/"}},{id:"projects-project-5",title:"project 5",description:"a project with a background image",section:"Projects",handler:()=>{window.location.href="/projects/5_project/"}},{id:"projects-project-6",title:"project 6",description:"a project with no image",section:"Projects",handler:()=>{window.location.href="/projects/6_project/"}},{id:"socials-email",title:"Send email",section:"Socials",handler:()=>{window.open("mailto:%7A%68%75%61%6E%67%7A%68%75%74%61%6F@%67%6D%61%69%6C.%63%6F%6D","_blank")}},{id:"socials-github",title:"GitHub",section:"Socials",handler:()=>{window.open("https://github.com/BilyZ98","_blank")}},{id:"socials-rss",title:"RSS Feed",section:"Socials",handler:()=>{window.open("/feed.xml","_blank")}},{id:"light-theme",title:"Change theme to light",description:"Change the theme of the site to Light",section:"Theme",handler:()=>{setThemeSetting("light")}},{id:"dark-theme",title:"Change theme to dark",description:"Change the theme of the site to Dark",section:"Theme",handler:()=>{setThemeSetting("dark")}},{id:"system-theme",title:"Use system default theme",description:"Change the theme of the site to System Default",section:"Theme",handler:()=>{setThemeSetting("system")}}];</script> <script src="/assets/js/shortcut-key.js"></script> </body> </html>