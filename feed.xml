<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://bilyz98.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://bilyz98.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-01-17T10:44:25+00:00</updated><id>https://bilyz98.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">nanogpt kv cache first attempt</title><link href="https://bilyz98.github.io/blog/2025/llm-kv-cache-first-attempt/" rel="alternate" type="text/html" title="nanogpt kv cache first attempt"/><published>2025-01-16T11:59:00+00:00</published><updated>2025-01-16T11:59:00+00:00</updated><id>https://bilyz98.github.io/blog/2025/llm-kv-cache-first-attempt</id><content type="html" xml:base="https://bilyz98.github.io/blog/2025/llm-kv-cache-first-attempt/"><![CDATA[<h2 id="1-run-basic-nano-gpt">1. Run basic nano-gpt</h2> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/karpathy/nanoGPT.git

</code></pre></div></div> <p>Install necessary packages</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip install -r requirements.txt
</code></pre></div></div> <p>I have these packages in the requirements.txt</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>blobfile==2.0.1
certifi==2022.12.7
charset-normalizer==3.0.1
filelock==3.9.0
idna==3.4
lxml==4.9.2
numpy==1.24.2
pycryptodomex==3.17
pytz==2022.7.1
regex==2022.10.31
requests==2.28.2
tokenizers==0.13.2
torch==2.0.0
typing_extensions==4.4.0
urllib3==1.26.14
torch==2.0.0
numpy==1.24.2
transformers==4.28.1
datasets==2.11.0
tiktoken==0.3.3
wandb==0.14.2
tqdm==4.65.0
</code></pre></div></div> <p>Follow quick start guidance in nanogpt repo do make sure that we can run training and inference successfully.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python data/shakespeare_char/prepare.py
python train.py --compile=False config/train_shakespeare_char.py
python sample.py --out_dir=out-shakespeare-char
</code></pre></div></div> <p>My python version is 3.11 which is too high for model compile so I added <code class="language-plaintext highlighter-rouge">--compile=False</code> in train command.</p> <p>With my A800 gpu, I get a loss 0.0449 after 5000 iteration training.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iter 4970: loss 0.0461, time 18.12ms, mfu 20.21%
iter 4980: loss 0.0441, time 18.14ms, mfu 20.24%
iter 4990: loss 0.0464, time 18.13ms, mfu 20.27%
step 5000: train loss 0.0383, val loss 4.7262
iter 5000: loss 0.0449, time 3352.84ms, mfu 18.26%
</code></pre></div></div> <h2 id="2-load-gpt-2-models--checkpoints-and-test-performance">2. Load GPT-2 models checkpoints and test performance</h2> <h2 id="3-implement-kv-cache-for-faster-inference">3. Implement KV cache for faster inference</h2> <h2 id="4-test-kv-cache-performance">4. Test KV cache performance</h2> <h2 id="references">References</h2> <p><a href="https://www.youtube.com/watch?v=80bIUggRJf4&amp;t=247s">youtube video llm kv cache explanation</a></p> <p><a href="https://github.com/karpathy/nanoGPT/pull/246/commits/5cc9bab7e2402caf69a00e9c38fc45517e958748">requirements.txt to run nano-gpt</a> <a href="https://github.com/karpathy/nanoGPT/pull/76">nano-gpt kv cache pr example</a></p> <p><a href="https://github.com/huggingface/transformers/blob/6bc0fbcfa7acb6ac4937e7456a76c2f7975fefec/src/transformers/modeling_outputs.py#L714">huggingface transformers kv cache source code on github</a></p> <p>https://zhuanlan.zhihu.com/p/646577898</p> <p>https://zhuanlan.zhihu.com/p/624740065</p> <p><a href="https://huggingface.co/docs/transformers/main_classes/output#transformers.modeling_outputs.CausalLMOutputWithPast">huggingface transformers API documentation</a></p>]]></content><author><name></name></author><category term="ml"/><category term="llm"/><category term="ml"/><category term="llm"/><summary type="html"><![CDATA[1. Run basic nano-gpt]]></summary></entry><entry><title type="html">Set Up Vim In Vscode</title><link href="https://bilyz98.github.io/blog/2025/set-up-vim-in-vscode/" rel="alternate" type="text/html" title="Set Up Vim In Vscode"/><published>2025-01-16T00:00:00+00:00</published><updated>2025-01-16T00:00:00+00:00</updated><id>https://bilyz98.github.io/blog/2025/set-up-vim-in-vscode</id><content type="html" xml:base="https://bilyz98.github.io/blog/2025/set-up-vim-in-vscode/"><![CDATA[<p>[ssh to remote node in vscode from wsl]https://stackoverflow.com/questions/60150466/can-i-ssh-from-wsl-in-visual-studio-code</p> <p>https://www.youtube.com/watch?v=GST8we5uABo&amp;t=426s</p> <p>https://medium.com/@nikmas_dev/vscode-neovim-setup-keyboard-centric-powerful-reliable-clean-and-aesthetic-development-582d34297985</p>]]></content><author><name></name></author><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">chibicc - Simple c compiler if statement</title><link href="https://bilyz98.github.io/blog/2025/chibicc-if-statement/" rel="alternate" type="text/html" title="chibicc - Simple c compiler if statement"/><published>2025-01-14T11:59:00+00:00</published><updated>2025-01-14T11:59:00+00:00</updated><id>https://bilyz98.github.io/blog/2025/chibicc-if-statement</id><content type="html" xml:base="https://bilyz98.github.io/blog/2025/chibicc-if-statement/"><![CDATA[<p><a href="https://github.com/BilyZ98/chibicc/commit/2f132cf8e68f0adf92bae038b75ea6da425e223c">Commit history for if statement feature</a></p> <h2 id="what-is-changed-">What is changed ?</h2> <p>For parser, new node type called <code class="language-plaintext highlighter-rouge">ND_IF</code> is introduced. Three new nodes are introduced for <code class="language-plaintext highlighter-rouge">Node</code> type in parser. They are called <code class="language-plaintext highlighter-rouge">cond</code>, <code class="language-plaintext highlighter-rouge">then</code>, <code class="language-plaintext highlighter-rouge">els</code> which corresponds to code in <code class="language-plaintext highlighter-rouge">if(cond){ } else {}</code>. New production rule is introduced to deal with <code class="language-plaintext highlighter-rouge">if</code> statement</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// stmt = "return" expr ";" </span>
<span class="c1">//        | "{" compound_stmt</span>
<span class="c1">//        | expr_stmt</span>
<span class="c1">//        | "if" "(" expr ")" stmt ("else" stmt)?</span>
<span class="k">static</span> <span class="n">Node</span><span class="o">*</span> <span class="nf">stmt</span><span class="p">(</span><span class="n">Token</span><span class="o">**</span><span class="n">rest</span><span class="p">,</span> <span class="n">Token</span><span class="o">*</span> <span class="n">tok</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="n">equal</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">"return"</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">new_unary</span><span class="p">(</span><span class="n">ND_RETURN</span><span class="p">,</span> <span class="n">expr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">));</span>
    <span class="o">*</span><span class="n">rest</span> <span class="o">=</span> <span class="n">skip</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">";"</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span><span class="p">(</span><span class="n">equal</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">"{"</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">compound_stmt</span><span class="p">(</span><span class="n">rest</span><span class="p">,</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">if</span><span class="p">(</span><span class="n">equal</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">"if"</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">tok</span> <span class="o">=</span> <span class="n">skip</span><span class="p">(</span><span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="s">"("</span><span class="p">);</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">(</span><span class="n">ND_IF</span><span class="p">);</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">cond</span> <span class="o">=</span> <span class="n">expr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">tok</span><span class="p">);</span>
    <span class="n">tok</span> <span class="o">=</span> <span class="n">skip</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">")"</span><span class="p">);</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">then</span> <span class="o">=</span> <span class="n">stmt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">tok</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">equal</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">"else"</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">node</span><span class="o">-&gt;</span><span class="n">els</span> <span class="o">=</span> <span class="n">stmt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="o">*</span><span class="n">rest</span> <span class="o">=</span> <span class="n">tok</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nf">expr_stmt</span><span class="p">(</span><span class="n">rest</span><span class="p">,</span> <span class="n">tok</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>For code generator, assembly code generation for <code class="language-plaintext highlighter-rouge">if</code> condition is introduced in <code class="language-plaintext highlighter-rouge">gen_stmt</code>. First we generate assembly code for <code class="language-plaintext highlighter-rouge">cond</code> node, and then we generate <code class="language-plaintext highlighter-rouge">je $0, %rax</code> to check condtion of <code class="language-plaintext highlighter-rouge">cond</code> node, and call <code class="language-plaintext highlighter-rouge">jump .L.else.%d</code> to do them instruction jump, <code class="language-plaintext highlighter-rouge">%d</code> is used to uniquly identify each <code class="language-plaintext highlighter-rouge">else</code> block. Because multiple <code class="language-plaintext highlighter-rouge">if</code> statement can be nested at the same time.</p>]]></content><author><name></name></author><category term="compiler"/><category term="c"/><category term="compiler"/><summary type="html"><![CDATA[Commit history for if statement feature]]></summary></entry><entry><title type="html">chibicc - Simple c compiler for statement</title><link href="https://bilyz98.github.io/blog/2025/chibicc-for-statement/" rel="alternate" type="text/html" title="chibicc - Simple c compiler for statement"/><published>2025-01-14T11:59:00+00:00</published><updated>2025-01-14T11:59:00+00:00</updated><id>https://bilyz98.github.io/blog/2025/chibicc-for-statement</id><content type="html" xml:base="https://bilyz98.github.io/blog/2025/chibicc-for-statement/"><![CDATA[<p><a href="https://github.com/BilyZ98/chibicc/commit/ed1f13abd63cc10e7cbd76c6f6de784df0f801c1">Commit history of for statement feature</a></p> <h2 id="what-is-changed-to-introduce-for-loop-">What is changed to introduce for loop ?</h2> <p>No big changes on top of if statement feature.</p> <p>For parser, add another grammar/production rule for <code class="language-plaintext highlighter-rouge">for</code> statement.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// stmt = "return" expr ";" </span>
<span class="c1">//        | "{" compound_stmt</span>
<span class="c1">//        | expr_stmt</span>
<span class="c1">//        | "if" "(" expr ")" stmt ("else" stmt)?</span>
<span class="c1">//        | "for" "(" expr_stmt expr? ";" expr? ")" stmt </span>
<span class="k">static</span> <span class="n">Node</span><span class="o">*</span> <span class="nf">stmt</span><span class="p">(</span><span class="n">Token</span><span class="o">**</span><span class="n">rest</span><span class="p">,</span> <span class="n">Token</span><span class="o">*</span> <span class="n">tok</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="n">equal</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">"return"</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">new_unary</span><span class="p">(</span><span class="n">ND_RETURN</span><span class="p">,</span> <span class="n">expr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">));</span>
    <span class="o">*</span><span class="n">rest</span> <span class="o">=</span> <span class="n">skip</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">";"</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span><span class="p">(</span><span class="n">equal</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">"{"</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">compound_stmt</span><span class="p">(</span><span class="n">rest</span><span class="p">,</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">if</span><span class="p">(</span><span class="n">equal</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">"if"</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">tok</span> <span class="o">=</span> <span class="n">skip</span><span class="p">(</span><span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="s">"("</span><span class="p">);</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">(</span><span class="n">ND_IF</span><span class="p">);</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">cond</span> <span class="o">=</span> <span class="n">expr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">tok</span><span class="p">);</span>
    <span class="n">tok</span> <span class="o">=</span> <span class="n">skip</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">")"</span><span class="p">);</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">then</span> <span class="o">=</span> <span class="n">stmt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">tok</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">equal</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">"else"</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">node</span><span class="o">-&gt;</span><span class="n">els</span> <span class="o">=</span> <span class="n">stmt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="o">*</span><span class="n">rest</span> <span class="o">=</span> <span class="n">tok</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span><span class="p">(</span><span class="n">equal</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">"for"</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">tok</span> <span class="o">=</span> <span class="n">skip</span><span class="p">(</span><span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="s">"("</span><span class="p">);</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">(</span><span class="n">ND_FOR</span><span class="p">);</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">init</span> <span class="o">=</span> <span class="n">expr_stmt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">tok</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">equal</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">";"</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">node</span><span class="o">-&gt;</span><span class="n">cond</span> <span class="o">=</span> <span class="n">expr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">tok</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">tok</span> <span class="o">=</span> <span class="n">skip</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">";"</span><span class="p">);</span>

    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">equal</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">")"</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">inc</span> <span class="o">=</span> <span class="n">expr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">tok</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">tok</span> <span class="o">=</span> <span class="n">skip</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">")"</span><span class="p">);</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">then</span> <span class="o">=</span> <span class="n">stmt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">tok</span><span class="p">);</span>
    <span class="o">*</span><span class="n">rest</span> <span class="o">=</span> <span class="n">tok</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nf">expr_stmt</span><span class="p">(</span><span class="n">rest</span><span class="p">,</span> <span class="n">tok</span><span class="p">);</span>
<span class="p">}</span>

</code></pre></div></div> <p>Introduce <code class="language-plaintext highlighter-rouge">init</code> and <code class="language-plaintext highlighter-rouge">inc</code> node inside of <code class="language-plaintext highlighter-rouge">Node</code> type to represent initialization and increment operation in <code class="language-plaintext highlighter-rouge">for</code> statement. <code class="language-plaintext highlighter-rouge">for(init;cond; inc){}</code></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">Node</span> <span class="n">Node</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
  <span class="n">NodeKind</span> <span class="n">kind</span><span class="p">;</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">lhs</span><span class="p">;</span> <span class="c1">//left hand side</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">rhs</span><span class="p">;</span> <span class="c1">// right hand side</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span> <span class="c1">// next node</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">body</span><span class="p">;</span> <span class="c1">// {} body node</span>

  <span class="c1">// "if" or "for" statement</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">cond</span><span class="p">;</span> 
  <span class="n">Node</span><span class="o">*</span> <span class="n">then</span><span class="p">;</span> 
  <span class="n">Node</span><span class="o">*</span> <span class="n">els</span><span class="p">;</span> 
  <span class="n">Node</span><span class="o">*</span> <span class="n">init</span><span class="p">;</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">inc</span><span class="p">;</span>


  <span class="c1">// char name;</span>
  <span class="n">Obj</span><span class="o">*</span> <span class="n">obj</span><span class="p">;</span> <span class="c1">// used if kind == ND_VAR</span>
  <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>  <span class="c1">// used if kind == ND_NUM</span>
<span class="p">};</span>

</code></pre></div></div> <p>For code generator, generate <code class="language-plaintext highlighter-rouge">.L.begin.%d:</code> to indicate the start of the for block. Use <code class="language-plaintext highlighter-rouge">cmp $0, %%rax</code> and <code class="language-plaintext highlighter-rouge">jmp .L.end.%d</code> after <code class="language-plaintext highlighter-rouge">cond</code> to go out of for block. Use <code class="language-plaintext highlighter-rouge">jmp .L.begin.%d</code> to jmp back to the begining of the for block at the end. And then comparison at the begining will decide whether to jump out of the for block or not.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">case</span> <span class="n">ND_FOR</span><span class="p">:</span> <span class="p">{</span>
      <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">count_depth</span><span class="p">();</span>
      <span class="n">gen_stmt</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">);</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">".L.begin.%d:</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
      <span class="k">if</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">cond</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">gen_expr</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">cond</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"  cmp $0, %%rax</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"  je .L.end.%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">c</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="n">gen_stmt</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">then</span><span class="p">);</span>
      <span class="k">if</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">inc</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">gen_expr</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">inc</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"  jmp .L.begin.%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">c</span><span class="p">);</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">".L.end.%d:</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">c</span><span class="p">);</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="compiler"/><category term="c"/><category term="compiler"/><summary type="html"><![CDATA[Commit history of for statement feature]]></summary></entry><entry><title type="html">chibicc - Simple c compiler block {} node</title><link href="https://bilyz98.github.io/blog/2025/chibicc-block/" rel="alternate" type="text/html" title="chibicc - Simple c compiler block {} node"/><published>2025-01-13T11:59:00+00:00</published><updated>2025-01-13T11:59:00+00:00</updated><id>https://bilyz98.github.io/blog/2025/chibicc-block</id><content type="html" xml:base="https://bilyz98.github.io/blog/2025/chibicc-block/"><![CDATA[<p><a href="https://github.com/BilyZ98/chibicc/commit/50d55515fe3a882f90fec3fbee8b5795239b60f8">Commit history for block feature</a></p> <h2 id="expected-an-expression-error-after-adding-block--node">expected an expression error after adding block {} node</h2> <p>Problem:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">{</span> <span class="nv">a</span><span class="o">=</span>3<span class="p">;</span> <span class="k">return </span>a<span class="p">;</span> <span class="o">}</span>
   ^ expected an expression
make: <span class="k">***</span> <span class="o">[</span>Makefile:12: <span class="nb">test</span><span class="o">]</span> Error 1
</code></pre></div></div> <p>Root cause:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// compound_stmt = stmt* "}"</span>
<span class="k">static</span> <span class="n">Node</span><span class="o">*</span> <span class="nf">compound_stmt</span><span class="p">(</span><span class="n">Token</span><span class="o">**</span> <span class="n">rest</span><span class="p">,</span> <span class="n">Token</span><span class="o">*</span> <span class="n">tok</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Node</span> <span class="n">head</span> <span class="o">=</span> <span class="p">{};</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">head</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">equal</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">"}"</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// This is the bug, should be tok not tok-&gt;next;</span>
    <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">stmt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">(</span><span class="n">ND_BLOCK</span><span class="p">);</span>
  <span class="n">node</span><span class="o">-&gt;</span><span class="n">body</span> <span class="o">=</span> <span class="n">head</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
  <span class="o">*</span><span class="n">rest</span> <span class="o">=</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">node</span><span class="p">;</span>

<span class="p">}</span>
</code></pre></div></div> <p>Fix:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// compound_stmt = stmt* "}"</span>
<span class="k">static</span> <span class="n">Node</span><span class="o">*</span> <span class="nf">compound_stmt</span><span class="p">(</span><span class="n">Token</span><span class="o">**</span> <span class="n">rest</span><span class="p">,</span> <span class="n">Token</span><span class="o">*</span> <span class="n">tok</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Node</span> <span class="n">head</span> <span class="o">=</span> <span class="p">{};</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">head</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">equal</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">"}"</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">stmt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">tok</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">(</span><span class="n">ND_BLOCK</span><span class="p">);</span>
  <span class="n">node</span><span class="o">-&gt;</span><span class="n">body</span> <span class="o">=</span> <span class="n">head</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
  <span class="o">*</span><span class="n">rest</span> <span class="o">=</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">node</span><span class="p">;</span>

<span class="p">}</span>
</code></pre></div></div> <h2 id="what-is-done-to-introduce-block-concept">What is done to introduce block concept?</h2> <p>Introduce another node in node struct called <code class="language-plaintext highlighter-rouge">body</code> to store the code content inside block</p> <p>No change is made to tokenizer</p> <p>For parser, introduce <code class="language-plaintext highlighter-rouge">compound_stmt</code> production/grammar rule for <code class="language-plaintext highlighter-rouge">stmt</code> generation rule.</p> <p>For code generator, start generating code from <code class="language-plaintext highlighter-rouge">Function-&gt;body</code> part which is a block itself. Each <code class="language-plaintext highlighter-rouge">body</code> inside each block has its own list of nodes. Previously we only have on list of nodes. Now we have one list of nodes for each block node.</p> <p>I guess this is for variable scope purpose, althought this has not been done in this commit history.</p>]]></content><author><name></name></author><category term="compiler"/><category term="c"/><category term="compiler"/><summary type="html"><![CDATA[Commit history for block feature]]></summary></entry><entry><title type="html">chibicc - Simple c compiler return keyword</title><link href="https://bilyz98.github.io/blog/2025/chibicc-return-keyword/" rel="alternate" type="text/html" title="chibicc - Simple c compiler return keyword"/><published>2025-01-12T11:59:00+00:00</published><updated>2025-01-12T11:59:00+00:00</updated><id>https://bilyz98.github.io/blog/2025/chibicc-return-keyword</id><content type="html" xml:base="https://bilyz98.github.io/blog/2025/chibicc-return-keyword/"><![CDATA[<h2 id="add-return-keyword-to-simple-c-compiler">Add return keyword to simple c compiler</h2> <p><a href="https://github.com/BilyZ98/chibicc/commit/f94ca394ade26ca861bd205d3714f103eb4dedb9">Commit history</a></p> <p>For tokenizer, <code class="language-plaintext highlighter-rouge">convert_keywords()</code> is added to convert kind of token from identity to keyword. So this means that all basic tokens are identity at first and later convert to keywrod type token.</p> <p>For parser, add extra prudction rule/grammar rule in expr geneartion. <code class="language-plaintext highlighter-rouge">stmt = "return" expr ";" | expr-stmt</code>. New node type <code class="language-plaintext highlighter-rouge">ND_RETURN</code> is added.</p> <p>For code generation, <code class="language-plaintext highlighter-rouge">jmp .L.return</code> is added to jump to specified assembly code.</p> <p>For test, add <code class="language-plaintext highlighter-rouge">return 1; 2; 3</code> to test return actually works.</p>]]></content><author><name></name></author><category term="compiler"/><category term="c"/><category term="compiler"/><summary type="html"><![CDATA[Add return keyword to simple c compiler]]></summary></entry><entry><title type="html">Learned idnex survey</title><link href="https://bilyz98.github.io/blog/2025/learned-index-survery/" rel="alternate" type="text/html" title="Learned idnex survey"/><published>2025-01-08T11:59:00+00:00</published><updated>2025-01-08T11:59:00+00:00</updated><id>https://bilyz98.github.io/blog/2025/learned-index-survery</id><content type="html" xml:base="https://bilyz98.github.io/blog/2025/learned-index-survery/"><![CDATA[<h2 id="what-is-learned-index-and-why">What is learned index and why?</h2> <p>To search a key in b+ tree, traditional way is to do binary search. This complexity time is O(Log_n)</p> <p>Learned index build model to learn the distribution of keys in space. The input is the key number and the output of the model is the location of the key in the storage array space. The time complexity is O(1) which is faster than binary search.</p> <h2 id="current-work">Current work</h2> <p><a href="https://arxiv.org/pdf/1712.01208">The case for learned index structures</a> proposes to replace every node in b+ tree with learned model.</p> <p>Each node contains a model trained from the keys covered by its key ranges.</p> <p>It’s said that in the paper that this hierachy style allows allows model to learn the rough key distribtuion at its key ranges. Bottom level model covers smalles range of keys, it’s easy for the model learn. Top level covers larget range of keys but it only cares about the big structure of the keys distribution and it leaves fine-grained key position to bottom level models.</p> <p>Search process:</p> <p>Model at each level gives its key position prediction until reaches the leaf child.</p> <p>Since model might not give the correct position prediction, learned index make sures that each model prediction error is within a predefined error bound.</p> <p>So it’s guarantee that key is located within the [lower_bound, upper_bound] range given by the model.</p> <p>This paper only mentions how to build model for read only scenario.</p> <p><a href="https://arxiv.org/pdf/1905.08898">ALEX</a> solves the updatable learned index problem.</p> <p>How ?</p> <p>Insert process:</p> <p>For non-full data node, it inserts the key to the predicted position from the model if there is a empty slow in the array..</p> <p>The predcited position might be occupied, so it shifts other elements towards the closet gap by one. ( I am not sure if the model should be trained after this shift operation, I think we should train a new model because that position of shifted key is changed, but the model train cost is too high if we do this for each occupied key.)</p> <p>For full-data node, it can choose to split the data node or matain a single data node but with allocation of largers storage space and retarined a new model.</p> <p>For data node expansion, new position in array of original key is given by new model.</p> <p>This is not the same as traditional binary tree which just does simple copy.</p> <p>For internal nodes, ALEX choose to split the internal nodes horizontally, i.e at the same level.</p> <p>Alex can choose to turn data nodes to internal nodes which is the same as split the node vertically, increasing the depth of the tree?</p> <h2 id="whats-next-">What’s next ?</h2> <p><a href="Learned index survey">https://arxiv.org/pdf/2403.06456</a> talks about development of learned index. It classifies learned index into multi-dimensional and mutable/immutable categories.</p> <p>What’s not talked about is how learned index is efficiently integrated into existing system.</p> <h2 id="references">References</h2> <p><a href="https://www.youtube.com/watch?v=2A3tiAmaq_c">Jeaf dean’s talk about ml for sys in NIPS’25</a></p> <p><a href="https://zongheng.me/pubs/qdtree-sigmod20.pdf">qd-tree</a> . Why only for data analytics?</p> <p><a href="https://www.cidrdb.org/cidr2019/papers/p117-kraska-cidr19.pdf">SageDB: A Learned Database System</a></p> <p><a href="https://dbgroup.cs.tsinghua.edu.cn/ligl/papers/experiment-learned-index.pdf">Learned Index: A Comprehensive Experimental Evaluation</a></p> <p><a href="https://www.usenix.org/conference/osdi20/presentation/wei">Fast RDMA-based Ordered Key-Value Store using Remote Learned Cache</a></p>]]></content><author><name></name></author><category term="learned"/><category term="index"/><category term="research"/><category term="learned"/><category term="index"/><category term="research"/><summary type="html"><![CDATA[What is learned index and why? To search a key in b+ tree, traditional way is to do binary search. This complexity time is O(Log_n)]]></summary></entry><entry><title type="html">chibicc C compiler - multi char variable name</title><link href="https://bilyz98.github.io/blog/2025/chibicc-multi-char-var-name/" rel="alternate" type="text/html" title="chibicc C compiler - multi char variable name"/><published>2025-01-05T11:59:00+00:00</published><updated>2025-01-05T11:59:00+00:00</updated><id>https://bilyz98.github.io/blog/2025/chibicc-multi-char-var-name</id><content type="html" xml:base="https://bilyz98.github.io/blog/2025/chibicc-multi-char-var-name/"><![CDATA[<h3 id="find-bug-in-code-that-leads-to-seg-fault">Find bug in code that leads to seg fault.</h3> <p><a href="https://github.com/BilyZ98/chibicc/commit/3ca91cc6431246e1b23f4503b6442e77e7457246">https://github.com/BilyZ98/chibicc/commit/3ca91cc6431246e1b23f4503b6442e77e7457246</a></p> <p>The bug code is at parse.c. I use gdb to find out the bug location.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>77      ../sysdeps/x86_64/multiarch/strlen-evex.S: No such file or directory.
(gdb) bt
#0  __strlen_evex () at ../sysdeps/x86_64/multiarch/strlen-evex.S:77
#1  0x0000555555555ff7 in find_var (start=0x7fffffffe399 "a;", len=1) at parse.c:194
#2  0x0000555555556140 in primary (rest=0x7fffffffdd30, tok=0x55555555a360) at parse.c:220
#3  0x0000555555555fbf in unary (rest=0x7fffffffdd30, tok=0x55555555a360) at parse.c:187
#4  0x0000555555555e73 in mul (rest=0x7fffffffdd60, tok=0x55555555a360) at parse.c:160
#5  0x0000555555555d9a in add (rest=0x7fffffffdd90, tok=0x55555555a360) at parse.c:138
#6  0x0000555555555c1f in relational (rest=0x7fffffffddc0, tok=0x55555555a360) at parse.c:109
#7  0x0000555555555b46 in equality (rest=0x7fffffffddf0, tok=0x55555555a360) at parse.c:90
#8  0x0000555555555ac1 in assign (rest=0x7fffffffde40, tok=0x55555555a360) at parse.c:78
#9  0x0000555555555a98 in expr (rest=0x7fffffffde40, tok=0x55555555a360) at parse.c:73
#10 0x0000555555555a3d in expr_stmt (rest=0x7fffffffde98, tok=0x55555555a360) at parse.c:65
#11 0x00005555555559e4 in stmt (rest=0x7fffffffde98, tok=0x55555555a360) at parse.c:46
#12 0x0000555555556248 in parse (tok=0x55555555a360) at parse.c:245
#13 0x00005555555558c9 in main (argc=2, argv=0x7fffffffe038) at main.c:9
</code></pre></div></div> <p>function</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">Obj</span><span class="o">*</span> <span class="nf">find_var</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span><span class="p">(</span><span class="n">Obj</span><span class="o">*</span> <span class="n">o_idx</span> <span class="o">=</span> <span class="n">local_obj_ptr</span><span class="p">;</span> <span class="n">o_idx</span><span class="p">;</span> <span class="n">o_idx</span><span class="o">=</span><span class="n">o_idx</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="n">strlen</span><span class="p">(</span><span class="n">o_idx</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">strncmp</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">o_idx</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">o_idx</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>Finally found the bug.</p> <p>I did not include this define at <code class="language-plaintext highlighter-rouge">chibicc.h</code></p> <p>lol.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#define _POSIX_C_SOURCE 200809L
</code></pre></div></div> <p>This line of code enable functions like <code class="language-plaintext highlighter-rouge">strndup, getline, and clock_gettime</code> which are not part of the standard C library but are available in the POSIX standard. Spend really long time on this.</p> <p>Correct code:</p> <p><a href="https://github.com/BilyZ98/chibicc/tree/1651006f9035bb0a1f3afffd1fb328948006cc28">https://github.com/BilyZ98/chibicc/tree/1651006f9035bb0a1f3afffd1fb328948006cc28</a></p>]]></content><author><name></name></author><category term="compiler"/><category term="c"/><category term="compiler"/><category term="cpp"/><summary type="html"><![CDATA[Find bug in code that leads to seg fault.]]></summary></entry><entry><title type="html">C++ and linux kernel memory allocation</title><link href="https://bilyz98.github.io/blog/2025/cpp-interview-questions/" rel="alternate" type="text/html" title="C++ and linux kernel memory allocation"/><published>2025-01-02T11:59:00+00:00</published><updated>2025-01-02T11:59:00+00:00</updated><id>https://bilyz98.github.io/blog/2025/cpp-interview-questions</id><content type="html" xml:base="https://bilyz98.github.io/blog/2025/cpp-interview-questions/"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/EIVDCWHr8EFEl4LX6UqWHQ">How malloc allocates memory?</a></p> <p>kernel memory allocation</p> <ul> <li> <p>buddy algorithm</p> </li> <li> <p>slab allocator</p> </li> </ul> <p>The slab allocator and buddy algorithm are two different memory allocation techniques used in the Linux kernel, each with its own strengths and use cases.</p> <h3 id="buddy-algorithm">Buddy Algorithm</h3> <p>The buddy algorithm is used for allocating memory in large contiguous blocks. It works by dividing memory into blocks of size 2^n and maintaining a binary tree structure. When a memory request is made, the allocator finds the smallest block that can satisfy the request. If a larger block is found, it is split into smaller blocks (buddies) until the desired size is obtained. This method is efficient for allocating large blocks of memory and helps reduce fragmentation](https://www.tutorialspoint.com/allocating-kernel-memory-buddy-system-and-slab-system).</p> <h3 id="slab-allocator">Slab Allocator</h3> <p>The slab allocator, on the other hand, is designed for allocating small, frequently used objects. It maintains caches of pre-allocated memory chunks (slabs) for different object sizes. When an object is needed, it is allocated from the appropriate slab, which reduces the overhead of frequent allocations and deallocations. This method is particularly useful for kernel objects like process descriptors, file descriptors, and other small data structures](https://www.tutorialspoint.com/allocating-kernel-memory-buddy-system-and-slab-system).</p> <h3 id="relationship">Relationship</h3> <p>The relationship between the two lies in their complementary roles within the Linux kernel. The buddy algorithm is used for allocating large contiguous blocks of memory, which can then be subdivided by the slab allocator for smaller, frequently used objects. This combination allows the Linux kernel to efficiently manage memory for both large and small allocations, optimizing performance and reducing fragmentation](https://www.tutorialspoint.com/allocating-kernel-memory-buddy-system-and-slab-system).</p> <p><a href="https://www.tutorialspoint.com/allocating-kernel-memory-buddy-system-and-slab-system">ref 1</a></p> <h3 id="which-algorithm-does-linux-use-when-brk-syscall-is-called-to-allocate-memory-">which algorithm does linux use when brk() syscall is called to allocate memory ?</h3> <p>When the <code class="language-plaintext highlighter-rouge">brk()</code> system call is used in Linux to allocate memory, it primarily relies on the <strong>buddy algorithm</strong> for managing the memory. The <code class="language-plaintext highlighter-rouge">brk()</code> system call adjusts the end of the data segment of a process, effectively increasing or decreasing the amount of memory allocated to the process. The buddy algorithm is used to allocate large contiguous blocks of memory, which can then be managed by the process.</p> <h3 id="difference-between-malloc-and-new-in-c-">Difference between malloc and new in c++ ?</h3> <p>malloc is a system call function. When calling malloc it will not call constructor of class or do memory initialization. <code class="language-plaintext highlighter-rouge">free</code> to free memory.</p> <p>new is a primitive word in c++ itself. <code class="language-plaintext highlighter-rouge">new</code> will call constructor of class and do memory initialization. <code class="language-plaintext highlighter-rouge">new</code> is managed by c++ compiler. <code class="language-plaintext highlighter-rouge">delete</code> to free memory and destructor is called for <code class="language-plaintext highlighter-rouge">delete</code></p> <h3 id="memory-allocation-for-process-in-linux">Memory allocation for process in linux</h3> <ol> <li> <p>For small memory allocation <code class="language-plaintext highlighter-rouge">brk</code> is called.</p> <p><code class="language-plaintext highlighter-rouge">brk</code> will allocate memory from heap and the allocated memory will not be returned to kernel immediately after <code class="language-plaintext highlighter-rouge">free</code>. It will stay in the process memory mapping space for future use.</p> </li> <li> <p>For large memory allocation <code class="language-plaintext highlighter-rouge">mmap</code> is called. For memory size allocation request &gt; 128KB, memory allocated is in file mapping space in process memory space. The physical memory is returned to kernel immediately after <code class="language-plaintext highlighter-rouge">free</code> call which is different from <code class="language-plaintext highlighter-rouge">brk</code></p> </li> </ol> <p><a href="https://mp.weixin.qq.com/s/EIVDCWHr8EFEl4LX6UqWHQ">ref article about memory allocation </a></p>]]></content><author><name></name></author><category term="compiler"/><category term="c"/><category term="compiler"/><category term="cpp"/><category term="linux"/><summary type="html"><![CDATA[How malloc allocates memory?]]></summary></entry><entry><title type="html">chibicc C compiler - parser review and expression evaluator</title><link href="https://bilyz98.github.io/blog/2025/chibicc-parser-review-and-calculator/" rel="alternate" type="text/html" title="chibicc C compiler - parser review and expression evaluator"/><published>2025-01-01T11:59:00+00:00</published><updated>2025-01-01T11:59:00+00:00</updated><id>https://bilyz98.github.io/blog/2025/chibicc-parser-review-and-calculator</id><content type="html" xml:base="https://bilyz98.github.io/blog/2025/chibicc-parser-review-and-calculator/"><![CDATA[<h2 id="lea-and-mov-explanation">lea and mov explanation</h2> <p><code class="language-plaintext highlighter-rouge">lea -4(%rbp), %rax</code> means that memory address that is 4 bytes below current base pointer <code class="language-plaintext highlighter-rouge">rbp</code> is stored in <code class="language-plaintext highlighter-rouge">rax</code> register.</p> <p>For example,</p> <p>assume <code class="language-plaintext highlighter-rouge">%rbp</code> holds value <code class="language-plaintext highlighter-rouge">0x7fffffffddd0</code> offset is 8,</p> <p>then this code</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lea -8(%rbp), %rax
</code></pre></div></div> <p>means</p> <ol> <li>the effective address calculation is <code class="language-plaintext highlighter-rouge">0x7fffffffddd0 -8 = 0x7fffffffdd8</code></li> <li>The value <code class="language-plaintext highlighter-rouge">0x7fffffffdd8</code> is stored in <code class="language-plaintext highlighter-rouge">rax</code> register</li> </ol> <p>I get confused about whether <code class="language-plaintext highlighter-rouge">mov src, dest</code> or <code class="language-plaintext highlighter-rouge">mov dest, src</code> is correct.</p> <p>I learn from this <a href="https://stackoverflow.com/questions/5890724/mov-instruction-in-x86-assembly">stack overflow post about mov in x86 and AT&amp;T</a> that both are valid.</p> <p><code class="language-plaintext highlighter-rouge">mov src, dest</code> is correct in AT&amp;T and <code class="language-plaintext highlighter-rouge">mov dest, src</code> is valid in Intel syntax.</p> <p><a href="https://electronicsreference.com/assembly-language/mov/">Intel x86 mov explanation</a></p> <h3 id="gcc-uses-att-assembly-standard">gcc uses AT&amp;T assembly standard</h3> <p>GCC (GNU Compiler Collection) uses the AT&amp;T assembly syntax by default. This is the standard assembly syntax used in Unix-like systems. However, GCC also supports Intel syntax, and you can switch to it using specific compiler flags if needed.</p> <p>If you’re working on a project and need to use Intel syntax, you can enable it with the <code class="language-plaintext highlighter-rouge">-masm=intel</code> flag. For example:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcc <span class="nt">-masm</span><span class="o">=</span>intel <span class="nt">-o</span> myprogram myprogram.c
</code></pre></div></div> <h2 id="simple-math-expression-evaluator">Simple math expression evaluator</h2> <p>Problem:</p> <p>Implement math expresion evaluator for expression containing <code class="language-plaintext highlighter-rouge">+,-,*,()</code></p> <p>Solution:</p> <p>This problem is very typical and important. It is a problem that uses stack to solve the priority issue between different operator like <code class="language-plaintext highlighter-rouge">+</code> and <code class="language-plaintext highlighter-rouge">*</code>.</p> <p>Since <code class="language-plaintext highlighter-rouge">*</code> has higher priority than <code class="language-plaintext highlighter-rouge">+</code>, so when we meet <code class="language-plaintext highlighter-rouge">+</code> during string scan we can not evalute it immediately because there might be a <code class="language-plaintext highlighter-rouge">*</code> following this <code class="language-plaintext highlighter-rouge">+</code>.</p> <p>For example <code class="language-plaintext highlighter-rouge">3+2*3</code>, we should evaluate <code class="language-plaintext highlighter-rouge">2*3</code> first.</p> <p><a href="https://www.nowcoder.com/practice/c215ba61c8b1443b996351df929dc4d4">ref two stack implementation for expression evaluator</a></p> <ol> <li> <p>for <code class="language-plaintext highlighter-rouge">(</code> , we just push it into ops stack</p> </li> <li> <p>for ‘)’ , we keep evaluating expression until <code class="language-plaintext highlighter-rouge">(</code> is met on <code class="language-plaintext highlighter-rouge">ops</code> stack</p> </li> <li> <p>for numbers, we just push it into nums stack.</p> </li> <li> <p>for <code class="language-plaintext highlighter-rouge">+,-,*</code>, we evaluate the expression in <code class="language-plaintext highlighter-rouge">ops</code> stack if priority of the op of the top of <code class="language-plaintext highlighter-rouge">ops</code> stack is equal or higher than current op in string.</p> </li> </ol> <p>Pay attention that we need to stop if top of the <code class="language-plaintext highlighter-rouge">ops</code> stack is <code class="language-plaintext highlighter-rouge">(</code>, because <code class="language-plaintext highlighter-rouge">()</code> has highest priority.</p> <p>Code:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>

<span class="cp">#include</span> <span class="cpf">&lt;cctype&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stack&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unordered_map&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">op_pri</span> <span class="o">=</span> <span class="p">{</span>
  <span class="p">{</span><span class="sc">'+'</span><span class="p">,</span><span class="mi">1</span><span class="p">},</span>
  <span class="p">{</span><span class="sc">'-'</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>
  <span class="p">{</span><span class="sc">'*'</span><span class="p">,</span><span class="mi">2</span><span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">cal_one</span><span class="p">(</span><span class="n">stack</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;&amp;</span> <span class="n">ops</span><span class="p">,</span> <span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">top</span><span class="p">();</span> 
  <span class="n">nums</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
  <span class="n">nums</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

  <span class="kt">char</span> <span class="n">c</span>  <span class="o">=</span> <span class="n">ops</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
  <span class="n">ops</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
  <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'+'</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">num</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>

  <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span><span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'-'</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">num</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span><span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'*'</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">num</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">num</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">solve</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">stack</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">ops</span><span class="p">;</span>
  <span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">nums</span><span class="p">;</span>

  <span class="n">nums</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">c</span><span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

    <span class="k">if</span><span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">'('</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">ops</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span><span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">')'</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">ops</span><span class="p">.</span><span class="n">top</span><span class="p">()</span> <span class="o">!=</span> <span class="sc">'('</span><span class="p">)</span> <span class="p">{</span>
          <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">cal_one</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">nums</span><span class="p">);</span>
          <span class="n">nums</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="n">ops</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
          <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// digit</span>
      <span class="k">if</span><span class="p">(</span><span class="n">isdigit</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">cur_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">isdigit</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span> <span class="p">{</span>
          <span class="n">cur_num</span> <span class="o">=</span> <span class="n">cur_num</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="sc">'0'</span><span class="p">;</span>
          <span class="n">j</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="n">nums</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">cur_num</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

        <span class="c1">// + - *</span>
        <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'('</span> <span class="o">||</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'-'</span> <span class="o">||</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="sc">'+'</span><span class="p">))</span> <span class="p">{</span>
          <span class="n">nums</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">// This ops.top() != '(' is important. (expr) is highest priority</span>
        <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">ops</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">ops</span><span class="p">.</span><span class="n">top</span><span class="p">()</span> <span class="o">!=</span> <span class="sc">'('</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span><span class="p">(</span><span class="n">op_pri</span><span class="p">[</span><span class="n">ops</span><span class="p">.</span><span class="n">top</span><span class="p">()]</span> <span class="o">&gt;=</span> <span class="n">op_pri</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>  <span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">cal_one</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">nums</span><span class="p">);</span>
            <span class="n">nums</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
          <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
          <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">ops</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
      <span class="p">}</span>

    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">ops</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">cal_one</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">nums</span><span class="p">);</span>
    <span class="n">nums</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">nums</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>


  <span class="n">string</span> <span class="n">s</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>


  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">solve</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>


<span class="p">}</span>
</code></pre></div></div> <p>Test case:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>base<span class="o">)</span> ➜  chibicc git:<span class="o">(</span>main<span class="o">)</span> ✗ g++ math_eval.cc
<span class="o">(</span>base<span class="o">)</span> ➜  chibicc git:<span class="o">(</span>main<span class="o">)</span> ✗ ./a.out <span class="s2">"1"</span>
1
1
<span class="o">(</span>base<span class="o">)</span> ➜  chibicc git:<span class="o">(</span>main<span class="o">)</span> ✗ ./a.out <span class="s2">"2"</span>
2
2
<span class="o">(</span>base<span class="o">)</span> ➜  chibicc git:<span class="o">(</span>main<span class="o">)</span> ✗ ./a.out <span class="s2">"2+1"</span>
2+1
3
<span class="o">(</span>base<span class="o">)</span> ➜  chibicc git:<span class="o">(</span>main<span class="o">)</span> ✗ ./a.out <span class="s2">"2+2*5"</span>
2+2<span class="k">*</span>5
12
<span class="o">(</span>base<span class="o">)</span> ➜  chibicc git:<span class="o">(</span>main<span class="o">)</span> ✗ ./a.out <span class="s2">"2+2*5-8"</span>
2+2<span class="k">*</span>5-8
4
<span class="o">(</span>base<span class="o">)</span> ➜  chibicc git:<span class="o">(</span>main<span class="o">)</span> ✗ ./a.out <span class="s2">"2+2*(5-8)"</span>
2+2<span class="k">*</span><span class="o">(</span>5-8<span class="o">)</span>
<span class="nt">-4</span>
<span class="o">(</span>base<span class="o">)</span> ➜  chibicc git:<span class="o">(</span>main<span class="o">)</span> ✗ ./a.out <span class="s2">"2+2*(5-8)*3"</span>
2+2<span class="k">*</span><span class="o">(</span>5-8<span class="o">)</span><span class="k">*</span>3
<span class="nt">-16</span>
<span class="o">(</span>base<span class="o">)</span> ➜  chibicc git:<span class="o">(</span>main<span class="o">)</span> ✗ ./a.out <span class="s2">"2+2*(5-8*2)"</span>
2+2<span class="k">*</span><span class="o">(</span>5-8<span class="k">*</span>2<span class="o">)</span>
<span class="nt">-20</span>
<span class="o">(</span>base<span class="o">)</span> ➜  chibicc git:<span class="o">(</span>main<span class="o">)</span> ✗ ./a.out <span class="s2">"2+2*(5*8-2)"</span>
2+2<span class="k">*</span><span class="o">(</span>5<span class="k">*</span>8-2<span class="o">)</span>
78
</code></pre></div></div>]]></content><author><name></name></author><category term="compiler"/><category term="c"/><category term="compiler"/><summary type="html"><![CDATA[lea and mov explanation]]></summary></entry></feed>