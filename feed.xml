<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://bilyz98.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://bilyz98.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-02-14T16:37:06+00:00</updated><id>https://bilyz98.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Lock free queue implementation cpp</title><link href="https://bilyz98.github.io/blog/2025/lock-free-queue/" rel="alternate" type="text/html" title="Lock free queue implementation cpp"/><published>2025-01-19T11:59:00+00:00</published><updated>2025-01-19T11:59:00+00:00</updated><id>https://bilyz98.github.io/blog/2025/lock-free-queue</id><content type="html" xml:base="https://bilyz98.github.io/blog/2025/lock-free-queue/"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/-9RJgcpamtXZOFflOkkt5w">lock free queue impl on wechat subscription post</a></p> <h2 id="why-lock-free">Why lock free?</h2> <p>To avoid lock contention between different threads.</p> <h2 id="how-to-implement-it-">How to implement it ?</h2> <h3 id="list-implementation">List implementation</h3> <p>Is this part of code necessary for correct lock free queue implementation ?</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">next</span><span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">tail</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">oldTail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
    <span class="k">continue</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>Yes, the following part of the code is <strong>necessary</strong> in a <strong>lock-free queue implementation</strong> to maintain correctness and avoid a stuck state:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">next</span><span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">tail</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">oldTail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
    <span class="k">continue</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="why-is-this-necessary"><strong>Why is this necessary?</strong></h3> <p>This block helps in <strong>correctly advancing the <code class="language-plaintext highlighter-rouge">tail</code> pointer</strong> when it <strong>lags behind</strong> the actual last node due to contention. Without it, the queue could become stuck in an inefficient state where the <code class="language-plaintext highlighter-rouge">tail</code> pointer does not point to the actual last node, which may cause issues in subsequent enqueue operations.</p> <hr/> <h3 id="example-of-why-this-is-needed"><strong>Example of Why This Is Needed</strong></h3> <p>Assume a <strong>multi-threaded</strong> environment where multiple threads are enqueuing elements.</p> <h4 id="step-by-step-scenario"><strong>Step-by-Step Scenario</strong></h4> <ol> <li><strong>Initial Queue State</strong> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Head ‚Üí A (tail) ‚Üí nullptr
</code></pre></div> </div> <ul> <li><code class="language-plaintext highlighter-rouge">tail</code> points to <strong>A</strong>.</li> <li><code class="language-plaintext highlighter-rouge">A-&gt;next</code> is <code class="language-plaintext highlighter-rouge">nullptr</code>.</li> </ul> </li> <li><strong>Thread T1 begins enqueue(B)</strong> <ul> <li>It <strong>gets <code class="language-plaintext highlighter-rouge">oldTail = A</code></strong>.</li> <li>It <strong>gets <code class="language-plaintext highlighter-rouge">next = nullptr</code></strong>, so it proceeds to insert <code class="language-plaintext highlighter-rouge">B</code>.</li> </ul> </li> <li><strong>Thread T1 is paused (context switch).</strong> <ul> <li><code class="language-plaintext highlighter-rouge">oldTail-&gt;next.compare_exchange_weak(next, newNode)</code> is <strong>not executed yet</strong>.</li> <li>Queue state is unchanged.</li> </ul> </li> <li><strong>Thread T2 starts enqueue(C)</strong> <ul> <li>It also <strong>gets <code class="language-plaintext highlighter-rouge">oldTail = A</code></strong>.</li> <li><strong>Another Thread T3 already completed enqueue(B)</strong>, so now: <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Head ‚Üí A ‚Üí B (tail) ‚Üí nullptr
</code></pre></div> </div> </li> <li>Now, <code class="language-plaintext highlighter-rouge">A-&gt;next</code> is <code class="language-plaintext highlighter-rouge">B</code>, but <code class="language-plaintext highlighter-rouge">tail</code> is <strong>still pointing to A</strong>.</li> </ul> </li> <li><strong>Thread T2 sees that <code class="language-plaintext highlighter-rouge">next != nullptr</code> (<code class="language-plaintext highlighter-rouge">next = B</code>)</strong> <ul> <li>It executes: <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">tail</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">oldTail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
</code></pre></div> </div> <ul> <li><code class="language-plaintext highlighter-rouge">tail</code> is updated from <strong>A to B</strong>.</li> </ul> </li> </ul> </li> <li><strong>Thread T2 retries the enqueue with <code class="language-plaintext highlighter-rouge">tail = B</code></strong>, allowing proper insertion of <code class="language-plaintext highlighter-rouge">C</code> after <code class="language-plaintext highlighter-rouge">B</code>.</li> </ol> <hr/> <h3 id="what-happens-if-this-block-is-removed"><strong>What Happens If This Block Is Removed?</strong></h3> <ul> <li>If <code class="language-plaintext highlighter-rouge">tail.compare_exchange_weak(oldTail, next);</code> is <strong>not</strong> performed, <code class="language-plaintext highlighter-rouge">tail</code> would continue pointing to <strong>A</strong>, even though <code class="language-plaintext highlighter-rouge">A-&gt;next = B</code> exists.</li> <li>This means <strong>new enqueue attempts might repeatedly try inserting after A instead of after B</strong>.</li> <li>In extreme cases, this can lead to a <strong>stalled queue</strong> where elements are not appended correctly.</li> </ul> <hr/> <h3 id="conclusion"><strong>Conclusion</strong></h3> <p>The block:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">next</span><span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">tail</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">oldTail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
    <span class="k">continue</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>is necessary to ensure that <code class="language-plaintext highlighter-rouge">tail</code> <strong>keeps up with the actual last node</strong>, preventing it from getting stuck in an outdated position, especially in a concurrent environment.</p> <p>Would you like me to clarify anything further? üöÄ</p> <p>My problematic implementation:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyLockFreeQueue</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">MyLockFreeQueue</span><span class="p">()</span>  <span class="p">{</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SimpleNode</span><span class="p">();</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="n">head_</span> <span class="o">=</span> <span class="n">tail_</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>

  <span class="p">}</span>

  <span class="kt">void</span> <span class="nf">enque</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">SimpleNode</span><span class="o">&gt;</span> <span class="n">node</span><span class="p">(</span><span class="k">new</span> <span class="n">SimpleNode</span><span class="p">());</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">old_tail</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">next</span>  <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>  
    <span class="k">do</span> <span class="p">{</span>
      <span class="n">old_tail</span> <span class="o">=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
      <span class="n">next</span> <span class="o">=</span> <span class="n">old_tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
      <span class="k">if</span><span class="p">(</span><span class="n">old_tail</span> <span class="o">!=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">continue</span><span class="p">;</span>
      
      <span class="p">}</span>

      <span class="k">if</span><span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>

    <span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="n">old_tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="o">==</span> <span class="nb">false</span><span class="p">);</span>
    <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">release</span><span class="p">());</span>
  <span class="p">}</span>

  <span class="kt">bool</span> <span class="nf">deque</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">old_head</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">old_tail</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">next</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="k">do</span> <span class="p">{</span>
      <span class="n">old_head</span> <span class="o">=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
      <span class="n">old_tail</span> <span class="o">=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>

      <span class="c1">// assert(old_head != nullptr);</span>
      <span class="c1">// This line of code is bug</span>
      <span class="n">next</span> <span class="o">=</span> <span class="n">old_head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
      <span class="k">if</span><span class="p">(</span><span class="n">old_head</span> <span class="o">!=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span><span class="p">(</span><span class="n">old_head</span> <span class="o">==</span> <span class="n">old_tail</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">next</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">val</span> <span class="o">=</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="n">head_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_head</span><span class="p">,</span> <span class="n">next</span><span class="p">)</span> <span class="o">==</span> <span class="nb">false</span><span class="p">);</span>
    <span class="k">delete</span> <span class="n">old_head</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>


  <span class="kt">bool</span> <span class="nf">empty</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">()</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">;</span>
  <span class="p">}</span>


  <span class="k">private</span><span class="o">:</span>
  <span class="c1">// size</span>
  <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">size_</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">SimpleNode</span><span class="o">*&gt;</span> <span class="n">head_</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">SimpleNode</span><span class="o">*&gt;</span> <span class="n">tail_</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div> <p>The problem is at deque part. enque has bug in it.</p> <p>Fixed code given by gpt Your <code class="language-plaintext highlighter-rouge">enque()</code> function has <strong>several serious bugs</strong> related to <strong>memory management, atomic operations, and ABA problems</strong>. Let‚Äôs analyze and fix them.</p> <hr/> <h2 id="-identified-bugs"><strong>üîç Identified Bugs</strong></h2> <h3 id="1-memory-leak-due-to-stdunique_ptrrelease"><strong>1. Memory Leak Due to <code class="language-plaintext highlighter-rouge">std::unique_ptr::release()</code></strong></h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">SimpleNode</span><span class="o">&gt;</span> <span class="n">node</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">SimpleNode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
</code></pre></div></div> <ul> <li><code class="language-plaintext highlighter-rouge">node.release()</code> transfers ownership but <strong>does not delete the old pointer</strong> if the enqueue operation fails.</li> <li>If <code class="language-plaintext highlighter-rouge">compare_exchange_weak()</code> fails, the <code class="language-plaintext highlighter-rouge">SimpleNode</code> is <strong>lost</strong> ‚Üí <strong>memory leak</strong>.</li> </ul> <p>‚úÖ <strong>Fix:</strong> Use <code class="language-plaintext highlighter-rouge">std::shared_ptr</code> or manually manage deletion.</p> <hr/> <h3 id="2-aba-problem-in-tail_compare_exchange_weak"><strong>2. ABA Problem in <code class="language-plaintext highlighter-rouge">tail_.compare_exchange_weak()</code></strong></h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
    <span class="k">continue</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <ul> <li>If another thread modifies <code class="language-plaintext highlighter-rouge">tail_</code> between these operations, it <strong>could still hold the same value</strong>, leading to a <strong>stale pointer reference</strong>.</li> <li>This introduces <strong>undefined behavior</strong>.</li> </ul> <p>‚úÖ <strong>Fix:</strong> Use a <strong>hazard pointer</strong> (complex) or ensure <code class="language-plaintext highlighter-rouge">next</code> is updated <strong>before</strong> modifying <code class="language-plaintext highlighter-rouge">tail_</code>.</p> <hr/> <h3 id="3-incorrect-order-of-compare_exchange_weak"><strong>3. Incorrect Order of <code class="language-plaintext highlighter-rouge">compare_exchange_weak()</code></strong></h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span><span class="p">(</span><span class="n">old_tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="o">==</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div></div> <ul> <li>This assumes <code class="language-plaintext highlighter-rouge">next</code> remains the same between checks, but <strong>other threads could modify it</strong>.</li> <li>This can lead to an <strong>infinite loop or inconsistent state</strong>.</li> </ul> <p>‚úÖ <strong>Fix:</strong> Re-load <code class="language-plaintext highlighter-rouge">next</code> before retrying.</p> <hr/> <h3 id="4-potential-infinite-loop-if-tail_-changes-midway"><strong>4. Potential Infinite Loop if <code class="language-plaintext highlighter-rouge">tail_</code> Changes Midway</strong></h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="n">old_tail</span> <span class="o">!=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">continue</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <ul> <li>This check is <strong>not enough</strong> to prevent starvation, as <code class="language-plaintext highlighter-rouge">tail_</code> may change <strong>again</strong> before re-entering the loop.</li> </ul> <p>‚úÖ <strong>Fix:</strong> Ensure a strong atomic operation.</p> <hr/> <h2 id="-fixed-code"><strong>‚úÖ Fixed Code</strong></h2> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">enque</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Allocate the new node</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">SimpleNode</span><span class="o">&gt;</span> <span class="n">node</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">SimpleNode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>

    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">old_tail</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">next</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">old_tail</span> <span class="o">=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
        <span class="n">next</span> <span class="o">=</span> <span class="n">old_tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">old_tail</span> <span class="o">!=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span> <span class="c1">// Retry if tail changed</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Help advance tail if it's stale</span>
            <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// Try to attach the new node</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">old_tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">get</span><span class="p">()))</span> <span class="p">{</span>
            <span class="c1">// Successfully linked, now update tail_</span>
            <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">release</span><span class="p">());</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <hr/> <h2 id="-summary-of-fixes"><strong>üîë Summary of Fixes</strong></h2> <p>| <strong>Bug</strong> | <strong>Issue</strong> | <strong>Fix</strong> | |‚Äî‚Äî‚Äî|‚Äî‚Äî‚Äî-|‚Äî‚Äî‚Äî| | <strong>Memory Leak</strong> | <code class="language-plaintext highlighter-rouge">node.release()</code> without cleanup | Use <code class="language-plaintext highlighter-rouge">std::unique_ptr</code> safely | | <strong>ABA Problem</strong> | <code class="language-plaintext highlighter-rouge">tail_.compare_exchange_weak()</code> fails if another thread modifies <code class="language-plaintext highlighter-rouge">tail_</code> | Ensure <code class="language-plaintext highlighter-rouge">next</code> is updated before modifying <code class="language-plaintext highlighter-rouge">tail_</code> | | <strong>Order of Operations</strong> | <code class="language-plaintext highlighter-rouge">compare_exchange_weak()</code> on <code class="language-plaintext highlighter-rouge">next</code> may lead to an <strong>infinite loop</strong> | Always reload <code class="language-plaintext highlighter-rouge">next</code> before retrying | | <strong>Stale <code class="language-plaintext highlighter-rouge">tail_</code> Pointer</strong> | <code class="language-plaintext highlighter-rouge">if (old_tail != tail_.load())</code> check is <strong>not strong enough</strong> | Use proper atomic operations |</p> <p>This new implementation <strong>ensures correctness, prevents memory leaks, and avoids infinite loops</strong>. üöÄ</p> <h3 id="what-is-aba-problem-">What is ABA problem ?</h3> <p>The <strong>ABA problem</strong> in software engineering is a well-known issue in <strong>concurrent programming</strong>, particularly in <strong>lock-free data structures</strong> that rely on <strong>compare-and-swap (CAS) operations</strong>.</p> <h3 id="understanding-the-aba-problem"><strong>Understanding the ABA Problem</strong></h3> <ol> <li><strong>CAS (Compare-And-Swap) Basics</strong> <ul> <li>CAS is an atomic operation used in multi-threading to update a variable only if its value hasn‚Äôt changed since the last check.</li> <li>Example: <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">atomic_value</span> <span class="o">==</span> <span class="n">expected_value</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">atomic_value</span> <span class="o">=</span> <span class="n">new_value</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> </div> </li> <li>It ensures that updates happen only when no other thread has modified the value.</li> </ul> </li> <li><strong>The Problem</strong> <ul> <li>If one thread (Thread 1) reads a value (e.g., <strong>A</strong>) from a shared variable, another thread (Thread 2) might change it to <strong>B</strong> and then back to <strong>A</strong> before Thread 1 proceeds.</li> <li>CAS sees <strong>A</strong> as unchanged and allows Thread 1 to proceed, even though the value was modified in between.</li> <li>This can lead to <strong>unexpected behavior</strong> and <strong>data inconsistencies</strong>.</li> </ul> </li> </ol> <h3 id="example-of-the-aba-problem"><strong>Example of the ABA Problem</strong></h3> <h4 id="scenario"><strong>Scenario</strong></h4> <ol> <li><strong>Thread 1</strong> reads a value <strong>A</strong> from memory.</li> <li><strong>Thread 2</strong> changes <strong>A ‚Üí B ‚Üí A</strong> (some operation happens in between).</li> <li><strong>Thread 1</strong> now uses CAS to update <strong>A ‚Üí C</strong>, thinking nothing changed.</li> <li>CAS succeeds because the value is still <strong>A</strong>, but the actual data has been modified!</li> </ol> <h4 id="why-is-this-dangerous"><strong>Why is this Dangerous?</strong></h4> <ul> <li>If a data structure (like a linked list) relies on CAS for safe updates, the ABA problem may lead to <strong>memory corruption</strong>, <strong>lost updates</strong>, or <strong>dangling pointers</strong>.</li> </ul> <h3 id="solutions-to-the-aba-problem"><strong>Solutions to the ABA Problem</strong></h3> <ol> <li><strong>Tagged Pointers (Version Numbers)</strong> <ul> <li>Instead of just storing <strong>A</strong>, store a <strong>version number</strong> along with the value (e.g., <code class="language-plaintext highlighter-rouge">A1</code>, <code class="language-plaintext highlighter-rouge">B2</code>, <code class="language-plaintext highlighter-rouge">A3</code>).</li> <li>When CAS checks, it verifies both the <strong>value</strong> and the <strong>version</strong>.</li> <li>Example: <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">AtomicValue</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">version</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div> </div> </li> <li>Even if the value is back to <strong>A</strong>, the version number ensures CAS detects the change.</li> </ul> </li> <li><strong>Hazard Pointers</strong> <ul> <li>Used in <strong>memory reclamation</strong> to track objects that are still being accessed by threads, preventing premature deletion.</li> </ul> </li> <li><strong>Read-Copy-Update (RCU)</strong> <ul> <li>Instead of modifying shared data directly, RCU allows <strong>readers to access old versions</strong> while writers update a new copy.</li> </ul> </li> <li><strong>Double Compare-And-Swap (Double CAS or DCAS)</strong> <ul> <li>Some architectures support <strong>checking two variables at once</strong> (e.g., the value + a version counter).</li> </ul> </li> </ol> <h3 id="where-is-the-aba-problem-common"><strong>Where is the ABA Problem Common?</strong></h3> <ul> <li><strong>Lock-free stacks, queues, and linked lists</strong></li> <li><strong>Garbage collection mechanisms</strong></li> <li><strong>Reference counting</strong></li> <li><strong>Memory allocators</strong></li> </ul> <h2 id="why-continue-is-necessary-in-the-second-if-statement-">Why continue is necessary in the second if statement ?</h2> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">void</span> <span class="nf">enque</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">SimpleNode</span><span class="o">&gt;</span> <span class="n">node</span><span class="p">(</span><span class="k">new</span> <span class="n">SimpleNode</span><span class="p">());</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">old_tail</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">next</span>  <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>  
    <span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">old_tail</span> <span class="o">=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
      <span class="n">next</span> <span class="o">=</span> <span class="n">old_tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
      <span class="k">if</span><span class="p">(</span><span class="n">old_tail</span> <span class="o">!=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">continue</span><span class="p">;</span>
      
      <span class="p">}</span>
      <span class="k">if</span><span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="k">if</span><span class="p">(</span><span class="n">old_tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">get</span><span class="p">()))</span> <span class="p">{</span>

      <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">release</span><span class="p">());</span>
        <span class="k">return</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span> 
  <span class="p">}</span>
</code></pre></div></div> <p>The <strong><code class="language-plaintext highlighter-rouge">continue</code></strong> statement in the second <code class="language-plaintext highlighter-rouge">if</code> condition is necessary to ensure that the <code class="language-plaintext highlighter-rouge">while(true)</code> loop properly retries the enqueue operation when the <code class="language-plaintext highlighter-rouge">tail_</code> pointer is updated asynchronously by another thread.</p> <h3 id="breaking-down-the-code"><strong>Breaking Down the Code</strong></h3> <p>This function implements a <strong>lock-free queue enqueue operation</strong> using <strong>atomic operations</strong> (<code class="language-plaintext highlighter-rouge">compare_exchange_weak</code>) to avoid locks.</p> <h4 id="key-elements-in-the-code"><strong>Key Elements in the Code:</strong></h4> <ul> <li><code class="language-plaintext highlighter-rouge">tail_</code>: A <strong>lock-free atomic pointer</strong> to the last node in the queue.</li> <li><code class="language-plaintext highlighter-rouge">next</code>: The next node after <code class="language-plaintext highlighter-rouge">old_tail</code>, used to check if <code class="language-plaintext highlighter-rouge">tail_</code> is up-to-date.</li> <li><code class="language-plaintext highlighter-rouge">compare_exchange_weak</code>: Used for <strong>atomic updates</strong>, but it may fail if another thread modifies the value simultaneously.</li> </ul> <h3 id="understanding-the-aba-problem-and-the-need-for-continue"><strong>Understanding the ABA Problem and the Need for <code class="language-plaintext highlighter-rouge">continue</code></strong></h3> <ol> <li><strong>First <code class="language-plaintext highlighter-rouge">if</code>: Detects Stale <code class="language-plaintext highlighter-rouge">tail_</code></strong> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="n">old_tail</span> <span class="o">!=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">continue</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> </div> <ul> <li>This check ensures that <code class="language-plaintext highlighter-rouge">old_tail</code> is still the actual tail.</li> <li>If another thread updates <code class="language-plaintext highlighter-rouge">tail_</code> during execution, the loop <strong>retries</strong> to reload the new tail.</li> </ul> </li> <li><strong>Second <code class="language-plaintext highlighter-rouge">if</code>: If <code class="language-plaintext highlighter-rouge">next != nullptr</code>, Another Thread is Advancing <code class="language-plaintext highlighter-rouge">tail_</code></strong> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
    <span class="k">continue</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> </div> <ul> <li>This means <strong>another thread is in the middle of an enqueue operation</strong> but hasn‚Äôt yet updated <code class="language-plaintext highlighter-rouge">tail_</code> completely.</li> <li>The queue is <strong>inconsistent</strong> at this point: <ul> <li><code class="language-plaintext highlighter-rouge">old_tail-&gt;next</code> points to <code class="language-plaintext highlighter-rouge">next</code>, but <code class="language-plaintext highlighter-rouge">tail_</code> still points to <code class="language-plaintext highlighter-rouge">old_tail</code>.</li> <li>Our thread helps move <code class="language-plaintext highlighter-rouge">tail_</code> forward to <code class="language-plaintext highlighter-rouge">next</code> before retrying.</li> </ul> </li> <li>The <code class="language-plaintext highlighter-rouge">continue</code> ensures that we <strong>restart</strong> the loop with a fresh state.</li> </ul> </li> <li><strong>Final Atomic Insert Attempt</strong> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="n">old_tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">get</span><span class="p">()))</span> <span class="p">{</span>
    <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">release</span><span class="p">());</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> </div> <ul> <li>If <code class="language-plaintext highlighter-rouge">next</code> is <code class="language-plaintext highlighter-rouge">nullptr</code>, we attempt to attach the new node.</li> <li>If successful, we update <code class="language-plaintext highlighter-rouge">tail_</code>.</li> </ul> </li> </ol> <h3 id="why-is-continue-necessary"><strong>Why is <code class="language-plaintext highlighter-rouge">continue</code> Necessary?</strong></h3> <p>Without <code class="language-plaintext highlighter-rouge">continue</code>, after <code class="language-plaintext highlighter-rouge">tail_.compare_exchange_weak(old_tail, next)</code>, the function would <strong>proceed</strong> without restarting the loop. This could result in:</p> <ul> <li><strong>Using stale values</strong> of <code class="language-plaintext highlighter-rouge">old_tail</code> and <code class="language-plaintext highlighter-rouge">next</code>, potentially leading to incorrect behavior.</li> <li><strong>A missed enqueue operation</strong>, as we wouldn‚Äôt retry with the new tail node. Which means that the <code class="language-plaintext highlighter-rouge">tail_</code> is not moved forward.</li> </ul> <h3 id="summary"><strong>Summary</strong></h3> <p>The <code class="language-plaintext highlighter-rouge">continue</code> ensures that if <code class="language-plaintext highlighter-rouge">tail_</code> was not pointing to the correct node (due to concurrent updates), the loop <strong>retries from the beginning</strong> with updated values. This is critical for maintaining the correctness of the <strong>lock-free queue</strong> and avoiding race conditions.</p> <h2 id="correct-vs-incorrect-deque">Correct vs. incorrect deque</h2> <p>Correct:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">deque</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">result</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">oldHead</span><span class="p">;</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
    
    <span class="k">do</span> <span class="p">{</span>
        <span class="n">oldHead</span> <span class="o">=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
        <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">oldTail</span> <span class="o">=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
        <span class="n">next</span> <span class="o">=</span> <span class="n">oldHead</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">oldHead</span> <span class="o">!=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span> <span class="c1">// Restart loop if head changed</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">oldHead</span> <span class="o">==</span> <span class="n">oldTail</span><span class="p">)</span> <span class="p">{</span> 
            <span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// Queue is empty</span>
            <span class="p">}</span>
            <span class="c1">// Help advance the tail if it's stuck (optional optimization)</span>
            <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">oldTail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
        <span class="p">}</span>
        
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">head_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">oldHead</span><span class="p">,</span> <span class="n">next</span><span class="p">));</span>

    <span class="c1">// Ensure next is valid before accessing it</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="k">delete</span> <span class="n">oldHead</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// Failsafe check, should not be reached</span>
<span class="p">}</span>
</code></pre></div></div> <p>Incorrect:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">bool</span> <span class="nf">deque</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">old_head</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">old_tail</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">next</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="k">do</span> <span class="p">{</span>
      <span class="n">old_head</span> <span class="o">=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
      <span class="n">old_tail</span> <span class="o">=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
      <span class="n">assert</span><span class="p">(</span><span class="n">old_head</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">);</span>
      <span class="n">next</span> <span class="o">=</span> <span class="n">old_head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
      <span class="k">if</span><span class="p">(</span><span class="n">old_head</span> <span class="o">!=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span><span class="p">(</span><span class="n">old_head</span> <span class="o">==</span> <span class="n">old_tail</span> <span class="o">&amp;&amp;</span> <span class="n">next</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="n">head_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_head</span><span class="p">,</span> <span class="n">next</span><span class="p">)</span> <span class="o">==</span> <span class="nb">false</span><span class="p">);</span>

    <span class="n">val</span> <span class="o">=</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">old_head</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div></div> <p>Explanation from gpt. Basically it means that we need to whether next is nullptr or not. Your <code class="language-plaintext highlighter-rouge">deque</code> function has a <strong>bug that can cause a segmentation fault (crash)</strong> due to <strong>dereferencing a null pointer (<code class="language-plaintext highlighter-rouge">next</code>)</strong> when the queue is empty. Here‚Äôs what happens:</p> <h3 id="identified-bugs"><strong>Identified Bugs:</strong></h3> <ol> <li><strong>Null Dereference of <code class="language-plaintext highlighter-rouge">next</code></strong> <ul> <li>When <code class="language-plaintext highlighter-rouge">oldHead == oldTail</code> and <code class="language-plaintext highlighter-rouge">next == nullptr</code>, the queue is empty.</li> <li>However, the loop continues, and <code class="language-plaintext highlighter-rouge">next</code> (which is <code class="language-plaintext highlighter-rouge">nullptr</code>) is used in <code class="language-plaintext highlighter-rouge">head_.compare_exchange_weak(oldHead, next)</code>, leading to <strong>undefined behavior</strong>.</li> <li>Also, <code class="language-plaintext highlighter-rouge">result = std::move(next-&gt;val);</code> will crash if <code class="language-plaintext highlighter-rouge">next</code> is <code class="language-plaintext highlighter-rouge">nullptr</code>.</li> </ul> </li> </ol> <h3 id="fixed-code"><strong>Fixed Code</strong></h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">deque</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">result</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">oldHead</span><span class="p">;</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
    
    <span class="k">do</span> <span class="p">{</span>
        <span class="n">oldHead</span> <span class="o">=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
        <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">oldTail</span> <span class="o">=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
        <span class="n">next</span> <span class="o">=</span> <span class="n">oldHead</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">oldHead</span> <span class="o">!=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span> <span class="c1">// Restart loop if head changed</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">oldHead</span> <span class="o">==</span> <span class="n">oldTail</span><span class="p">)</span> <span class="p">{</span> 
            <span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// Queue is empty</span>
            <span class="p">}</span>
            <span class="c1">// Help advance the tail if it's stuck (optional optimization)</span>
            <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">oldTail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
        <span class="p">}</span>
        
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">head_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">oldHead</span><span class="p">,</span> <span class="n">next</span><span class="p">));</span>

    <span class="c1">// Ensure next is valid before accessing it</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="k">delete</span> <span class="n">oldHead</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// Failsafe check, should not be reached</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="fixes--improvements"><strong>Fixes &amp; Improvements</strong></h3> <ol> <li><strong>Ensured <code class="language-plaintext highlighter-rouge">next</code> is not null before accessing it</strong> <ul> <li>We only proceed if <code class="language-plaintext highlighter-rouge">next</code> is valid.</li> </ul> </li> <li><strong>Added a tail advancement step</strong> <em>(optional but improves performance)</em> <ul> <li>If <code class="language-plaintext highlighter-rouge">tail_</code> is outdated (<code class="language-plaintext highlighter-rouge">oldTail == oldHead &amp;&amp; next != nullptr</code>), update it to avoid slow tail progression.</li> </ul> </li> <li><strong>Handled the empty queue case properly</strong> <ul> <li>Now correctly returns <code class="language-plaintext highlighter-rouge">false</code> when the queue is empty without further processing.</li> </ul> </li> </ol> <p>This prevents <strong>segmentation faults</strong>, ensures correct behavior, and slightly optimizes the tail update. üöÄ</p> <h2 id="the-difference-between-two-enque-implementation">The difference between two enque implementation</h2> <p>First one, correct</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">void</span> <span class="nf">enque</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">SimpleNode</span><span class="o">&gt;</span> <span class="n">node</span><span class="p">(</span><span class="k">new</span> <span class="n">SimpleNode</span><span class="p">());</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">old_tail</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">next</span>  <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>  
    <span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">old_tail</span> <span class="o">=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
      <span class="n">next</span> <span class="o">=</span> <span class="n">old_tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
      <span class="k">if</span><span class="p">(</span><span class="n">old_tail</span> <span class="o">!=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">continue</span><span class="p">;</span>
      
      <span class="p">}</span>
      <span class="k">if</span><span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="k">if</span><span class="p">(</span><span class="n">old_tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">get</span><span class="p">()))</span> <span class="p">{</span>

      <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">release</span><span class="p">());</span>
        <span class="k">return</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span> 
  <span class="p">}</span>
</code></pre></div></div> <p>Second one, incorrect</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">void</span> <span class="nf">enque</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SimpleNode</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
        <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">old_tail</span><span class="p">;</span>
        <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>

        <span class="k">do</span> <span class="p">{</span>
            <span class="n">old_tail</span> <span class="o">=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
            <span class="n">next</span> <span class="o">=</span> <span class="n">old_tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">old_tail</span> <span class="o">!=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">())</span> <span class="p">{</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">old_tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">node</span><span class="p">));</span>

        <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
        <span class="n">size_</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div></div> <h3 id="key-difference-when-tail_-is-updated"><strong>Key Difference: When <code class="language-plaintext highlighter-rouge">tail_</code> is Updated</strong></h3> <p>You‚Äôre correct that <strong>both implementations update <code class="language-plaintext highlighter-rouge">tail_</code> only once when successfully adding a node</strong>. However, <strong>the crucial difference is what happens when <code class="language-plaintext highlighter-rouge">next != nullptr</code></strong> (i.e., when another thread is already modifying the queue).</p> <h3 id="first-implementation-correct"><strong>First Implementation (Correct)</strong></h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
    <span class="k">continue</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>üîπ <strong>If another thread is already enqueueing a node (<code class="language-plaintext highlighter-rouge">next != nullptr</code>), we help move <code class="language-plaintext highlighter-rouge">tail_</code> forward before retrying.</strong><br/> üîπ This prevents <code class="language-plaintext highlighter-rouge">tail_</code> from becoming stale and ensures it always points to the latest node.</p> <h3 id="second-implementation-incorrect"><strong>Second Implementation (Incorrect)</strong></h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
    <span class="k">continue</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>üîπ <strong>This part is identical</strong>, but <strong>the retry loop does not guarantee that <code class="language-plaintext highlighter-rouge">tail_</code> is updated correctly at the end</strong>.<br/> üîπ Since <code class="language-plaintext highlighter-rouge">tail_.compare_exchange_weak(old_tail, node);</code> is <strong>only executed once, outside the loop</strong>, it might miss updates when multiple threads are enqueueing.</p> <hr/> <h2 id="example-the-core-issue-in-the-second-implementation"><strong>Example: The Core Issue in the Second Implementation</strong></h2> <p>Let‚Äôs break it down step by step <strong>with two threads (<code class="language-plaintext highlighter-rouge">Thread 1</code> and <code class="language-plaintext highlighter-rouge">Thread 2</code>) enqueuing at the same time</strong>.</p> <h3 id="initial-queue-state"><strong>Initial Queue State</strong></h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HEAD -&gt; Node(A) -&gt; (TAIL)
</code></pre></div></div> <p>Both <code class="language-plaintext highlighter-rouge">head_</code> and <code class="language-plaintext highlighter-rouge">tail_</code> point to <code class="language-plaintext highlighter-rouge">Node(A)</code>.<br/> Now, <strong>Thread 1 enqueues <code class="language-plaintext highlighter-rouge">Node(B)</code>, and Thread 2 enqueues <code class="language-plaintext highlighter-rouge">Node(C)</code>.</strong></p> <hr/> <h3 id="step-1-both-threads-read-tail_"><strong>Step 1: Both Threads Read <code class="language-plaintext highlighter-rouge">tail_</code></strong></h3> <ul> <li><strong>Thread 1</strong> reads <code class="language-plaintext highlighter-rouge">tail_ = Node(A)</code>, sees <code class="language-plaintext highlighter-rouge">next = nullptr</code>, and creates <code class="language-plaintext highlighter-rouge">Node(B)</code>.</li> <li><strong>Thread 2</strong> reads <code class="language-plaintext highlighter-rouge">tail_ = Node(A)</code>, sees <code class="language-plaintext highlighter-rouge">next = nullptr</code>, and creates <code class="language-plaintext highlighter-rouge">Node(C)</code>.</li> </ul> <hr/> <h3 id="step-2-thread-1-successfully-adds-nodeb"><strong>Step 2: Thread 1 Successfully Adds <code class="language-plaintext highlighter-rouge">Node(B)</code></strong></h3> <ul> <li><strong>Thread 1 succeeds</strong> in: <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">old_tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">node_B</span><span class="p">);</span>
</code></pre></div> </div> <ul> <li>Now, the queue looks like: <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HEAD -&gt; Node(A) -&gt; Node(B)
</code></pre></div> </div> </li> </ul> </li> <li><strong>Thread 2 retries because <code class="language-plaintext highlighter-rouge">next</code> is no longer <code class="language-plaintext highlighter-rouge">nullptr</code>!</strong></li> </ul> <hr/> <h3 id="step-3-thread-1-updates-tail_"><strong>Step 3: Thread 1 Updates <code class="language-plaintext highlighter-rouge">tail_</code></strong></h3> <ul> <li><strong>Thread 1 successfully updates <code class="language-plaintext highlighter-rouge">tail_</code> to point to <code class="language-plaintext highlighter-rouge">Node(B)</code>.</strong> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HEAD -&gt; Node(A) -&gt; Node(B) -&gt; (TAIL)
</code></pre></div> </div> </li> </ul> <hr/> <h3 id="step-4-thread-2-retries"><strong>Step 4: Thread 2 Retries</strong></h3> <ul> <li><strong>Thread 2 now reads <code class="language-plaintext highlighter-rouge">tail_ = Node(B)</code>, next = <code class="language-plaintext highlighter-rouge">nullptr</code>, and successfully adds <code class="language-plaintext highlighter-rouge">Node(C)</code>.</strong> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HEAD -&gt; Node(A) -&gt; Node(B) -&gt; Node(C)
</code></pre></div> </div> </li> <li><strong>But here‚Äôs the bug in the second implementation:</strong> <ul> <li><code class="language-plaintext highlighter-rouge">tail_</code> is updated <strong>only once, outside the loop</strong>.</li> <li>If another thread starts enqueueing at the same time, <code class="language-plaintext highlighter-rouge">tail_</code> <strong>might still point to <code class="language-plaintext highlighter-rouge">Node(B)</code> instead of <code class="language-plaintext highlighter-rouge">Node(C)</code>!</strong></li> <li><strong>Future enqueue operations might have to retry unnecessarily because <code class="language-plaintext highlighter-rouge">tail_</code> is stale.</strong></li> </ul> </li> </ul> <hr/> <h3 id="step-5-the-problem-stale-tail_"><strong>Step 5: The Problem (Stale <code class="language-plaintext highlighter-rouge">tail_</code>)</strong></h3> <ul> <li>If a new thread tries to enqueue <code class="language-plaintext highlighter-rouge">Node(D)</code>, it <strong>may still see <code class="language-plaintext highlighter-rouge">tail_ = Node(B)</code>, instead of <code class="language-plaintext highlighter-rouge">Node(C)</code>.</strong></li> <li>This forces unnecessary retries, slowing down the queue.</li> </ul> <hr/> <h2 id="why-the-first-implementation-avoids-this"><strong>Why the First Implementation Avoids This</strong></h2> <p>In the <strong>first implementation</strong>, if another thread is already in the middle of an enqueue (i.e., <code class="language-plaintext highlighter-rouge">next != nullptr</code>), it <strong>helps move <code class="language-plaintext highlighter-rouge">tail_</code> forward before retrying.</strong></p> <h3 id="why-this-matters"><strong>Why This Matters</strong></h3> <p>Imagine <code class="language-plaintext highlighter-rouge">Thread 1</code> enqueues <code class="language-plaintext highlighter-rouge">Node(B)</code>, and <code class="language-plaintext highlighter-rouge">Thread 2</code> enqueues <code class="language-plaintext highlighter-rouge">Node(C)</code>.</p> <ul> <li><strong>In the first implementation, <code class="language-plaintext highlighter-rouge">Thread 2</code> would help move <code class="language-plaintext highlighter-rouge">tail_</code> to <code class="language-plaintext highlighter-rouge">Node(B)</code> before proceeding.</strong></li> <li><strong>This guarantees that when it enqueues <code class="language-plaintext highlighter-rouge">Node(C)</code>, <code class="language-plaintext highlighter-rouge">tail_</code> will be updated correctly.</strong></li> </ul> <p>By continuously ensuring that <code class="language-plaintext highlighter-rouge">tail_</code> is moved forward <strong>before retrying</strong>, the first implementation guarantees that <code class="language-plaintext highlighter-rouge">tail_</code> <strong>always</strong> points to the most recently enqueued node.</p> <hr/> <h2 id="summary-of-the-core-difference"><strong>Summary of the Core Difference</strong></h2> <p>| Feature | <strong>First Implementation (Correct)</strong> | <strong>Second Implementation (Incorrect)</strong> | |‚Äî‚Äî‚Äî|‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî-|‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî-| | <strong>What happens when <code class="language-plaintext highlighter-rouge">next != nullptr</code>?</strong> | Moves <code class="language-plaintext highlighter-rouge">tail_</code> forward before retrying. | Just retries without ensuring <code class="language-plaintext highlighter-rouge">tail_</code> is updated correctly. | | <strong>Ensures <code class="language-plaintext highlighter-rouge">tail_</code> always points to the latest node?</strong> | ‚úÖ Yes | ‚ùå No, <code class="language-plaintext highlighter-rouge">tail_</code> might point to an old node. | | <strong>Potential issue?</strong> | No inefficiencies, always correct. | <code class="language-plaintext highlighter-rouge">tail_</code> can become stale, causing unnecessary retries. | | <strong>Performance impact</strong> | More efficient, fewer retries. | Less efficient, more retries needed. |</p> <hr/> <h3 id="final-takeaway"><strong>Final Takeaway</strong></h3> <p><strong>The key reason the first implementation is correct is that it ensures <code class="language-plaintext highlighter-rouge">tail_</code> is always moved forward before retrying.</strong><br/> Without this, the second implementation <strong>allows <code class="language-plaintext highlighter-rouge">tail_</code> to become stale</strong>, which slows down the queue by forcing unnecessary retries.</p> <hr/> <p>I still don‚Äôt get it. Why the second implementation is incorrect ?</p> <p>You‚Äôre absolutely right that <strong>other threads can help move <code class="language-plaintext highlighter-rouge">tail_</code> forward</strong>‚Äîthis is the whole idea behind a lock-free queue! However, the second implementation <strong>still has a correctness issue</strong> because it does not ensure that <code class="language-plaintext highlighter-rouge">tail_</code> is updated reliably <strong>before finishing the enqueue operation</strong>.</p> <p>Let‚Äôs clarify <strong>why this is a problem even though other threads can help move <code class="language-plaintext highlighter-rouge">tail_</code> forward.</strong></p> <hr/> <h2 id="key-question"><strong>Key Question</strong></h2> <p>Since other threads can update <code class="language-plaintext highlighter-rouge">tail_</code>, why is the second implementation still incorrect?</p> <h3 id="answer"><strong>Answer:</strong></h3> <p>Even though other threads <strong>may</strong> update <code class="language-plaintext highlighter-rouge">tail_</code>, the second implementation <strong>relies on them to fix the issue rather than guaranteeing correctness itself.</strong><br/> This creates a <strong>non-deterministic behavior</strong> where <code class="language-plaintext highlighter-rouge">tail_</code> <strong>might or might not</strong> point to the latest node, depending on thread timing.</p> <hr/> <h2 id="breaking-it-down-step-by-step"><strong>Breaking It Down Step by Step</strong></h2> <p>Let‚Äôs assume <strong>three threads (<code class="language-plaintext highlighter-rouge">T1</code>, <code class="language-plaintext highlighter-rouge">T2</code>, and <code class="language-plaintext highlighter-rouge">T3</code>) are enqueuing at the same time</strong> to see where the second implementation fails.</p> <h3 id="initial-state"><strong>Initial State</strong></h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HEAD -&gt; Node(A) (tail_)
</code></pre></div></div> <ul> <li><code class="language-plaintext highlighter-rouge">head_</code> and <code class="language-plaintext highlighter-rouge">tail_</code> both point to <code class="language-plaintext highlighter-rouge">Node(A)</code>.</li> <li>Now three threads start enqueueing.</li> </ul> <hr/> <h3 id="step-1-t1-successfully-enqueues-nodeb"><strong>Step 1: T1 Successfully Enqueues <code class="language-plaintext highlighter-rouge">Node(B)</code></strong></h3> <ul> <li><code class="language-plaintext highlighter-rouge">T1</code> successfully attaches <code class="language-plaintext highlighter-rouge">Node(B)</code>: <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HEAD -&gt; Node(A) -&gt; Node(B)
</code></pre></div> </div> </li> <li>But <code class="language-plaintext highlighter-rouge">tail_</code> is <strong>still pointing to <code class="language-plaintext highlighter-rouge">Node(A)</code></strong>.</li> <li>Before <code class="language-plaintext highlighter-rouge">T1</code> can update <code class="language-plaintext highlighter-rouge">tail_</code>, <strong>T2 and T3 start running.</strong></li> </ul> <hr/> <h3 id="step-2-t2-reads-stale-tail_--nodea-tries-to-enqueue-nodec"><strong>Step 2: T2 Reads Stale <code class="language-plaintext highlighter-rouge">tail_ = Node(A)</code>, Tries to Enqueue <code class="language-plaintext highlighter-rouge">Node(C)</code></strong></h3> <ul> <li><code class="language-plaintext highlighter-rouge">T2</code> reads: <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>old_tail = Node(A), next = Node(B)
</code></pre></div> </div> </li> <li>Since <code class="language-plaintext highlighter-rouge">next != nullptr</code>, <strong>it helps move <code class="language-plaintext highlighter-rouge">tail_</code> to <code class="language-plaintext highlighter-rouge">Node(B)</code>, then retries.</strong></li> <li><strong>Now <code class="language-plaintext highlighter-rouge">tail_ = Node(B)</code>.</strong></li> </ul> <hr/> <h3 id="step-3-t2-successfully-enqueues-nodec"><strong>Step 3: T2 Successfully Enqueues <code class="language-plaintext highlighter-rouge">Node(C)</code></strong></h3> <ul> <li><code class="language-plaintext highlighter-rouge">T2</code> now enqueues <code class="language-plaintext highlighter-rouge">Node(C)</code>: <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HEAD -&gt; Node(A) -&gt; Node(B) -&gt; Node(C)
</code></pre></div> </div> </li> <li>But <code class="language-plaintext highlighter-rouge">tail_</code> <strong>is still pointing to <code class="language-plaintext highlighter-rouge">Node(B)</code></strong>.</li> <li>Before <code class="language-plaintext highlighter-rouge">T2</code> updates <code class="language-plaintext highlighter-rouge">tail_</code>, <strong>T3 starts running.</strong></li> </ul> <hr/> <h3 id="step-4-t3-reads-stale-tail_--nodeb-tries-to-enqueue-noded"><strong>Step 4: T3 Reads Stale <code class="language-plaintext highlighter-rouge">tail_ = Node(B)</code>, Tries to Enqueue <code class="language-plaintext highlighter-rouge">Node(D)</code></strong></h3> <ul> <li><code class="language-plaintext highlighter-rouge">T3</code> reads: <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>old_tail = Node(B), next = Node(C)
</code></pre></div> </div> </li> <li>Since <code class="language-plaintext highlighter-rouge">next != nullptr</code>, <strong>it helps move <code class="language-plaintext highlighter-rouge">tail_</code> to <code class="language-plaintext highlighter-rouge">Node(C)</code>, then retries.</strong></li> <li><strong>Now <code class="language-plaintext highlighter-rouge">tail_ = Node(C)</code>.</strong></li> </ul> <hr/> <h3 id="step-5-t3-successfully-enqueues-noded"><strong>Step 5: T3 Successfully Enqueues <code class="language-plaintext highlighter-rouge">Node(D)</code></strong></h3> <ul> <li><code class="language-plaintext highlighter-rouge">T3</code> enqueues <code class="language-plaintext highlighter-rouge">Node(D)</code>: <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HEAD -&gt; Node(A) -&gt; Node(B) -&gt; Node(C) -&gt; Node(D)
</code></pre></div> </div> </li> <li>But <code class="language-plaintext highlighter-rouge">tail_</code> is <strong>still pointing to <code class="language-plaintext highlighter-rouge">Node(C)</code></strong>.</li> <li>If <strong>no other thread updates <code class="language-plaintext highlighter-rouge">tail_</code> now, it remains stale!</strong></li> </ul> <hr/> <h2 id="the-core-problem-in-the-second-implementation"><strong>The Core Problem in the Second Implementation</strong></h2> <p>If <strong>all threads finish</strong> and no new thread is enqueueing, <code class="language-plaintext highlighter-rouge">tail_</code> <strong>might be stuck at an old node</strong> (e.g., <code class="language-plaintext highlighter-rouge">Node(C)</code> instead of <code class="language-plaintext highlighter-rouge">Node(D)</code>).</p> <p>This <strong>isn‚Äôt guaranteed to cause a failure immediately</strong>, but it creates two major issues:</p> <ol> <li><strong>Future threads must do extra retries to move <code class="language-plaintext highlighter-rouge">tail_</code> forward.</strong> <ul> <li>If <code class="language-plaintext highlighter-rouge">tail_</code> lags behind, future enqueue operations will see <code class="language-plaintext highlighter-rouge">next != nullptr</code> and must <strong>repeatedly help move <code class="language-plaintext highlighter-rouge">tail_</code> forward before enqueuing.</strong></li> <li>This <strong>adds unnecessary contention and performance overhead.</strong></li> </ul> </li> <li><strong>If a dequeue operation runs now, it may have to traverse multiple nodes before reaching <code class="language-plaintext highlighter-rouge">tail_</code>.</strong> <ul> <li>A correct <code class="language-plaintext highlighter-rouge">tail_</code> should always point to the last node, minimizing the traversal cost for future operations.</li> </ul> </li> </ol> <h3 id="why-doesnt-this-happen-in-the-first-implementation"><strong>Why Doesn‚Äôt This Happen in the First Implementation?</strong></h3> <p>The <strong>first implementation guarantees that <code class="language-plaintext highlighter-rouge">tail_</code> always points to the latest node before returning</strong>:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
    <span class="k">continue</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <ul> <li>If <code class="language-plaintext highlighter-rouge">next != nullptr</code>, we <strong>keep updating <code class="language-plaintext highlighter-rouge">tail_</code> and retrying until we attach our node to the latest position</strong>.</li> <li>This ensures that when the function exits, <code class="language-plaintext highlighter-rouge">tail_</code> <strong>always points to the correct last node</strong>.</li> </ul> <hr/> <h2 id="final-takeaway-1"><strong>Final Takeaway</strong></h2> <p>üîπ <strong>Yes, other threads can update <code class="language-plaintext highlighter-rouge">tail_</code>, but the second implementation relies on this happening rather than guaranteeing correctness itself.</strong><br/> üîπ <strong>If no other thread updates <code class="language-plaintext highlighter-rouge">tail_</code>, <code class="language-plaintext highlighter-rouge">tail_</code> can become stale, leading to inefficiencies and unnecessary retries.</strong><br/> üîπ The <strong>first implementation actively ensures <code class="language-plaintext highlighter-rouge">tail_</code> is always updated before returning</strong>, making it more robust and efficient.</p> <p>I still don‚Äôt get it. I will just give up then. At least I learn what‚Äôs the correct implementaion of lock free queue.</p> <h2 id="full-test-code">Full test code</h2> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cassert&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp">
</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">Node</span><span class="p">{</span>
  <span class="n">Node</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
    <span class="n">next</span> <span class="o">=</span> <span class="n">prev</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">prev</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Queue</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Queue</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">head_</span> <span class="o">=</span> <span class="n">tail_</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">size_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">head_</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">tail_</span><span class="p">;</span>
    <span class="n">tail_</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">head_</span><span class="p">;</span>


  <span class="p">}</span>

  <span class="kt">void</span> <span class="nf">enque</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">tail_</span><span class="p">;</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">tail_</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>
    <span class="n">tail_</span><span class="o">-&gt;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
    <span class="n">tail_</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
    <span class="n">size_</span><span class="o">++</span><span class="p">;</span>


  <span class="p">}</span>

  <span class="kt">bool</span> <span class="nf">deque</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">size_</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">head_</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
    <span class="n">head_</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">head_</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">node</span><span class="p">;</span>
    <span class="n">size_</span><span class="o">--</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

  <span class="p">}</span>

  <span class="kt">bool</span> <span class="nf">empty</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">size_</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>

  <span class="p">}</span>

  <span class="kt">int</span> <span class="nf">front</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">head_</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>

  <span class="p">}</span>


<span class="k">private</span><span class="o">:</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">head_</span><span class="p">;</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">tail_</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">size_</span><span class="p">;</span>


<span class="p">};</span>


<span class="k">struct</span> <span class="nc">SimpleNode</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">SimpleNode</span><span class="o">*&gt;</span> <span class="n">next</span><span class="p">;</span>
  <span class="n">SimpleNode</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">next</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">SimpleNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
    <span class="n">next</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
  <span class="p">}</span>

<span class="p">};</span>


<span class="k">class</span> <span class="nc">MyLockFreeQueue</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">MyLockFreeQueue</span><span class="p">()</span>  <span class="p">{</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SimpleNode</span><span class="p">();</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="n">head_</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
    <span class="n">tail_</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>

  <span class="p">}</span>
<span class="c1">// void enque(int val) {</span>
<span class="c1">//     // Allocate the new node</span>
<span class="c1">//     std::unique_ptr&lt;SimpleNode&gt; node = std::make_unique&lt;SimpleNode&gt;(val);</span>

<span class="c1">//     SimpleNode* old_tail = nullptr;</span>
<span class="c1">//     SimpleNode* next = nullptr;</span>

<span class="c1">//     while (true) {</span>
<span class="c1">//         old_tail = tail_.load();</span>
<span class="c1">//         next = old_tail-&gt;next.load();</span>

<span class="c1">//         if (old_tail != tail_.load()) {</span>
<span class="c1">//             continue; // Retry if tail changed</span>
<span class="c1">//         }</span>

<span class="c1">//         if (next != nullptr) {</span>
<span class="c1">//             // Help advance tail if it's stale</span>
<span class="c1">//             tail_.compare_exchange_weak(old_tail, next);</span>
<span class="c1">//             continue;</span>
<span class="c1">//         }</span>

<span class="c1">//         // Try to attach the new node</span>
<span class="c1">//         if (old_tail-&gt;next.compare_exchange_weak(next, node.get())) {</span>
<span class="c1">//             // Successfully linked, now update tail_</span>
<span class="c1">//             tail_.compare_exchange_weak(old_tail, node.release());</span>
<span class="c1">//             return;</span>
<span class="c1">//         }</span>
<span class="c1">//     }</span>
<span class="c1">// }</span>

  <span class="kt">void</span> <span class="nf">enque</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">SimpleNode</span><span class="o">&gt;</span> <span class="n">node</span><span class="p">(</span><span class="k">new</span> <span class="n">SimpleNode</span><span class="p">());</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">old_tail</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">next</span>  <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>  
    <span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">old_tail</span> <span class="o">=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
      <span class="n">next</span> <span class="o">=</span> <span class="n">old_tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
      <span class="k">if</span><span class="p">(</span><span class="n">old_tail</span> <span class="o">!=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">continue</span><span class="p">;</span>
      
      <span class="p">}</span>
      <span class="k">if</span><span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="k">if</span><span class="p">(</span><span class="n">old_tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">get</span><span class="p">()))</span> <span class="p">{</span>

      <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">release</span><span class="p">());</span>
        <span class="k">return</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span> 
  <span class="p">}</span>

    <span class="kt">int</span> <span class="nf">size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">node</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">node</span> <span class="o">!=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">count</span><span class="o">++</span><span class="p">;</span>
      <span class="k">if</span><span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"node is null, count is "</span> <span class="o">&lt;&lt;</span> <span class="n">count</span><span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

      <span class="p">}</span>
      <span class="n">assert</span><span class="p">(</span><span class="n">node</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">);</span>
      <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// bool deque(int&amp; val) {</span>
  <span class="c1">//   SimpleNode* old_head = nullptr;</span>
  <span class="c1">//   SimpleNode* old_tail = nullptr;</span>
  <span class="c1">//   SimpleNode* next = nullptr;</span>
  <span class="c1">//   do {</span>
  <span class="c1">//     old_head = head_.load();</span>
  <span class="c1">//     old_tail = tail_.load();</span>
  <span class="c1">//     assert(old_head != nullptr);</span>
  <span class="c1">//     next = old_head-&gt;next.load();</span>
  <span class="c1">//     if(old_head != head_.load()) {</span>
  <span class="c1">//       continue;</span>
  <span class="c1">//     }</span>
  <span class="c1">//     if(old_head == old_tail &amp;&amp; next == nullptr) {</span>
  <span class="c1">//       return false;</span>
  <span class="c1">//     }</span>
  <span class="c1">//   } while(head_.compare_exchange_weak(old_head, next) == false);</span>

  <span class="c1">//   val = next-&gt;val;</span>
  <span class="c1">//   delete old_head;</span>
  <span class="c1">//   return true;</span>
  <span class="c1">// }</span>

<span class="kt">bool</span> <span class="nf">deque</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">result</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">oldHead</span><span class="p">;</span>
    <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
    
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">oldHead</span> <span class="o">=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
        <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">oldTail</span> <span class="o">=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
        <span class="n">next</span> <span class="o">=</span> <span class="n">oldHead</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">oldHead</span> <span class="o">!=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span> <span class="c1">// Restart loop if head changed</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">oldHead</span> <span class="o">==</span> <span class="n">oldTail</span><span class="p">)</span> <span class="p">{</span> 
            <span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// Queue is empty</span>
            <span class="p">}</span>
            <span class="c1">// Help advance the tail if it's stuck (optional optimization)</span>
            <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">oldTail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
        <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="n">head_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">oldHead</span><span class="p">,</span> <span class="n">next</span><span class="p">))</span> <span class="p">{</span>
          <span class="c1">// Ensure next is valid before accessing it</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
              <span class="n">result</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
              <span class="k">delete</span> <span class="n">oldHead</span><span class="p">;</span>
              <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
          <span class="p">}</span>


          <span class="p">}</span>
        
    <span class="p">}</span> 

    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// Failsafe check, should not be reached</span>
<span class="p">}</span>

    <span class="c1">// bool deque(int&amp; result) {</span>
    <span class="c1">//     SimpleNode* oldHead;</span>
    <span class="c1">//     SimpleNode* next;</span>
    <span class="c1">//     do {</span>
    <span class="c1">//         oldHead = head_.load();</span>
    <span class="c1">//         SimpleNode* oldTail = tail_.load();</span>
    <span class="c1">//         next = oldHead-&gt;next.load();</span>
    <span class="c1">//         if (oldHead!= head_.load()) {</span>
    <span class="c1">//             continue;</span>
    <span class="c1">//         }</span>
    <span class="c1">//         if (oldHead == oldTail &amp;&amp; next == nullptr) {</span>
    <span class="c1">//             return false;</span>
    <span class="c1">//         }</span>
    <span class="c1">//     } while (!head_.compare_exchange_weak(oldHead, next));</span>
    <span class="c1">//     result = std::move(next-&gt;val);</span>
    <span class="c1">//     delete oldHead;</span>
    <span class="c1">//     return true;</span>
    <span class="c1">// }</span>


  <span class="kt">bool</span> <span class="nf">empty</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">()</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">;</span>
  <span class="p">}</span>


  <span class="k">private</span><span class="o">:</span>
  <span class="c1">// size</span>
  <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">size_</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">SimpleNode</span><span class="o">*&gt;</span> <span class="n">head_</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">SimpleNode</span><span class="o">*&gt;</span> <span class="n">tail_</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">MyLockFreeQueue2</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">MyLockFreeQueue2</span><span class="p">()</span> <span class="o">:</span> <span class="n">size_</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SimpleNode</span><span class="p">();</span>
        <span class="n">head_</span> <span class="o">=</span> <span class="n">tail_</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">enque</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SimpleNode</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
        <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">old_tail</span><span class="p">;</span>
        <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>

        <span class="k">do</span> <span class="p">{</span>
            <span class="n">old_tail</span> <span class="o">=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
            <span class="n">next</span> <span class="o">=</span> <span class="n">old_tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">old_tail</span> <span class="o">!=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">())</span> <span class="p">{</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">old_tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">node</span><span class="p">));</span>

        <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_tail</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
        <span class="n">size_</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="nf">deque</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">old_head</span><span class="p">;</span>
        <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">old_tail</span><span class="p">;</span>
        <span class="n">SimpleNode</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>

        <span class="k">do</span> <span class="p">{</span>
            <span class="n">old_head</span> <span class="o">=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
            <span class="n">old_tail</span> <span class="o">=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
            <span class="n">next</span> <span class="o">=</span> <span class="n">old_head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">old_head</span> <span class="o">!=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">())</span> <span class="p">{</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">old_head</span> <span class="o">==</span> <span class="n">old_tail</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="c1">// tail_.compare_exchange_weak(old_tail, next);</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">val</span> <span class="o">=</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">head_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_head</span><span class="p">,</span> <span class="n">next</span><span class="p">));</span>

        <span class="n">safe_delete</span><span class="p">(</span><span class="n">old_head</span><span class="p">);</span> <span class="c1">// Use a safe delete method</span>
        <span class="n">size_</span><span class="p">.</span><span class="n">fetch_sub</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="nf">empty</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">()</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="p">}</span>

  <span class="kt">int</span> <span class="nf">size</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">size_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
  <span class="p">}</span>


<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">size_</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">SimpleNode</span><span class="o">*&gt;</span> <span class="n">head_</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">SimpleNode</span><span class="o">*&gt;</span> <span class="n">tail_</span><span class="p">;</span>

    <span class="kt">void</span> <span class="nf">safe_delete</span><span class="p">(</span><span class="n">SimpleNode</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">delete</span> <span class="n">node</span><span class="p">;</span>
        <span class="c1">// Implement a safe deletion mechanism to prevent use-after-free issues</span>
        <span class="c1">// This could be done with a garbage collector or hazard pointers.</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">LockFreeQueue</span><span class="p">{</span>

<span class="nl">public:</span>
  <span class="n">LockFreeQueue</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">head_</span> <span class="o">=</span> <span class="n">tail_</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">head_</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">tail_</span><span class="p">;</span>
    <span class="n">tail_</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">head_</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="nf">enque</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">tail_</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Node</span><span class="o">*</span> <span class="n">next</span> <span class="o">=</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
      <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
      <span class="n">node</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">__sync_bool_compare_and_swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">node</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">bool</span> <span class="nf">deque</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">node</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">node</span> <span class="o">=</span> <span class="n">head_</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="n">tail_</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">Node</span><span class="o">*</span> <span class="n">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">__sync_bool_compare_and_swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head_</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">next</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">head_</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">node</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">bool</span> <span class="nf">empty</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">head_</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="n">tail_</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">int</span> <span class="nf">front</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">head_</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
  <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">head_</span><span class="p">;</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">tail_</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">test_my_lock_free_queue</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// enque 100 times concurrently and dequeue 100 times concurrently</span>
  <span class="n">MyLockFreeQueue</span> <span class="n">q</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">num_threads</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">num_ops</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">threads</span><span class="p">[</span><span class="n">num_threads</span><span class="p">];</span>
  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">dequeue_threads</span><span class="p">[</span><span class="n">num_threads</span><span class="p">];</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_threads</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">([</span><span class="o">&amp;</span><span class="n">q</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">num_ops</span><span class="p">]</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">num_ops</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">q</span><span class="p">.</span><span class="n">enque</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">num_ops</span> <span class="o">+</span> <span class="n">j</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_threads</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">join</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">" hello "</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="c1">// get queue size</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"size "</span> <span class="o">&lt;&lt;</span> <span class="n">q</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>


  <span class="c1">// return;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_threads</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">dequeue_threads</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">([</span><span class="o">&amp;</span><span class="n">q</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">num_ops</span><span class="p">]</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">num_ops</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">res</span> <span class="o">=</span>  <span class="n">q</span><span class="p">.</span><span class="n">deque</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
        <span class="c1">// cout &lt;&lt; "cur val " &lt;&lt; val &lt;&lt; endl;</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"cur num "</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">" cur ops "</span> <span class="o">&lt;&lt;</span> <span class="n">j</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
          <span class="n">assert</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">});</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_threads</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">dequeue_threads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">join</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">());</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"All tests pass"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

<span class="p">}</span>

<span class="kt">void</span> <span class="nf">testnormalqueue</span><span class="p">()</span> <span class="p">{</span>
<span class="n">Queue</span> <span class="n">q</span><span class="p">;</span>
  <span class="n">q</span><span class="p">.</span><span class="n">enque</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">q</span><span class="p">.</span><span class="n">enque</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="n">q</span><span class="p">.</span><span class="n">enque</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
  <span class="n">q</span><span class="p">.</span><span class="n">deque</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
  <span class="n">q</span><span class="p">.</span><span class="n">enque</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span><span class="p">);</span>
  <span class="n">q</span><span class="p">.</span><span class="n">deque</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">()</span> <span class="o">==</span> <span class="mi">3</span><span class="p">);</span>
  <span class="n">q</span><span class="p">.</span><span class="n">deque</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">()</span> <span class="o">==</span> <span class="mi">4</span><span class="p">);</span>
  <span class="n">q</span><span class="p">.</span><span class="n">deque</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">());</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"All tests pass"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

<span class="p">}</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cassert&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">test_concurrent_lock_free_queue</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">MyLockFreeQueue</span> <span class="n">q</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">num_threads</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">num_ops</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">enqueue_threads</span><span class="p">[</span><span class="n">num_threads</span><span class="p">];</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">dequeue_threads</span><span class="p">[</span><span class="n">num_threads</span><span class="p">];</span>

    <span class="c1">// Enqueue and dequeue concurrently</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_threads</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">enqueue_threads</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">([</span><span class="o">&amp;</span><span class="n">q</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">num_ops</span><span class="p">]</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">num_ops</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">q</span><span class="p">.</span><span class="n">enque</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">num_ops</span> <span class="o">+</span> <span class="n">j</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">});</span>

        <span class="n">dequeue_threads</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">([</span><span class="o">&amp;</span><span class="n">q</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">num_ops</span><span class="p">]</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">num_ops</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">deque</span><span class="p">(</span><span class="n">val</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// Check return value to avoid undefined behavior</span>
                    <span class="c1">// Process val (optional)</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">});</span>
    <span class="p">}</span>

    <span class="c1">// Join all threads</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_threads</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">enqueue_threads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">join</span><span class="p">();</span>
        <span class="n">dequeue_threads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">join</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="c1">// Ensure queue is empty</span>
    <span class="c1">// assert(q.empty());</span>

    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">cout_mutex</span><span class="p">;</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">cout_mutex</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">q</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"test concurrent lock free queue All tests pass"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// test_concurrent_lock_free_queue();</span>
  <span class="n">test_my_lock_free_queue</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="references">References</h2> <p><a href="https://book-of-gehn.github.io/articles/2020/04/28/Lock-Free-Queue-Part-II.html">https://book-of-gehn.github.io/articles/2020/04/28/Lock-Free-Queue-Part-II.html</a> I don‚Äôt fully get the idea in this article.</p> <p><a href="https://mp.weixin.qq.com/s?__biz=Mzg4NDQ0OTI4Ng==&amp;mid=2247490953&amp;idx=1&amp;sn=00dd064b978d2bae85939f5e387d1022&amp;chksm=cfb954e0f8ceddf641401126ad96bb5ca8ec37d206f66792aaae9f48decdc1292eef2c296f16&amp;cur_album_id=3140091333123276802&amp;scene=189#wechat_redirect">https://mp.weixin.qq.com/s?__biz=Mzg4NDQ0OTI4Ng==&amp;mid=2247490953&amp;idx=1&amp;sn=00dd064b978d2bae85939f5e387d1022&amp;chksm=cfb954e0f8ceddf641401126ad96bb5ca8ec37d206f66792aaae9f48decdc1292eef2c296f16&amp;cur_album_id=3140091333123276802&amp;scene=189#wechat_redirect</a> This article talks about licked list implementaion and array implementaion which is useful.</p> <p><a href="https://github.com/cameron314/concurrentqueue">https://github.com/cameron314/concurrentqueue</a></p>]]></content><author><name></name></author><category term="backend"/><category term="concurrent-programming"/><category term="cpp"/><category term="queue"/><summary type="html"><![CDATA[lock free queue impl on wechat subscription post]]></summary></entry><entry><title type="html">nanogpt kv cache first attempt</title><link href="https://bilyz98.github.io/blog/2025/llm-kv-cache-first-attempt/" rel="alternate" type="text/html" title="nanogpt kv cache first attempt"/><published>2025-01-18T11:59:00+00:00</published><updated>2025-01-18T11:59:00+00:00</updated><id>https://bilyz98.github.io/blog/2025/llm-kv-cache-first-attempt</id><content type="html" xml:base="https://bilyz98.github.io/blog/2025/llm-kv-cache-first-attempt/"><![CDATA[<h2 id="1-run-basic-nano-gpt">1. Run basic nano-gpt</h2> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/karpathy/nanoGPT.git

</code></pre></div></div> <p>Install necessary packages</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip install -r requirements.txt
</code></pre></div></div> <p>I have these packages in the requirements.txt</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>blobfile==2.0.1
certifi==2022.12.7
charset-normalizer==3.0.1
filelock==3.9.0
idna==3.4
lxml==4.9.2
numpy==1.24.2
pycryptodomex==3.17
pytz==2022.7.1
regex==2022.10.31
requests==2.28.2
tokenizers==0.13.2
torch==2.0.0
typing_extensions==4.4.0
urllib3==1.26.14
torch==2.0.0
numpy==1.24.2
transformers==4.28.1
datasets==2.11.0
tiktoken==0.3.3
wandb==0.14.2
tqdm==4.65.0
</code></pre></div></div> <p>Follow quick start guidance in nanogpt repo do make sure that we can run training and inference successfully.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python data/shakespeare_char/prepare.py
python train.py --compile=False config/train_shakespeare_char.py
python sample.py --out_dir=out-shakespeare-char
</code></pre></div></div> <p>My python version is 3.11 which is too high for model compile so I added <code class="language-plaintext highlighter-rouge">--compile=False</code> in train command.</p> <p>With my A800 gpu, I get a loss 0.0449 after 5000 iteration training.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iter 4970: loss 0.0461, time 18.12ms, mfu 20.21%
iter 4980: loss 0.0441, time 18.14ms, mfu 20.24%
iter 4990: loss 0.0464, time 18.13ms, mfu 20.27%
step 5000: train loss 0.0383, val loss 4.7262
iter 5000: loss 0.0449, time 3352.84ms, mfu 18.26%
</code></pre></div></div> <h2 id="2-load-gpt-2-models--checkpoints-and-test-performance">2. Load GPT-2 models checkpoints and test performance</h2> <p>https://stackoverflow.com/questions/75110981/sslerror-httpsconnectionpoolhost-huggingface-co-port-443-max-retries-exce</p> <p>proxy error while trying to download gpt2 model from huggingface: <a href="https://github.com/huggingface/transformers/issues/17611">https://github.com/huggingface/transformers/issues/17611</a></p> <p>First downgrad requests version to 2.27.1</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip <span class="nb">install </span><span class="nv">requests</span><span class="o">==</span>2.27.1
</code></pre></div></div> <p>And then adding these two lines of code in <code class="language-plaintext highlighter-rouge">train.py</code> and <code class="language-plaintext highlighter-rouge">sample.py</code> fix the proxy connection issue for me</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">os</span><span class="p">.</span><span class="n">environ</span><span class="p">[</span><span class="sh">'</span><span class="s">CURL_CA_BUNDLE</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="sh">''</span>
<span class="n">os</span><span class="p">.</span><span class="n">environ</span><span class="p">[</span><span class="sh">'</span><span class="s">HF_ENDPOINT</span><span class="sh">'</span><span class="p">]</span><span class="o">=</span> <span class="sh">'</span><span class="s">https://hf-mirror.com</span><span class="sh">'</span>
</code></pre></div></div> <p>Run <code class="language-plaintext highlighter-rouge">sample.py</code> to get a test of gpt2 model with params downloaded from huggingface.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> python sample.py --init_from='gpt2'
</code></pre></div></div> <p>I tried to start with ‚Äúplease tell me a joke.‚Äù The output is not anything like joke but still very readable.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>please tell me a joke

[‚Ä¶]

My name is Zarek, but I am extremely sad for you.

You can't even come to my house anymore

I'm sorry, I know

I have a dream

I don't know how long this thing will last

My name Is Zarek

I'm an adult who believes that

The problem with your friend is that he doesnt know

He doesn't know how to act
</code></pre></div></div> <p>running time for 10 times inference:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>---------------
Elapsed time: 25.4s
</code></pre></div></div> <h2 id="3-implement-kv-cache-for-faster-inference">3. Implement KV cache for faster inference</h2> <p><a href="https://github.com/BilyZ98/nano-gpt-kv-cache/commit/606e4e4e881db6c769e0bdca51bdac96f00a55e1">Commit hisotry for kv cache implementation</a></p> <p>Please check code above for implementation details.</p> <p>Issue:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>shape of past k proj is  torch.Size([1, 12, 946, 64])
shape of k is  torch.Size([1, 12, 44, 64]) shape of v is  torch.Size([1, 12, 44, 64])
q len is  45
shape of past k proj is  torch.Size([1, 12, 990, 64])
shape of k is  torch.Size([1, 12, 45, 64]) shape of v is  torch.Size([1, 12, 45, 64])
Traceback (most recent call last):
  File "/GPUFS/nsccgz_qylin_1/zt/nano-gpt-kv-cache/sample.py", line 93, in &lt;module&gt;
    y = model.generate(x, max_new_tokens, temperature=temperature, top_k=top_k)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/GPUFS/nsccgz_qylin_1/miniconda3/lib/python3.11/site-packages/torch/utils/_contextlib.py", line 115, in decorate_context
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "/GPUFS/nsccgz_qylin_1/zt/nano-gpt-kv-cache/model.py", line 359, in generate
    logits, _, past_kv_proj = self(idx_cond, past_kv_proj=past_kv_proj,start_pos=start_pos)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/GPUFS/nsccgz_qylin_1/miniconda3/lib/python3.11/site-packages/torch/nn/modules/module.py", line 1501, in _call_impl
    return forward_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/GPUFS/nsccgz_qylin_1/zt/nano-gpt-kv-cache/model.py", line 204, in forward
    x, layer_kv_proj = block(x, past_kv_proj=past_kv_proj[i])
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/GPUFS/nsccgz_qylin_1/miniconda3/lib/python3.11/site-packages/torch/nn/modules/module.py", line 1501, in _call_impl
    return forward_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/GPUFS/nsccgz_qylin_1/zt/nano-gpt-kv-cache/model.py", line 122, in forward
    attn_res, present_kv_proj = self.attn(self.ln_1(x), past_kv_proj=past_kv_proj)
                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/GPUFS/nsccgz_qylin_1/miniconda3/lib/python3.11/site-packages/torch/nn/modules/module.py", line 1501, in _call_impl
    return forward_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/GPUFS/nsccgz_qylin_1/zt/nano-gpt-kv-cache/model.py", line 78, in forward
    assert KV &lt; self.block_size, f"KV: {KV} &gt;= block_size: {self.block_size}"
           ^^^^^^^^^^^^^^^^^^^^
AssertionError: KV: 1035 &gt;= block_size: 1024
yhrun: error: gpu73: task 0: Exited with exit code 1
(nano-gpt-kv-cache) [nsccgz_qylin_1@ln101 nano-gpt-kv-cache]$
</code></pre></div></div> <p>Fix</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">def</span> <span class="nf">generate</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">max_new_tokens</span><span class="p">,</span> <span class="n">temperature</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">top_k</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">max_new_tokens</span><span class="p">):</span>
            <span class="c1"># This is the righ condition
</span>            <span class="k">if</span> <span class="n">idx</span><span class="p">.</span><span class="nf">size</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="o">==</span> <span class="n">T</span><span class="p">:</span>
                <span class="n">idx_cond</span> <span class="o">=</span> <span class="n">idx</span>
                <span class="n">start_pos</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">idx_cond</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[:,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                <span class="n">start_pos</span> <span class="o">=</span> <span class="n">idx</span><span class="p">.</span><span class="nf">size</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
</code></pre></div></div> <p>The limitation of this code is that it can only handles condition where <code class="language-plaintext highlighter-rouge">max_new_tokens &lt; self.config.block_size</code></p> <p>I don‚Äôt know why yet.</p> <h2 id="4-test-kv-cache-performance">4. Test KV cache performance</h2> <p><a href="https://github.com/karpathy/nanoGPT/pull/76">The commit</a> mentions that it only brings performance boost with cpu but not on A100 gpu. Why is that ? Is this because that linear projections can be quickly done with fast gpu matrix multiplication?</p> <p><a href="https://github.com/huggingface/transformers/pull/14118/files">This commit</a> <a href="https://github.com/huggingface/transformers/issues/14033#issuecomment-948385227">and this discussion</a> talks about how to handle long text generation. I have not yet understanded it completely how it deals with long text geneartion.</p> <p>There is a technique called rotary positional embeddings as mentioned in this <a href="https://github.com/karpathy/nanoGPT/pull/76">commit</a>. But I don‚Äôt know how does it works yet. And all I want to do right now is to simply test how kv cache helps with inference speed.</p> <p>My naive solution right now is to simply cut past_kv_proj to latest self.config.block_size tokens</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            if past_kv_proj is not None:
                past_k_proj, past_v_proj = past_kv_proj
                print('shape of past k proj is ', past_k_proj.shape )
                print('shape of k is ', k.shape, 'shape of v is ', v.shape)
                if KV &gt;= self.block_size:
                    past_k_proj = past_k_proj[:, :, -self.block_size:, :]
                    past_v_proj = past_v_proj[:, :, -self.block_size:, :]
                k = torch.cat((past_k_proj, k), dim=2)
                v = torch.cat((past_v_proj, v), dim=2)

</code></pre></div></div> <p>gpu v100</p> <p>with kv cache, no flash attention</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> yhrun -p gpu_v100  python   sample.py --init_from='gpt2'  --use_kv_cache=True --dtype=float32  --num_samples=10 --max_
new_tokens=1000
</code></pre></div></div> <p>time:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>---------------
Elapsed time: 102.6s
</code></pre></div></div> <p>memory: almost the same for peak memory usage ?</p> <p>without kv cache, no flash attention</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python   sample.py --init_from='gpt2'  --use_kv_cache=False --dtype=float32  --num_samples=10 --max_new_tokens=1000
</code></pre></div></div> <p>time:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Elapsed time: 151.8s
</code></pre></div></div> <p>memory:</p> <p>Saves 30% time. Not bad.</p> <p>Function profile: I run 10 times, each with 1000 generation sequence length.</p> <p>with kv cache:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      15990616 function calls (14380614 primitive calls) in 110.086 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
   120000   21.130    0.000   56.527    0.000 /GPUFS/nsccgz_qylin_1/zt/nano-gpt-kv-cache/model.py:58(forward)
   490000   14.545    0.000   14.545    0.000 {built-in method torch._C._nn.linear}
1620000/10000   13.119    0.000  103.105    0.010 /GPUFS/nsccgz_qylin_1/miniconda3/lib/python3.11/site-packages/torch/nn/modules/module.py:1494(_call_impl)
  3420000    9.789    0.000    9.789    0.000 /GPUFS/nsccgz_qylin_1/miniconda3/lib/python3.11/site-packages/torch/nn/modules/module.py:1601(__getattr__)
   120000    5.108    0.000   97.206    0.001 /GPUFS/nsccgz_qylin_1/zt/nano-gpt-kv-cache/model.py:135(forward)
   250000    4.809    0.000    4.809    0.000 {built-in method torch.layer_norm}
   120000    3.840    0.000    3.840    0.000 {method 'masked_fill' of 'torch._C._TensorBase' objects}
       10    3.737    0.374  109.808   10.981 /GPUFS/nsccgz_qylin_1/zt/nano-gpt-kv-cache/model.py:350(generate)
   250000    3.694    0.000    3.694    0.000 {built-in method torch.cat}
   120000    2.772    0.000   20.640    0.000 /GPUFS/nsccgz_qylin_1/zt/nano-gpt-kv-cache/model.py:113(forward)
   370000    2.268    0.000    3.704    0.000 /GPUFS/nsccgz_qylin_1/miniconda3/lib/python3.11/site-packages/torch/nn/functional.py:1235(dropout)

    10000    2.075    0.000  102.922    0.010 /GPUFS/nsccgz_qylin_1/zt/nano-gpt-kv-cache/model.py:206(forward)

</code></pre></div></div> <p>without kv cache</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>       15380126 function calls (13770124 primitive calls) in 154.658 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)

    10000   45.431    0.005  148.326    0.015 /GPUFS/nsccgz_qylin_1/zt/nano-gpt-kv-cache/model.py:206(forward)

   120000   22.252    0.000   58.175    0.000 /GPUFS/nsccgz_qylin_1/zt/nano-gpt-kv-cache/model.py:58(forward)
   490000   17.891    0.000   17.891    0.000 {built-in method torch._C._nn.linear}
1620000/10000   13.188    0.000  148.485    0.015 /GPUFS/nsccgz_qylin_1/miniconda3/lib/python3.11/site-packages/torch/nn/modules/module.py:1494(_call_impl)
  3420000    9.488    0.000    9.488    0.000 /GPUFS/nsccgz_qylin_1/miniconda3/lib/python3.11/site-packages/torch/nn/modules/module.py:1601(__getattr__)
   120000    5.289    0.000   99.160    0.001 /GPUFS/nsccgz_qylin_1/zt/nano-gpt-kv-cache/model.py:135(forward)
   250000    5.037    0.000    5.037    0.000 {built-in method torch.layer_norm}
   120000    4.087    0.000    4.087    0.000 {method 'masked_fill' of 'torch._C._TensorBase' objects}
       10    2.952    0.295  154.334   15.433 /GPUFS/nsccgz_qylin_1/zt/nano-gpt-kv-cache/model.py:350(generate)
</code></pre></div></div> <p>The main time difference comes from the function call to self attention block. Per call time for without kv cache gpt is 0.015 and it‚Äôs 0.010 for with kv cache. I guess this explains why benefit of kv cache for short sequence geneartion on A100 is negligible because it takes very short amount of time to generate key and value embedding with more advanced gpu.</p> <p>500 tokens, cpu</p> <p>with kv cache,</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>The law gives the government access to consumer information only if the government's purpose is to provide health care to the general public. If those
---------------
Elapsed time: 218.9s


The law gives the government access to consumer information only if the government's purpose is to provide health care to the general public. If those
---------------
Elapsed time: 251.4s
</code></pre></div></div> <p>without kv cache</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>The law gives the government access to consumer information only if the government's purpose is to provide health care to the general public. If those
---------------
Elapsed time: 1191.4s
</code></pre></div></div> <p>5 times inference time saving. Not bad.</p> <p>The peak memory usage between with kv cache and without kv cache is nearly the same. This is because that sequence length is the same with or without kv cache. However, kv cache do bring some advantages. Here‚Äôs the answer from gpt.</p> <blockquote> <p>Actually, there is a difference in memory usage when using KV cache for LLM inference. While it‚Äôs true that the maximum memory usage might be similar, the way memory is utilized and managed can vary significantly.</p> <ol> <li><strong>Memory Allocation</strong>: With KV cache, memory is allocated for storing key-value pairs from previous computations. This can lead to more efficient memory usage as the model doesn‚Äôt need to recompute values, reducing the overall memory footprint during inference.</li> <li><strong>Memory Management</strong>: KV cache helps in better memory management by reusing previously computed values. This can lead to more stable memory usage patterns, avoiding spikes in memory consumption that might occur without caching.</li> <li><strong>Performance Optimization</strong>: By reducing redundant computations, KV cache can lead to faster inference times, which indirectly affects memory usage. Faster computations mean less time spent holding intermediate values in memory, leading to more efficient memory utilization.</li> </ol> </blockquote> <h2 id="references">References</h2> <p><a href="https://www.youtube.com/watch?v=80bIUggRJf4&amp;t=247s">youtube video llm kv cache explanation</a></p> <p><a href="https://github.com/karpathy/nanoGPT/pull/246/commits/5cc9bab7e2402caf69a00e9c38fc45517e958748">requirements.txt to run nano-gpt</a></p> <p><a href="https://github.com/karpathy/nanoGPT/pull/76">nano-gpt kv cache pr example</a></p> <p><a href="https://github.com/huggingface/transformers/blob/6bc0fbcfa7acb6ac4937e7456a76c2f7975fefec/src/transformers/modeling_outputs.py#L714">huggingface transformers kv cache source code on github</a></p> <p>https://zhuanlan.zhihu.com/p/646577898</p> <p>https://zhuanlan.zhihu.com/p/624740065</p> <p><a href="https://huggingface.co/docs/transformers/main_classes/output#transformers.modeling_outputs.CausalLMOutputWithPast">huggingface transformers API documentation</a></p>]]></content><author><name></name></author><category term="ml"/><category term="llm"/><category term="ml"/><category term="llm"/><summary type="html"><![CDATA[1. Run basic nano-gpt]]></summary></entry><entry><title type="html">Set up vim in vscode</title><link href="https://bilyz98.github.io/blog/2025/set-up-vim-in-vscode/" rel="alternate" type="text/html" title="Set up vim in vscode"/><published>2025-01-17T11:59:00+00:00</published><updated>2025-01-17T11:59:00+00:00</updated><id>https://bilyz98.github.io/blog/2025/set-up-vim-in-vscode</id><content type="html" xml:base="https://bilyz98.github.io/blog/2025/set-up-vim-in-vscode/"><![CDATA[<h2 id="why-move-to-vscode">Why move to vscode?</h2> <p>Because I want to use copilot in vscode to do code auto complete or function update for many lines at the same time.</p> <p>I use neovim vscode which uses native neovim instead of doing simulation. However, I am not sure if all neovim plugin can be used in vscode or not. I found whichkey on vscode and it works quite well.</p> <p>Not sure if <code class="language-plaintext highlighter-rouge">lazy</code> and telescope can work well at the same time but it does not matter a lot. I can use vscode builtin search to do searching.</p> <h2 id="move-between-editor-and-terminal">Move between editor and terminal</h2> <p><code class="language-plaintext highlighter-rouge">ctrl+\</code>` to move to terminal and toggle/close the terminal window. This is default settings from vscode</p> <p><code class="language-plaintext highlighter-rouge">ctrl+1</code> to move to first editor buffer.</p> <p>check out this stackoverflow for more. <a href="https://stackoverflow.com/questions/42796887/switch-focus-between-editor-and-integrated-terminal">https://stackoverflow.com/questions/42796887/switch-focus-between-editor-and-integrated-terminal</a></p> <h2 id="settingsjson-configuration">settings.json configuration</h2> <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="nl">"workbench.colorTheme"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Default Dark Modern"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"svg.preview.mode"</span><span class="p">:</span><span class="w"> </span><span class="s2">"svg"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"remote.SSH.enableRemoteCommand"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
    </span><span class="nl">"remote.SSH.remotePlatform"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nl">"ctb"</span><span class="p">:</span><span class="w"> </span><span class="s2">"linux"</span><span class="p">,</span><span class="w">
        </span><span class="nl">"th2k"</span><span class="p">:</span><span class="w"> </span><span class="s2">"linux"</span><span class="w">
    </span><span class="p">},</span><span class="w">

    </span><span class="nl">"Codegeex.License"</span><span class="p">:</span><span class="w"> </span><span class="s2">""</span><span class="p">,</span><span class="w">
    </span><span class="nl">"Codegeex.Privacy"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w">
    </span><span class="nl">"extensions.experimental.affinity"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nl">"asvetliakov.vscode-neovim"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="err">//</span><span class="w"> </span><span class="nl">"vscode-neovim.neovimInitVimPaths.win32"</span><span class="p">:</span><span class="w"> </span><span class="s2">"C:</span><span class="se">\\</span><span class="s2">Users</span><span class="se">\\</span><span class="s2">zhutaozhuang</span><span class="se">\\</span><span class="s2">nvim_config</span><span class="se">\\</span><span class="s2">init.lua"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"vim.neovimConfigPath"</span><span class="p">:</span><span class="w"> </span><span class="s2">"C:</span><span class="se">\\</span><span class="s2">Users</span><span class="se">\\</span><span class="s2">zhutaozhuang</span><span class="se">\\</span><span class="s2">nvim_config</span><span class="se">\\</span><span class="s2">init.lua"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"vim.neovimPath"</span><span class="p">:</span><span class="w"> </span><span class="s2">"C:</span><span class="se">\\</span><span class="s2">Program Files</span><span class="se">\\</span><span class="s2">Neovim</span><span class="se">\\</span><span class="s2">bin</span><span class="se">\\</span><span class="s2">nvim.exe"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"vim.enableNeovim"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
    </span><span class="nl">"vim.neovimUseConfigFile"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
    </span><span class="nl">"vscode-neovim.neovimInitVimPaths.win32"</span><span class="p">:</span><span class="w"> </span><span class="s2">"C:</span><span class="se">\\</span><span class="s2">Users</span><span class="se">\\</span><span class="s2">zhutaozhuang</span><span class="se">\\</span><span class="s2">nvim_config</span><span class="se">\\</span><span class="s2">init.lua"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"terminal.integrated.sendKeybindingsToShell"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
    </span><span class="nl">"accessibility.verbosity.keybindingsEditor"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w">
    </span><span class="nl">"workbench.settings.openDefaultKeybindings"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
    </span><span class="nl">"workbench.activityBar.location"</span><span class="p">:</span><span class="w"> </span><span class="s2">"hidden"</span><span class="p">,</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div> <h2 id="keybindingsjson">keybindings.json</h2> <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">//</span><span class="w"> </span><span class="err">Place</span><span class="w"> </span><span class="err">your</span><span class="w"> </span><span class="err">key</span><span class="w"> </span><span class="err">bindings</span><span class="w"> </span><span class="err">in</span><span class="w"> </span><span class="err">this</span><span class="w"> </span><span class="err">file</span><span class="w"> </span><span class="err">to</span><span class="w"> </span><span class="err">override</span><span class="w"> </span><span class="err">the</span><span class="w"> </span><span class="err">defaults</span><span class="w">
</span><span class="p">[</span><span class="w">
    </span><span class="p">{</span><span class="w">
        </span><span class="nl">"key"</span><span class="p">:</span><span class="w"> </span><span class="s2">"ctrl+j"</span><span class="p">,</span><span class="w">
        </span><span class="nl">"command"</span><span class="p">:</span><span class="w"> </span><span class="s2">"workbench.action.navigateBackInEditLocations"</span><span class="p">,</span><span class="w">
        </span><span class="err">//</span><span class="w"> </span><span class="nl">"command"</span><span class="p">:</span><span class="w"> </span><span class="s2">"workbench.action.quickOpenNavigatePrevious"</span><span class="p">,</span><span class="w">
        </span><span class="nl">"when"</span><span class="p">:</span><span class="w"> </span><span class="s2">"editorFocus"</span><span class="w">
        </span><span class="err">//</span><span class="w"> </span><span class="nl">"when"</span><span class="p">:</span><span class="w"> </span><span class="s2">"inQuickOpen"</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="p">{</span><span class="w">
        </span><span class="nl">"key"</span><span class="p">:</span><span class="w"> </span><span class="s2">"ctrl+q"</span><span class="p">,</span><span class="w">
        </span><span class="nl">"command"</span><span class="p">:</span><span class="w"> </span><span class="s2">"workbench.action.closeEditorsInGroup"</span><span class="p">,</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="err">//</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="err">//</span><span class="w">     </span><span class="nl">"key"</span><span class="p">:</span><span class="w">     </span><span class="s2">"ctrl+`"</span><span class="p">,</span><span class="w">
    </span><span class="err">//</span><span class="w">     </span><span class="nl">"command"</span><span class="p">:</span><span class="w"> </span><span class="s2">"workbench.action.terminal.focus"</span><span class="w">
    </span><span class="err">//</span><span class="w"> </span><span class="p">},</span><span class="w">
    </span><span class="err">//</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="err">//</span><span class="w">     </span><span class="nl">"key"</span><span class="p">:</span><span class="w">     </span><span class="s2">"ctrl+`"</span><span class="p">,</span><span class="w">
    </span><span class="err">//</span><span class="w">     </span><span class="nl">"command"</span><span class="p">:</span><span class="w"> </span><span class="s2">"workbench.action.focusActiveEditorGroup"</span><span class="p">,</span><span class="w">
    </span><span class="err">//</span><span class="w">     </span><span class="nl">"when"</span><span class="p">:</span><span class="w">    </span><span class="s2">"terminalFocus"</span><span class="w">
    </span><span class="err">//</span><span class="w"> </span><span class="p">},</span><span class="w">
    </span><span class="err">//</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="err">//</span><span class="w">     </span><span class="nl">"key"</span><span class="p">:</span><span class="w"> </span><span class="s2">"ctrl+]"</span><span class="p">,</span><span class="w">
    </span><span class="err">//</span><span class="w">     </span><span class="nl">"command"</span><span class="p">:</span><span class="w"> </span><span class="s2">"workbench.action.terminal.clear"</span><span class="p">,</span><span class="w">
    </span><span class="err">//</span><span class="w">     </span><span class="err">//</span><span class="w"> </span><span class="nl">"command"</span><span class="p">:</span><span class="w"> </span><span class="s2">"workbench.action.terminal.toggleTerminal"</span><span class="p">,</span><span class="w">

    </span><span class="err">//</span><span class="w">      </span><span class="nl">"when"</span><span class="p">:</span><span class="w"> </span><span class="s2">"terminal.active"</span><span class="w"> 
    </span><span class="err">//</span><span class="w"> </span><span class="p">}</span><span class="w">

    </span><span class="err">/*</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nl">"command"</span><span class="p">:</span><span class="w"> </span><span class="s2">"vscode-neovim.compositeEscape1"</span><span class="p">,</span><span class="w">
        </span><span class="nl">"key"</span><span class="p">:</span><span class="w"> </span><span class="s2">"j"</span><span class="p">,</span><span class="w">
        </span><span class="nl">"when"</span><span class="p">:</span><span class="w"> </span><span class="s2">"neovim.mode == insert &amp;&amp; editorTextFocus"</span><span class="p">,</span><span class="w">
        </span><span class="nl">"args"</span><span class="p">:</span><span class="w"> </span><span class="s2">"j"</span><span class="w">

    </span><span class="p">}</span><span class="w"> </span><span class="err">*/</span><span class="w">
</span><span class="p">]</span><span class="w">
</span></code></pre></div></div> <h2 id="initlua-configuration">init.lua configuration</h2> <div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">vim</span><span class="p">.</span><span class="n">g</span><span class="p">.</span><span class="n">vscode</span> <span class="k">then</span>
    <span class="c1">-- VSCode extension</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"Running in VSCode"</span><span class="p">)</span>
    <span class="c1">-- set leader key to space</span>
    <span class="n">vim</span><span class="p">.</span><span class="n">g</span><span class="p">.</span><span class="n">mapleader</span> <span class="o">=</span> <span class="s1">' '</span>

    <span class="n">vim</span><span class="p">.</span><span class="n">cmd</span><span class="p">(</span><span class="s1">'nmap &lt;leader&gt;c :e C:\\Users\\zhutaozhuang\\nvim_config\\init.lua&lt;cr&gt;'</span><span class="p">)</span>
    
    <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="s1">'n'</span><span class="p">,</span> <span class="s1">'&lt;Esc&gt;'</span><span class="p">,</span> <span class="s1">':nohlsearch&lt;CR&gt;'</span><span class="p">,</span> <span class="p">{</span> <span class="n">noremap</span> <span class="o">=</span> <span class="kc">true</span><span class="p">,</span> <span class="n">silent</span> <span class="o">=</span> <span class="kc">true</span> <span class="p">})</span>
    
    <span class="c1">-- go to left side buffer </span>
    <span class="c1">-- vim.keymap.set('n', '&lt;S-h&gt;', '', { noremap = true, silent = true })</span>
    <span class="c1">-- vim.keymap.set('n', '&lt;S-l&gt;', ':bnext', { noremap = true, silent = true })</span>
    <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="s1">'n'</span><span class="p">,</span> <span class="s1">'&lt;S-h&gt;'</span><span class="p">,</span> <span class="s1">':bprevious&lt;CR&gt;'</span><span class="p">,</span> <span class="p">{</span> <span class="n">noremap</span> <span class="o">=</span> <span class="kc">true</span><span class="p">,</span> <span class="n">silent</span> <span class="o">=</span> <span class="kc">true</span> <span class="p">})</span>
    <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="s1">'n'</span><span class="p">,</span> <span class="s1">'&lt;S-l&gt;'</span><span class="p">,</span> <span class="s1">':bnext&lt;CR&gt;'</span><span class="p">,</span> <span class="p">{</span> <span class="n">noremap</span> <span class="o">=</span> <span class="kc">true</span><span class="p">,</span> <span class="n">silent</span> <span class="o">=</span> <span class="kc">true</span> <span class="p">})</span>
    <span class="c1">-- vim.keymap.set('n', '&lt;S-h&gt;', '^', { noremap = true, silent = true })</span>
    <span class="c1">-- vim.keymap.set('n', '&lt;S-l&gt;', '$', { noremap = true, silent = true })</span>
    <span class="c1">--</span>
    <span class="c1">-- go to right window with Ctrl-l</span>
    <span class="n">vim</span><span class="p">.</span><span class="n">api</span><span class="p">.</span><span class="n">nvim_set_keymap</span><span class="p">(</span><span class="s1">'n'</span><span class="p">,</span> <span class="s1">'&lt;C-l&gt;'</span><span class="p">,</span> <span class="s1">':call VSCodeNotify("workbench.action.navigateRight")&lt;CR&gt;'</span><span class="p">,</span> <span class="p">{</span> <span class="n">noremap</span> <span class="o">=</span> <span class="kc">true</span><span class="p">,</span> <span class="n">silent</span> <span class="o">=</span> <span class="kc">true</span> <span class="p">})</span>
    <span class="n">vim</span><span class="p">.</span><span class="n">api</span><span class="p">.</span><span class="n">nvim_set_keymap</span><span class="p">(</span><span class="s1">'n'</span><span class="p">,</span> <span class="s1">'&lt;C-h&gt;'</span><span class="p">,</span> <span class="s1">':call VSCodeNotify("workbench.action.navigateLeft")&lt;CR&gt;'</span><span class="p">,</span> <span class="p">{</span> <span class="n">noremap</span> <span class="o">=</span> <span class="kc">true</span><span class="p">,</span> <span class="n">silent</span> <span class="o">=</span> <span class="kc">true</span> <span class="p">})</span>


    <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="s1">'n'</span><span class="p">,</span> <span class="s1">'&lt;ctrl-q&gt;'</span><span class="p">,</span> <span class="s1">':q&lt;CR&gt;'</span><span class="p">,</span> <span class="p">{</span> <span class="n">noremap</span> <span class="o">=</span> <span class="kc">true</span><span class="p">,</span> <span class="n">silent</span> <span class="o">=</span> <span class="kc">true</span> <span class="p">})</span>

    <span class="n">vim</span><span class="p">.</span><span class="n">opt</span><span class="p">.</span><span class="n">ignorecase</span> <span class="o">=</span> <span class="kc">true</span>

    <span class="c1">-- search file after pressing f after pressing leader key, use vscode command</span>
    

    <span class="kd">local</span> <span class="n">whichkey</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">show</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"whichkey.show"</span><span class="p">)</span>
        <span class="k">end</span>
      <span class="p">}</span>
      
      <span class="kd">local</span> <span class="n">comment</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">selected</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotifyRange</span><span class="p">(</span><span class="s2">"editor.action.commentLine"</span><span class="p">,</span> <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">line</span><span class="p">(</span><span class="s2">"v"</span><span class="p">),</span> <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">line</span><span class="p">(</span><span class="s2">"."</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">end</span>
      <span class="p">}</span>
      
      <span class="kd">local</span> <span class="n">file</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">new</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"workbench.explorer.fileView.focus"</span><span class="p">)</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"explorer.newFile"</span><span class="p">)</span>
        <span class="k">end</span><span class="p">,</span>
      
        <span class="n">save</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"workbench.action.files.save"</span><span class="p">)</span>
        <span class="k">end</span><span class="p">,</span>
      
        <span class="n">saveAll</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"workbench.action.files.saveAll"</span><span class="p">)</span>
        <span class="k">end</span><span class="p">,</span>
      
        <span class="n">format</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"editor.action.formatDocument"</span><span class="p">)</span>
        <span class="k">end</span><span class="p">,</span>
      
        <span class="n">showInExplorer</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"workbench.files.action.showActiveFileInExplorer"</span><span class="p">)</span>
        <span class="k">end</span><span class="p">,</span>
      
        <span class="n">rename</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"workbench.files.action.showActiveFileInExplorer"</span><span class="p">)</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"renameFile"</span><span class="p">)</span>
        <span class="k">end</span>
      <span class="p">}</span>
      
      <span class="kd">local</span> <span class="nb">error</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">list</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"workbench.actions.view.problems"</span><span class="p">)</span>
        <span class="k">end</span><span class="p">,</span>
        <span class="nb">next</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"editor.action.marker.next"</span><span class="p">)</span>
        <span class="k">end</span><span class="p">,</span>
        <span class="n">previous</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"editor.action.marker.prev"</span><span class="p">)</span>
        <span class="k">end</span><span class="p">,</span>
      <span class="p">}</span>
      
      <span class="kd">local</span> <span class="n">editor</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">closeActive</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"workbench.action.closeActiveEditor"</span><span class="p">)</span>
        <span class="k">end</span><span class="p">,</span>
      
        <span class="n">closeOther</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"workbench.action.closeOtherEditors"</span><span class="p">)</span>
        <span class="k">end</span><span class="p">,</span>
      
        <span class="n">organizeImport</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"editor.action.organizeImports"</span><span class="p">)</span>
        <span class="k">end</span>
      <span class="p">}</span>
      
      <span class="kd">local</span> <span class="n">workbench</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">showCommands</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"workbench.action.showCommands"</span><span class="p">)</span>
        <span class="k">end</span><span class="p">,</span>
        <span class="n">previousEditor</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"workbench.action.previousEditor"</span><span class="p">)</span>
        <span class="k">end</span><span class="p">,</span>
        <span class="n">nextEditor</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"workbench.action.nextEditor"</span><span class="p">)</span>
        <span class="k">end</span><span class="p">,</span>
      <span class="p">}</span>
      
      <span class="kd">local</span> <span class="n">terminal</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">toggle_panel</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"workbench.action.terminal.toggleTerminal"</span><span class="p">)</span>
        <span class="k">end</span><span class="p">,</span>
      <span class="p">}</span>
      
      <span class="kd">local</span> <span class="n">toggle</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">toggleActivityBar</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"workbench.action.toggleActivityBarVisibility"</span><span class="p">)</span>
        <span class="k">end</span><span class="p">,</span>
        <span class="n">toggleSideBarVisibility</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"workbench.action.toggleSidebarVisibility"</span><span class="p">)</span>
        <span class="k">end</span><span class="p">,</span>
        <span class="n">toggleZenMode</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"workbench.action.toggleZenMode"</span><span class="p">)</span>
        <span class="k">end</span><span class="p">,</span>
        <span class="n">theme</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"workbench.action.selectTheme"</span><span class="p">)</span>
        <span class="k">end</span><span class="p">,</span>
      <span class="p">}</span>
      
      <span class="kd">local</span> <span class="n">symbol</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">rename</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"editor.action.rename"</span><span class="p">)</span>
        <span class="k">end</span><span class="p">,</span>
      <span class="p">}</span>
      
      <span class="c1">-- if bookmark extension is used</span>
      <span class="kd">local</span> <span class="n">bookmark</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">toggle</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"bookmarks.toggle"</span><span class="p">)</span>
        <span class="k">end</span><span class="p">,</span>
        <span class="n">list</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"bookmarks.list"</span><span class="p">)</span>
        <span class="k">end</span><span class="p">,</span>
        <span class="n">previous</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"bookmarks.jumpToPrevious"</span><span class="p">)</span>
        <span class="k">end</span><span class="p">,</span>
        <span class="nb">next</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"bookmarks.jumpToNext"</span><span class="p">)</span>
        <span class="k">end</span><span class="p">,</span>
      <span class="p">}</span>
      
      <span class="kd">local</span> <span class="n">search</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">reference</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"editor.action.referenceSearch.trigger"</span><span class="p">)</span>
        <span class="k">end</span><span class="p">,</span>
        <span class="n">referenceInSideBar</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"references-view.find"</span><span class="p">)</span>
        <span class="k">end</span><span class="p">,</span>
        <span class="n">project</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"editor.action.addSelectionToNextFindMatch"</span><span class="p">)</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"workbench.action.findInFiles"</span><span class="p">)</span>
        <span class="k">end</span><span class="p">,</span>
        <span class="n">text</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"workbench.action.findInFiles"</span><span class="p">)</span>
        <span class="k">end</span><span class="p">,</span>
      <span class="p">}</span>
      
      <span class="kd">local</span> <span class="n">project</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">findFile</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"workbench.action.quickOpen"</span><span class="p">)</span>
        <span class="k">end</span><span class="p">,</span>
        <span class="n">switch</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"workbench.action.openRecent"</span><span class="p">)</span>
        <span class="k">end</span><span class="p">,</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"workbench.view.explorer"</span><span class="p">)</span>
        <span class="k">end</span><span class="p">,</span>
      <span class="p">}</span>
      
      <span class="kd">local</span> <span class="n">git</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">init</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"git.init"</span><span class="p">)</span>
        <span class="k">end</span><span class="p">,</span>
        <span class="n">status</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"workbench.view.scm"</span><span class="p">)</span>
        <span class="k">end</span><span class="p">,</span>
        <span class="n">switch</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"git.checkout"</span><span class="p">)</span>
        <span class="k">end</span><span class="p">,</span>
        <span class="n">deleteBranch</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"git.deleteBranch"</span><span class="p">)</span>
        <span class="k">end</span><span class="p">,</span>
        <span class="n">push</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"git.push"</span><span class="p">)</span>
        <span class="k">end</span><span class="p">,</span>
        <span class="n">pull</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"git.pull"</span><span class="p">)</span>
        <span class="k">end</span><span class="p">,</span>
        <span class="n">fetch</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"git.fetch"</span><span class="p">)</span>
        <span class="k">end</span><span class="p">,</span>
        <span class="n">commit</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"git.commit"</span><span class="p">)</span>
        <span class="k">end</span><span class="p">,</span>
        <span class="n">publish</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"git.publish"</span><span class="p">)</span>
        <span class="k">end</span><span class="p">,</span>
      
        <span class="c1">-- if gitlens installed</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"gitlens.showGraphPage"</span><span class="p">)</span>
        <span class="k">end</span><span class="p">,</span>
      <span class="p">}</span>
      
      <span class="kd">local</span> <span class="n">fold</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">toggle</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"editor.toggleFold"</span><span class="p">)</span>
        <span class="k">end</span><span class="p">,</span>
      
        <span class="n">all</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"editor.foldAll"</span><span class="p">)</span>
        <span class="k">end</span><span class="p">,</span>
        <span class="n">openAll</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"editor.unfoldAll"</span><span class="p">)</span>
        <span class="k">end</span><span class="p">,</span>
      
        <span class="n">close</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"editor.fold"</span><span class="p">)</span>
        <span class="k">end</span><span class="p">,</span>
        <span class="n">open</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"editor.unfold"</span><span class="p">)</span>
        <span class="k">end</span><span class="p">,</span>
        <span class="n">openRecursive</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"editor.unfoldRecursively"</span><span class="p">)</span>
        <span class="k">end</span><span class="p">,</span>
      
        <span class="n">blockComment</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"editor.foldAllBlockComments"</span><span class="p">)</span>
        <span class="k">end</span><span class="p">,</span>
      
        <span class="n">allMarkerRegion</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"editor.foldAllMarkerRegions"</span><span class="p">)</span>
        <span class="k">end</span><span class="p">,</span>
        <span class="n">openAllMarkerRegion</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"editor.unfoldAllMarkerRegions"</span><span class="p">)</span>
        <span class="k">end</span><span class="p">,</span>
      <span class="p">}</span>
      
      <span class="kd">local</span> <span class="n">vscode</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">focusEditor</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"workbench.action.focusActiveEditorGroup"</span><span class="p">)</span>
        <span class="k">end</span><span class="p">,</span>
        <span class="n">moveSideBarRight</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"workbench.action.moveSideBarRight"</span><span class="p">)</span>
        <span class="k">end</span><span class="p">,</span>
        <span class="n">moveSideBarLeft</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"workbench.action.moveSideBarLeft"</span><span class="p">)</span>
        <span class="k">end</span><span class="p">,</span>
      <span class="p">}</span>
      
      <span class="kd">local</span> <span class="n">refactor</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">showMenu</span> <span class="o">=</span> <span class="k">function</span><span class="p">()</span>
          <span class="n">vim</span><span class="p">.</span><span class="n">fn</span><span class="p">.</span><span class="n">VSCodeNotify</span><span class="p">(</span><span class="s2">"editor.action.refactor"</span><span class="p">)</span>
        <span class="k">end</span><span class="p">,</span>
      <span class="p">}</span>
      
      <span class="c1">-- https://vi.stackexchange.com/a/31887</span>
      <span class="kd">local</span> <span class="n">nv_keymap</span> <span class="o">=</span> <span class="k">function</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>
        <span class="n">vim</span><span class="p">.</span><span class="n">api</span><span class="p">.</span><span class="n">nvim_set_keymap</span><span class="p">(</span><span class="s1">'n'</span><span class="p">,</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="p">{</span> <span class="n">noremap</span> <span class="o">=</span> <span class="kc">true</span><span class="p">,</span> <span class="n">silent</span> <span class="o">=</span> <span class="kc">true</span> <span class="p">})</span>
        <span class="n">vim</span><span class="p">.</span><span class="n">api</span><span class="p">.</span><span class="n">nvim_set_keymap</span><span class="p">(</span><span class="s1">'v'</span><span class="p">,</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="p">{</span> <span class="n">noremap</span> <span class="o">=</span> <span class="kc">true</span><span class="p">,</span> <span class="n">silent</span> <span class="o">=</span> <span class="kc">true</span> <span class="p">})</span>
      <span class="k">end</span>
      
      <span class="kd">local</span> <span class="n">nx_keymap</span> <span class="o">=</span> <span class="k">function</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>
        <span class="n">vim</span><span class="p">.</span><span class="n">api</span><span class="p">.</span><span class="n">nvim_set_keymap</span><span class="p">(</span><span class="s1">'n'</span><span class="p">,</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="p">{</span> <span class="n">silent</span> <span class="o">=</span> <span class="kc">true</span> <span class="p">})</span>
        <span class="n">vim</span><span class="p">.</span><span class="n">api</span><span class="p">.</span><span class="n">nvim_set_keymap</span><span class="p">(</span><span class="s1">'v'</span><span class="p">,</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="p">{</span> <span class="n">silent</span> <span class="o">=</span> <span class="kc">true</span> <span class="p">})</span>
      <span class="k">end</span>
      
      <span class="c1">--#region keymap</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">g</span><span class="p">.</span><span class="n">mapleader</span> <span class="o">=</span> <span class="s2">" "</span>
      
      <span class="n">nv_keymap</span><span class="p">(</span><span class="s1">'s'</span><span class="p">,</span> <span class="s1">'}'</span><span class="p">)</span>
      <span class="n">nv_keymap</span><span class="p">(</span><span class="s1">'S'</span><span class="p">,</span> <span class="s1">'{'</span><span class="p">)</span>
      
      <span class="n">nv_keymap</span><span class="p">(</span><span class="s1">'&lt;leader&gt;h'</span><span class="p">,</span> <span class="s1">'^'</span><span class="p">)</span>
      <span class="n">nv_keymap</span><span class="p">(</span><span class="s1">'&lt;leader&gt;l'</span><span class="p">,</span> <span class="s1">'$'</span><span class="p">)</span>
      <span class="n">nv_keymap</span><span class="p">(</span><span class="s1">'&lt;leader&gt;a'</span><span class="p">,</span> <span class="s1">'%'</span><span class="p">)</span>
      
      <span class="n">nx_keymap</span><span class="p">(</span><span class="s1">'j'</span><span class="p">,</span> <span class="s1">'gj'</span><span class="p">)</span>
      <span class="n">nx_keymap</span><span class="p">(</span><span class="s1">'k'</span><span class="p">,</span> <span class="s1">'gk'</span><span class="p">)</span>
      
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span><span class="p">,</span> <span class="s1">'v'</span> <span class="p">},</span> <span class="s2">"&lt;leader&gt;"</span><span class="p">,</span> <span class="n">whichkey</span><span class="p">.</span><span class="n">show</span><span class="p">)</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span><span class="p">,</span> <span class="s1">'v'</span> <span class="p">},</span> <span class="s2">"&lt;leader&gt;/"</span><span class="p">,</span> <span class="n">comment</span><span class="p">.</span><span class="n">selected</span><span class="p">)</span>
      
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span> <span class="p">},</span> <span class="s2">"&lt;leader&gt;i"</span><span class="p">,</span> <span class="n">editor</span><span class="p">.</span><span class="n">organizeImport</span><span class="p">)</span>
      
      <span class="c1">-- no highlight</span>
      <span class="c1">-- vim.keymap.set({ 'n' }, "&lt;leader&gt;n", "&lt;cmd&gt;noh&lt;cr&gt;")</span>
      
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span><span class="p">,</span> <span class="s1">'v'</span> <span class="p">},</span> <span class="s2">"&lt;leader&gt; "</span><span class="p">,</span> <span class="n">workbench</span><span class="p">.</span><span class="n">showCommands</span><span class="p">)</span>
      
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span><span class="p">,</span> <span class="s1">'v'</span> <span class="p">},</span> <span class="s2">"H"</span><span class="p">,</span> <span class="n">workbench</span><span class="p">.</span><span class="n">previousEditor</span><span class="p">)</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span><span class="p">,</span> <span class="s1">'v'</span> <span class="p">},</span> <span class="s2">"L"</span><span class="p">,</span> <span class="n">workbench</span><span class="p">.</span><span class="n">nextEditor</span><span class="p">)</span>
      
      <span class="c1">-- error</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span> <span class="p">},</span> <span class="s2">"&lt;leader&gt;el"</span><span class="p">,</span> <span class="n">error</span><span class="p">.</span><span class="n">list</span><span class="p">)</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span> <span class="p">},</span> <span class="s2">"&lt;leader&gt;en"</span><span class="p">,</span> <span class="n">error</span><span class="p">.</span><span class="n">next</span><span class="p">)</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span> <span class="p">},</span> <span class="s2">"&lt;leader&gt;ep"</span><span class="p">,</span> <span class="n">error</span><span class="p">.</span><span class="n">previous</span><span class="p">)</span>
      
      <span class="c1">-- git</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span> <span class="p">},</span> <span class="s2">"&lt;leader&gt;gb"</span><span class="p">,</span> <span class="n">git</span><span class="p">.</span><span class="n">switch</span><span class="p">)</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span> <span class="p">},</span> <span class="s2">"&lt;leader&gt;gi"</span><span class="p">,</span> <span class="n">git</span><span class="p">.</span><span class="n">init</span><span class="p">)</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span> <span class="p">},</span> <span class="s2">"&lt;leader&gt;gd"</span><span class="p">,</span> <span class="n">git</span><span class="p">.</span><span class="n">deleteBranch</span><span class="p">)</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span> <span class="p">},</span> <span class="s2">"&lt;leader&gt;gf"</span><span class="p">,</span> <span class="n">git</span><span class="p">.</span><span class="n">fetch</span><span class="p">)</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span> <span class="p">},</span> <span class="s2">"&lt;leader&gt;gs"</span><span class="p">,</span> <span class="n">git</span><span class="p">.</span><span class="n">status</span><span class="p">)</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span> <span class="p">},</span> <span class="s2">"&lt;leader&gt;gp"</span><span class="p">,</span> <span class="n">git</span><span class="p">.</span><span class="n">pull</span><span class="p">)</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span> <span class="p">},</span> <span class="s2">"&lt;leader&gt;gg"</span><span class="p">,</span> <span class="n">git</span><span class="p">.</span><span class="n">graph</span><span class="p">)</span>
      
      <span class="c1">-- project</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span> <span class="p">},</span> <span class="s2">"&lt;leader&gt;f"</span><span class="p">,</span> <span class="n">project</span><span class="p">.</span><span class="n">findFile</span><span class="p">)</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span> <span class="p">},</span> <span class="s2">"&lt;leader&gt;pp"</span><span class="p">,</span> <span class="n">project</span><span class="p">.</span><span class="n">switch</span><span class="p">)</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span> <span class="p">},</span> <span class="s2">"&lt;leader&gt;pt"</span><span class="p">,</span> <span class="n">project</span><span class="p">.</span><span class="n">tree</span><span class="p">)</span>
      
      <span class="c1">-- file</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span><span class="p">,</span> <span class="s1">'v'</span> <span class="p">},</span> <span class="s2">"&lt;space&gt;w"</span><span class="p">,</span> <span class="n">file</span><span class="p">.</span><span class="n">save</span><span class="p">)</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span><span class="p">,</span> <span class="s1">'v'</span> <span class="p">},</span> <span class="s2">"&lt;space&gt;wa"</span><span class="p">,</span> <span class="n">file</span><span class="p">.</span><span class="n">saveAll</span><span class="p">)</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span><span class="p">,</span> <span class="s1">'v'</span> <span class="p">},</span> <span class="s2">"&lt;space&gt;fs"</span><span class="p">,</span> <span class="n">file</span><span class="p">.</span><span class="n">save</span><span class="p">)</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span><span class="p">,</span> <span class="s1">'v'</span> <span class="p">},</span> <span class="s2">"&lt;space&gt;fS"</span><span class="p">,</span> <span class="n">file</span><span class="p">.</span><span class="n">saveAll</span><span class="p">)</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span> <span class="p">},</span> <span class="s2">"&lt;space&gt;ff"</span><span class="p">,</span> <span class="n">file</span><span class="p">.</span><span class="n">format</span><span class="p">)</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span> <span class="p">},</span> <span class="s2">"&lt;space&gt;fn"</span><span class="p">,</span> <span class="n">file</span><span class="p">.</span><span class="n">new</span><span class="p">)</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span> <span class="p">},</span> <span class="s2">"&lt;space&gt;ft"</span><span class="p">,</span> <span class="n">file</span><span class="p">.</span><span class="n">showInExplorer</span><span class="p">)</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span> <span class="p">},</span> <span class="s2">"&lt;space&gt;fr"</span><span class="p">,</span> <span class="n">file</span><span class="p">.</span><span class="n">rename</span><span class="p">)</span>
      
      <span class="c1">-- buffer/editor</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span><span class="p">,</span> <span class="s1">'v'</span> <span class="p">},</span> <span class="s2">"&lt;space&gt;c"</span><span class="p">,</span> <span class="n">editor</span><span class="p">.</span><span class="n">closeActive</span><span class="p">)</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span><span class="p">,</span> <span class="s1">'v'</span> <span class="p">},</span> <span class="s2">"&lt;space&gt;bc"</span><span class="p">,</span> <span class="n">editor</span><span class="p">.</span><span class="n">closeActive</span><span class="p">)</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span><span class="p">,</span> <span class="s1">'v'</span> <span class="p">},</span> <span class="s2">"&lt;space&gt;k"</span><span class="p">,</span> <span class="n">editor</span><span class="p">.</span><span class="n">closeOther</span><span class="p">)</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span><span class="p">,</span> <span class="s1">'v'</span> <span class="p">},</span> <span class="s2">"&lt;space&gt;bk"</span><span class="p">,</span> <span class="n">editor</span><span class="p">.</span><span class="n">closeOther</span><span class="p">)</span>
      
      <span class="c1">-- toggle</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span><span class="p">,</span> <span class="s1">'v'</span> <span class="p">},</span> <span class="s2">"&lt;leader&gt;ta"</span><span class="p">,</span> <span class="n">toggle</span><span class="p">.</span><span class="n">toggleActivityBar</span><span class="p">)</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span><span class="p">,</span> <span class="s1">'v'</span> <span class="p">},</span> <span class="s2">"&lt;leader&gt;tz"</span><span class="p">,</span> <span class="n">toggle</span><span class="p">.</span><span class="n">toggleZenMode</span><span class="p">)</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span><span class="p">,</span> <span class="s1">'v'</span> <span class="p">},</span> <span class="s2">"&lt;leader&gt;ts"</span><span class="p">,</span> <span class="n">toggle</span><span class="p">.</span><span class="n">toggleSideBarVisibility</span><span class="p">)</span>
      <span class="c1">-- vim.keymap.set({ 'n', 'v' }, "&lt;leader&gt;tt", toggle.theme)</span>
      <span class="c1">-- </span>

      <span class="c1">-- toggle terminal</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span><span class="p">,</span> <span class="s1">'v'</span> <span class="p">},</span> <span class="s2">"&lt;leader&gt;tt"</span><span class="p">,</span> <span class="n">terminal</span><span class="p">.</span><span class="n">toggle_panel</span><span class="p">)</span>
      
      <span class="c1">-- refactor</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'v'</span> <span class="p">},</span> <span class="s2">"&lt;leader&gt;r"</span><span class="p">,</span> <span class="n">refactor</span><span class="p">.</span><span class="n">showMenu</span><span class="p">)</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span> <span class="p">},</span> <span class="s2">"&lt;leader&gt;rr"</span><span class="p">,</span> <span class="n">symbol</span><span class="p">.</span><span class="n">rename</span><span class="p">)</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">api</span><span class="p">.</span><span class="n">nvim_set_keymap</span><span class="p">(</span><span class="s1">'n'</span><span class="p">,</span> <span class="s1">'&lt;leader&gt;rd'</span><span class="p">,</span> <span class="s1">'V%d'</span><span class="p">,</span> <span class="p">{</span> <span class="n">silent</span> <span class="o">=</span> <span class="kc">true</span> <span class="p">})</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">api</span><span class="p">.</span><span class="n">nvim_set_keymap</span><span class="p">(</span><span class="s1">'n'</span><span class="p">,</span> <span class="s1">'&lt;leader&gt;rv'</span><span class="p">,</span> <span class="s1">'V%'</span><span class="p">,</span> <span class="p">{</span> <span class="n">silent</span> <span class="o">=</span> <span class="kc">true</span> <span class="p">})</span>
      
      <span class="c1">-- bookmark</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span> <span class="p">},</span> <span class="s2">"&lt;leader&gt;m"</span><span class="p">,</span> <span class="n">bookmark</span><span class="p">.</span><span class="n">toggle</span><span class="p">)</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span> <span class="p">},</span> <span class="s2">"&lt;leader&gt;mt"</span><span class="p">,</span> <span class="n">bookmark</span><span class="p">.</span><span class="n">toggle</span><span class="p">)</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span> <span class="p">},</span> <span class="s2">"&lt;leader&gt;ml"</span><span class="p">,</span> <span class="n">bookmark</span><span class="p">.</span><span class="n">list</span><span class="p">)</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span> <span class="p">},</span> <span class="s2">"&lt;leader&gt;mn"</span><span class="p">,</span> <span class="n">bookmark</span><span class="p">.</span><span class="n">next</span><span class="p">)</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span> <span class="p">},</span> <span class="s2">"&lt;leader&gt;mp"</span><span class="p">,</span> <span class="n">bookmark</span><span class="p">.</span><span class="n">previous</span><span class="p">)</span>
      
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span> <span class="p">},</span> <span class="s2">"&lt;leader&gt;sr"</span><span class="p">,</span> <span class="n">search</span><span class="p">.</span><span class="n">reference</span><span class="p">)</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span> <span class="p">},</span> <span class="s2">"&lt;leader&gt;sR"</span><span class="p">,</span> <span class="n">search</span><span class="p">.</span><span class="n">referenceInSideBar</span><span class="p">)</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span> <span class="p">},</span> <span class="s2">"&lt;leader&gt;sp"</span><span class="p">,</span> <span class="n">search</span><span class="p">.</span><span class="n">project</span><span class="p">)</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span> <span class="p">},</span> <span class="s2">"&lt;leader&gt;st"</span><span class="p">,</span> <span class="n">search</span><span class="p">.</span><span class="n">text</span><span class="p">)</span>
      
      <span class="c1">-- vscode</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span> <span class="p">},</span> <span class="s2">"&lt;leader&gt;ve"</span><span class="p">,</span> <span class="n">vscode</span><span class="p">.</span><span class="n">focusEditor</span><span class="p">)</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span> <span class="p">},</span> <span class="s2">"&lt;leader&gt;vl"</span><span class="p">,</span> <span class="n">vscode</span><span class="p">.</span><span class="n">moveSideBarLeft</span><span class="p">)</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span> <span class="p">},</span> <span class="s2">"&lt;leader&gt;vr"</span><span class="p">,</span> <span class="n">vscode</span><span class="p">.</span><span class="n">moveSideBarRight</span><span class="p">)</span>
      
      <span class="c1">--folding</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span> <span class="p">},</span> <span class="s2">"&lt;leader&gt;zr"</span><span class="p">,</span> <span class="n">fold</span><span class="p">.</span><span class="n">openAll</span><span class="p">)</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span> <span class="p">},</span> <span class="s2">"&lt;leader&gt;zO"</span><span class="p">,</span> <span class="n">fold</span><span class="p">.</span><span class="n">openRecursive</span><span class="p">)</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span> <span class="p">},</span> <span class="s2">"&lt;leader&gt;zo"</span><span class="p">,</span> <span class="n">fold</span><span class="p">.</span><span class="n">open</span><span class="p">)</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span> <span class="p">},</span> <span class="s2">"&lt;leader&gt;zm"</span><span class="p">,</span> <span class="n">fold</span><span class="p">.</span><span class="n">all</span><span class="p">)</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span> <span class="p">},</span> <span class="s2">"&lt;leader&gt;zb"</span><span class="p">,</span> <span class="n">fold</span><span class="p">.</span><span class="n">blockComment</span><span class="p">)</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span> <span class="p">},</span> <span class="s2">"&lt;leader&gt;zc"</span><span class="p">,</span> <span class="n">fold</span><span class="p">.</span><span class="n">close</span><span class="p">)</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span> <span class="p">},</span> <span class="s2">"&lt;leader&gt;zg"</span><span class="p">,</span> <span class="n">fold</span><span class="p">.</span><span class="n">allMarkerRegion</span><span class="p">)</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span> <span class="p">},</span> <span class="s2">"&lt;leader&gt;zG"</span><span class="p">,</span> <span class="n">fold</span><span class="p">.</span><span class="n">openAllMarkerRegion</span><span class="p">)</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span> <span class="p">},</span> <span class="s2">"&lt;leader&gt;za"</span><span class="p">,</span> <span class="n">fold</span><span class="p">.</span><span class="n">toggle</span><span class="p">)</span>
      
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span> <span class="p">},</span> <span class="s2">"zr"</span><span class="p">,</span> <span class="n">fold</span><span class="p">.</span><span class="n">openAll</span><span class="p">)</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span> <span class="p">},</span> <span class="s2">"zO"</span><span class="p">,</span> <span class="n">fold</span><span class="p">.</span><span class="n">openRecursive</span><span class="p">)</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span> <span class="p">},</span> <span class="s2">"zo"</span><span class="p">,</span> <span class="n">fold</span><span class="p">.</span><span class="n">open</span><span class="p">)</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span> <span class="p">},</span> <span class="s2">"zm"</span><span class="p">,</span> <span class="n">fold</span><span class="p">.</span><span class="n">all</span><span class="p">)</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span> <span class="p">},</span> <span class="s2">"zb"</span><span class="p">,</span> <span class="n">fold</span><span class="p">.</span><span class="n">blockComment</span><span class="p">)</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span> <span class="p">},</span> <span class="s2">"zc"</span><span class="p">,</span> <span class="n">fold</span><span class="p">.</span><span class="n">close</span><span class="p">)</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span> <span class="p">},</span> <span class="s2">"zg"</span><span class="p">,</span> <span class="n">fold</span><span class="p">.</span><span class="n">allMarkerRegion</span><span class="p">)</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span> <span class="p">},</span> <span class="s2">"zG"</span><span class="p">,</span> <span class="n">fold</span><span class="p">.</span><span class="n">openAllMarkerRegion</span><span class="p">)</span>
      <span class="n">vim</span><span class="p">.</span><span class="n">keymap</span><span class="p">.</span><span class="n">set</span><span class="p">({</span> <span class="s1">'n'</span> <span class="p">},</span> <span class="s2">"za"</span><span class="p">,</span> <span class="n">fold</span><span class="p">.</span><span class="n">toggle</span><span class="p">)</span>
      <span class="c1">--#endregion keymap</span>
      
<span class="k">else</span>

    <span class="c1">-- ordinary Neovim</span>
    <span class="c1">-- set leader key to space</span>
    <span class="n">vim</span><span class="p">.</span><span class="n">g</span><span class="p">.</span><span class="n">mapleader</span> <span class="o">=</span> <span class="s2">" "</span>
    <span class="n">vim</span><span class="p">.</span><span class="n">g</span><span class="p">.</span><span class="n">maplocalleader</span> <span class="o">=</span> <span class="s2">" "</span>
    
    <span class="c1">-- search file after pressing f after pressing leader key, use Telescope</span>
    <span class="n">vim</span><span class="p">.</span><span class="n">api</span><span class="p">.</span><span class="n">nvim_set_keymap</span><span class="p">(</span><span class="s1">'n'</span><span class="p">,</span> <span class="s1">'&lt;leader&gt;f'</span><span class="p">,</span> <span class="s1">':Telescope find_files&lt;CR&gt;'</span><span class="p">,</span> <span class="p">{</span> <span class="n">noremap</span> <span class="o">=</span> <span class="kc">true</span><span class="p">,</span> <span class="n">silent</span> <span class="o">=</span> <span class="kc">true</span> <span class="p">})</span>
<span class="k">end</span>

</code></pre></div></div> <p>[ssh to remote node in vscode from wsl]https://stackoverflow.com/questions/60150466/can-i-ssh-from-wsl-in-visual-studio-code</p> <p><a href="https://github.com/sokhuong-uon/vscode-nvim/blob/main/init.lua">example init.lua for vscode nvm config</a></p> <p>https://www.youtube.com/watch?v=GST8we5uABo&amp;t=426s</p> <p>https://medium.com/@nikmas_dev/vscode-neovim-setup-keyboard-centric-powerful-reliable-clean-and-aesthetic-development-582d34297985</p> <p>https://www.youtube.com/watch?v=z64gxcKQSRI&amp;list=PLXDouhCU5r6qRE46qQ2rYIPnbJ5a9jzmd&amp;index=2</p> <p>https://www.youtube.com/watch?v=A5b2GxG-6do</p>]]></content><author><name></name></author><category term="development"/><category term="vscode"/><category term="vim"/><summary type="html"><![CDATA[Why move to vscode? Because I want to use copilot in vscode to do code auto complete or function update for many lines at the same time.]]></summary></entry><entry><title type="html">chibicc - Simple c compiler if statement</title><link href="https://bilyz98.github.io/blog/2025/chibicc-if-statement/" rel="alternate" type="text/html" title="chibicc - Simple c compiler if statement"/><published>2025-01-14T11:59:00+00:00</published><updated>2025-01-14T11:59:00+00:00</updated><id>https://bilyz98.github.io/blog/2025/chibicc-if-statement</id><content type="html" xml:base="https://bilyz98.github.io/blog/2025/chibicc-if-statement/"><![CDATA[<p><a href="https://github.com/BilyZ98/chibicc/commit/2f132cf8e68f0adf92bae038b75ea6da425e223c">Commit history for if statement feature</a></p> <h2 id="what-is-changed-">What is changed ?</h2> <p>For parser, new node type called <code class="language-plaintext highlighter-rouge">ND_IF</code> is introduced. Three new nodes are introduced for <code class="language-plaintext highlighter-rouge">Node</code> type in parser. They are called <code class="language-plaintext highlighter-rouge">cond</code>, <code class="language-plaintext highlighter-rouge">then</code>, <code class="language-plaintext highlighter-rouge">els</code> which corresponds to code in <code class="language-plaintext highlighter-rouge">if(cond){ } else {}</code>. New production rule is introduced to deal with <code class="language-plaintext highlighter-rouge">if</code> statement</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// stmt = "return" expr ";" </span>
<span class="c1">//        | "{" compound_stmt</span>
<span class="c1">//        | expr_stmt</span>
<span class="c1">//        | "if" "(" expr ")" stmt ("else" stmt)?</span>
<span class="k">static</span> <span class="n">Node</span><span class="o">*</span> <span class="nf">stmt</span><span class="p">(</span><span class="n">Token</span><span class="o">**</span><span class="n">rest</span><span class="p">,</span> <span class="n">Token</span><span class="o">*</span> <span class="n">tok</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="n">equal</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">"return"</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">new_unary</span><span class="p">(</span><span class="n">ND_RETURN</span><span class="p">,</span> <span class="n">expr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">));</span>
    <span class="o">*</span><span class="n">rest</span> <span class="o">=</span> <span class="n">skip</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">";"</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span><span class="p">(</span><span class="n">equal</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">"{"</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">compound_stmt</span><span class="p">(</span><span class="n">rest</span><span class="p">,</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">if</span><span class="p">(</span><span class="n">equal</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">"if"</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">tok</span> <span class="o">=</span> <span class="n">skip</span><span class="p">(</span><span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="s">"("</span><span class="p">);</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">(</span><span class="n">ND_IF</span><span class="p">);</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">cond</span> <span class="o">=</span> <span class="n">expr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">tok</span><span class="p">);</span>
    <span class="n">tok</span> <span class="o">=</span> <span class="n">skip</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">")"</span><span class="p">);</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">then</span> <span class="o">=</span> <span class="n">stmt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">tok</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">equal</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">"else"</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">node</span><span class="o">-&gt;</span><span class="n">els</span> <span class="o">=</span> <span class="n">stmt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="o">*</span><span class="n">rest</span> <span class="o">=</span> <span class="n">tok</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nf">expr_stmt</span><span class="p">(</span><span class="n">rest</span><span class="p">,</span> <span class="n">tok</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>For code generator, assembly code generation for <code class="language-plaintext highlighter-rouge">if</code> condition is introduced in <code class="language-plaintext highlighter-rouge">gen_stmt</code>. First we generate assembly code for <code class="language-plaintext highlighter-rouge">cond</code> node, and then we generate <code class="language-plaintext highlighter-rouge">je $0, %rax</code> to check condtion of <code class="language-plaintext highlighter-rouge">cond</code> node, and call <code class="language-plaintext highlighter-rouge">jump .L.else.%d</code> to do them instruction jump, <code class="language-plaintext highlighter-rouge">%d</code> is used to uniquly identify each <code class="language-plaintext highlighter-rouge">else</code> block. Because multiple <code class="language-plaintext highlighter-rouge">if</code> statement can be nested at the same time.</p>]]></content><author><name></name></author><category term="compiler"/><category term="c"/><category term="compiler"/><summary type="html"><![CDATA[Commit history for if statement feature]]></summary></entry><entry><title type="html">chibicc - Simple c compiler for statement</title><link href="https://bilyz98.github.io/blog/2025/chibicc-for-statement/" rel="alternate" type="text/html" title="chibicc - Simple c compiler for statement"/><published>2025-01-14T11:59:00+00:00</published><updated>2025-01-14T11:59:00+00:00</updated><id>https://bilyz98.github.io/blog/2025/chibicc-for-statement</id><content type="html" xml:base="https://bilyz98.github.io/blog/2025/chibicc-for-statement/"><![CDATA[<p><a href="https://github.com/BilyZ98/chibicc/commit/ed1f13abd63cc10e7cbd76c6f6de784df0f801c1">Commit history of for statement feature</a></p> <h2 id="what-is-changed-to-introduce-for-loop-">What is changed to introduce for loop ?</h2> <p>No big changes on top of if statement feature.</p> <p>For parser, add another grammar/production rule for <code class="language-plaintext highlighter-rouge">for</code> statement.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// stmt = "return" expr ";" </span>
<span class="c1">//        | "{" compound_stmt</span>
<span class="c1">//        | expr_stmt</span>
<span class="c1">//        | "if" "(" expr ")" stmt ("else" stmt)?</span>
<span class="c1">//        | "for" "(" expr_stmt expr? ";" expr? ")" stmt </span>
<span class="k">static</span> <span class="n">Node</span><span class="o">*</span> <span class="nf">stmt</span><span class="p">(</span><span class="n">Token</span><span class="o">**</span><span class="n">rest</span><span class="p">,</span> <span class="n">Token</span><span class="o">*</span> <span class="n">tok</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="n">equal</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">"return"</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">new_unary</span><span class="p">(</span><span class="n">ND_RETURN</span><span class="p">,</span> <span class="n">expr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">));</span>
    <span class="o">*</span><span class="n">rest</span> <span class="o">=</span> <span class="n">skip</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">";"</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span><span class="p">(</span><span class="n">equal</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">"{"</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">compound_stmt</span><span class="p">(</span><span class="n">rest</span><span class="p">,</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">if</span><span class="p">(</span><span class="n">equal</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">"if"</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">tok</span> <span class="o">=</span> <span class="n">skip</span><span class="p">(</span><span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="s">"("</span><span class="p">);</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">(</span><span class="n">ND_IF</span><span class="p">);</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">cond</span> <span class="o">=</span> <span class="n">expr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">tok</span><span class="p">);</span>
    <span class="n">tok</span> <span class="o">=</span> <span class="n">skip</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">")"</span><span class="p">);</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">then</span> <span class="o">=</span> <span class="n">stmt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">tok</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">equal</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">"else"</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">node</span><span class="o">-&gt;</span><span class="n">els</span> <span class="o">=</span> <span class="n">stmt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="o">*</span><span class="n">rest</span> <span class="o">=</span> <span class="n">tok</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span><span class="p">(</span><span class="n">equal</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">"for"</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">tok</span> <span class="o">=</span> <span class="n">skip</span><span class="p">(</span><span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="s">"("</span><span class="p">);</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">(</span><span class="n">ND_FOR</span><span class="p">);</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">init</span> <span class="o">=</span> <span class="n">expr_stmt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">tok</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">equal</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">";"</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">node</span><span class="o">-&gt;</span><span class="n">cond</span> <span class="o">=</span> <span class="n">expr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">tok</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">tok</span> <span class="o">=</span> <span class="n">skip</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">";"</span><span class="p">);</span>

    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">equal</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">")"</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">inc</span> <span class="o">=</span> <span class="n">expr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">tok</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">tok</span> <span class="o">=</span> <span class="n">skip</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">")"</span><span class="p">);</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">then</span> <span class="o">=</span> <span class="n">stmt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">tok</span><span class="p">);</span>
    <span class="o">*</span><span class="n">rest</span> <span class="o">=</span> <span class="n">tok</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nf">expr_stmt</span><span class="p">(</span><span class="n">rest</span><span class="p">,</span> <span class="n">tok</span><span class="p">);</span>
<span class="p">}</span>

</code></pre></div></div> <p>Introduce <code class="language-plaintext highlighter-rouge">init</code> and <code class="language-plaintext highlighter-rouge">inc</code> node inside of <code class="language-plaintext highlighter-rouge">Node</code> type to represent initialization and increment operation in <code class="language-plaintext highlighter-rouge">for</code> statement. <code class="language-plaintext highlighter-rouge">for(init;cond; inc){}</code></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">Node</span> <span class="n">Node</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
  <span class="n">NodeKind</span> <span class="n">kind</span><span class="p">;</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">lhs</span><span class="p">;</span> <span class="c1">//left hand side</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">rhs</span><span class="p">;</span> <span class="c1">// right hand side</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span> <span class="c1">// next node</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">body</span><span class="p">;</span> <span class="c1">// {} body node</span>

  <span class="c1">// "if" or "for" statement</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">cond</span><span class="p">;</span> 
  <span class="n">Node</span><span class="o">*</span> <span class="n">then</span><span class="p">;</span> 
  <span class="n">Node</span><span class="o">*</span> <span class="n">els</span><span class="p">;</span> 
  <span class="n">Node</span><span class="o">*</span> <span class="n">init</span><span class="p">;</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">inc</span><span class="p">;</span>


  <span class="c1">// char name;</span>
  <span class="n">Obj</span><span class="o">*</span> <span class="n">obj</span><span class="p">;</span> <span class="c1">// used if kind == ND_VAR</span>
  <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>  <span class="c1">// used if kind == ND_NUM</span>
<span class="p">};</span>

</code></pre></div></div> <p>For code generator, generate <code class="language-plaintext highlighter-rouge">.L.begin.%d:</code> to indicate the start of the for block. Use <code class="language-plaintext highlighter-rouge">cmp $0, %%rax</code> and <code class="language-plaintext highlighter-rouge">jmp .L.end.%d</code> after <code class="language-plaintext highlighter-rouge">cond</code> to go out of for block. Use <code class="language-plaintext highlighter-rouge">jmp .L.begin.%d</code> to jmp back to the begining of the for block at the end. And then comparison at the begining will decide whether to jump out of the for block or not.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">case</span> <span class="n">ND_FOR</span><span class="p">:</span> <span class="p">{</span>
      <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">count_depth</span><span class="p">();</span>
      <span class="n">gen_stmt</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">);</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">".L.begin.%d:</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
      <span class="k">if</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">cond</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">gen_expr</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">cond</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"  cmp $0, %%rax</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"  je .L.end.%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">c</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="n">gen_stmt</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">then</span><span class="p">);</span>
      <span class="k">if</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">inc</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">gen_expr</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">inc</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"  jmp .L.begin.%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">c</span><span class="p">);</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">".L.end.%d:</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">c</span><span class="p">);</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="compiler"/><category term="c"/><category term="compiler"/><summary type="html"><![CDATA[Commit history of for statement feature]]></summary></entry><entry><title type="html">chibicc - Simple c compiler block {} node</title><link href="https://bilyz98.github.io/blog/2025/chibicc-block/" rel="alternate" type="text/html" title="chibicc - Simple c compiler block {} node"/><published>2025-01-13T11:59:00+00:00</published><updated>2025-01-13T11:59:00+00:00</updated><id>https://bilyz98.github.io/blog/2025/chibicc-block</id><content type="html" xml:base="https://bilyz98.github.io/blog/2025/chibicc-block/"><![CDATA[<p><a href="https://github.com/BilyZ98/chibicc/commit/50d55515fe3a882f90fec3fbee8b5795239b60f8">Commit history for block feature</a></p> <h2 id="expected-an-expression-error-after-adding-block--node">expected an expression error after adding block {} node</h2> <p>Problem:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">{</span> <span class="nv">a</span><span class="o">=</span>3<span class="p">;</span> <span class="k">return </span>a<span class="p">;</span> <span class="o">}</span>
   ^ expected an expression
make: <span class="k">***</span> <span class="o">[</span>Makefile:12: <span class="nb">test</span><span class="o">]</span> Error 1
</code></pre></div></div> <p>Root cause:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// compound_stmt = stmt* "}"</span>
<span class="k">static</span> <span class="n">Node</span><span class="o">*</span> <span class="nf">compound_stmt</span><span class="p">(</span><span class="n">Token</span><span class="o">**</span> <span class="n">rest</span><span class="p">,</span> <span class="n">Token</span><span class="o">*</span> <span class="n">tok</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Node</span> <span class="n">head</span> <span class="o">=</span> <span class="p">{};</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">head</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">equal</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">"}"</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// This is the bug, should be tok not tok-&gt;next;</span>
    <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">stmt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">(</span><span class="n">ND_BLOCK</span><span class="p">);</span>
  <span class="n">node</span><span class="o">-&gt;</span><span class="n">body</span> <span class="o">=</span> <span class="n">head</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
  <span class="o">*</span><span class="n">rest</span> <span class="o">=</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">node</span><span class="p">;</span>

<span class="p">}</span>
</code></pre></div></div> <p>Fix:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// compound_stmt = stmt* "}"</span>
<span class="k">static</span> <span class="n">Node</span><span class="o">*</span> <span class="nf">compound_stmt</span><span class="p">(</span><span class="n">Token</span><span class="o">**</span> <span class="n">rest</span><span class="p">,</span> <span class="n">Token</span><span class="o">*</span> <span class="n">tok</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Node</span> <span class="n">head</span> <span class="o">=</span> <span class="p">{};</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">head</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">equal</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">"}"</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">stmt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">tok</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">(</span><span class="n">ND_BLOCK</span><span class="p">);</span>
  <span class="n">node</span><span class="o">-&gt;</span><span class="n">body</span> <span class="o">=</span> <span class="n">head</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
  <span class="o">*</span><span class="n">rest</span> <span class="o">=</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">node</span><span class="p">;</span>

<span class="p">}</span>
</code></pre></div></div> <h2 id="what-is-done-to-introduce-block-concept">What is done to introduce block concept?</h2> <p>Introduce another node in node struct called <code class="language-plaintext highlighter-rouge">body</code> to store the code content inside block</p> <p>No change is made to tokenizer</p> <p>For parser, introduce <code class="language-plaintext highlighter-rouge">compound_stmt</code> production/grammar rule for <code class="language-plaintext highlighter-rouge">stmt</code> generation rule.</p> <p>For code generator, start generating code from <code class="language-plaintext highlighter-rouge">Function-&gt;body</code> part which is a block itself. Each <code class="language-plaintext highlighter-rouge">body</code> inside each block has its own list of nodes. Previously we only have on list of nodes. Now we have one list of nodes for each block node.</p> <p>I guess this is for variable scope purpose, althought this has not been done in this commit history.</p>]]></content><author><name></name></author><category term="compiler"/><category term="c"/><category term="compiler"/><summary type="html"><![CDATA[Commit history for block feature]]></summary></entry><entry><title type="html">chibicc - Simple c compiler return keyword</title><link href="https://bilyz98.github.io/blog/2025/chibicc-return-keyword/" rel="alternate" type="text/html" title="chibicc - Simple c compiler return keyword"/><published>2025-01-12T11:59:00+00:00</published><updated>2025-01-12T11:59:00+00:00</updated><id>https://bilyz98.github.io/blog/2025/chibicc-return-keyword</id><content type="html" xml:base="https://bilyz98.github.io/blog/2025/chibicc-return-keyword/"><![CDATA[<h2 id="add-return-keyword-to-simple-c-compiler">Add return keyword to simple c compiler</h2> <p><a href="https://github.com/BilyZ98/chibicc/commit/f94ca394ade26ca861bd205d3714f103eb4dedb9">Commit history</a></p> <p>For tokenizer, <code class="language-plaintext highlighter-rouge">convert_keywords()</code> is added to convert kind of token from identity to keyword. So this means that all basic tokens are identity at first and later convert to keywrod type token.</p> <p>For parser, add extra prudction rule/grammar rule in expr geneartion. <code class="language-plaintext highlighter-rouge">stmt = "return" expr ";" | expr-stmt</code>. New node type <code class="language-plaintext highlighter-rouge">ND_RETURN</code> is added.</p> <p>For code generation, <code class="language-plaintext highlighter-rouge">jmp .L.return</code> is added to jump to specified assembly code.</p> <p>For test, add <code class="language-plaintext highlighter-rouge">return 1; 2; 3</code> to test return actually works.</p>]]></content><author><name></name></author><category term="compiler"/><category term="c"/><category term="compiler"/><summary type="html"><![CDATA[Add return keyword to simple c compiler]]></summary></entry><entry><title type="html">Learned idnex survey</title><link href="https://bilyz98.github.io/blog/2025/learned-index-survery/" rel="alternate" type="text/html" title="Learned idnex survey"/><published>2025-01-08T11:59:00+00:00</published><updated>2025-01-08T11:59:00+00:00</updated><id>https://bilyz98.github.io/blog/2025/learned-index-survery</id><content type="html" xml:base="https://bilyz98.github.io/blog/2025/learned-index-survery/"><![CDATA[<h2 id="what-is-learned-index-and-why">What is learned index and why?</h2> <p>To search a key in b+ tree, traditional way is to do binary search. This complexity time is O(Log_n)</p> <p>Learned index build model to learn the distribution of keys in space. The input is the key number and the output of the model is the location of the key in the storage array space. The time complexity is O(1) which is faster than binary search.</p> <h2 id="current-work">Current work</h2> <p><a href="https://arxiv.org/pdf/1712.01208">The case for learned index structures</a> proposes to replace every node in b+ tree with learned model.</p> <p>Each node contains a model trained from the keys covered by its key ranges.</p> <p>It‚Äôs said that in the paper that this hierachy style allows allows model to learn the rough key distribtuion at its key ranges. Bottom level model covers smalles range of keys, it‚Äôs easy for the model learn. Top level covers larget range of keys but it only cares about the big structure of the keys distribution and it leaves fine-grained key position to bottom level models.</p> <p>Search process:</p> <p>Model at each level gives its key position prediction until reaches the leaf child.</p> <p>Since model might not give the correct position prediction, learned index make sures that each model prediction error is within a predefined error bound.</p> <p>So it‚Äôs guarantee that key is located within the [lower_bound, upper_bound] range given by the model.</p> <p>This paper only mentions how to build model for read only scenario.</p> <p><a href="https://arxiv.org/pdf/1905.08898">ALEX</a> solves the updatable learned index problem.</p> <p>How ?</p> <p>Insert process:</p> <p>For non-full data node, it inserts the key to the predicted position from the model if there is a empty slow in the array..</p> <p>The predcited position might be occupied, so it shifts other elements towards the closet gap by one. ( I am not sure if the model should be trained after this shift operation, I think we should train a new model because that position of shifted key is changed, but the model train cost is too high if we do this for each occupied key.)</p> <p>For full-data node, it can choose to split the data node or matain a single data node but with allocation of largers storage space and retarined a new model.</p> <p>For data node expansion, new position in array of original key is given by new model.</p> <p>This is not the same as traditional binary tree which just does simple copy.</p> <p>For internal nodes, ALEX choose to split the internal nodes horizontally, i.e at the same level.</p> <p>Alex can choose to turn data nodes to internal nodes which is the same as split the node vertically, increasing the depth of the tree?</p> <h2 id="whats-next-">What‚Äôs next ?</h2> <p><a href="Learned index survey">https://arxiv.org/pdf/2403.06456</a> talks about development of learned index. It classifies learned index into multi-dimensional and mutable/immutable categories.</p> <p>What‚Äôs not talked about is how learned index is efficiently integrated into existing system.</p> <h2 id="references">References</h2> <p><a href="https://www.youtube.com/watch?v=2A3tiAmaq_c">Jeaf dean‚Äôs talk about ml for sys in NIPS‚Äô25</a></p> <p><a href="https://zongheng.me/pubs/qdtree-sigmod20.pdf">qd-tree</a> . Why only for data analytics?</p> <p><a href="https://www.cidrdb.org/cidr2019/papers/p117-kraska-cidr19.pdf">SageDB: A Learned Database System</a></p> <p><a href="https://dbgroup.cs.tsinghua.edu.cn/ligl/papers/experiment-learned-index.pdf">Learned Index: A Comprehensive Experimental Evaluation</a></p> <p><a href="https://www.usenix.org/conference/osdi20/presentation/wei">Fast RDMA-based Ordered Key-Value Store using Remote Learned Cache</a></p>]]></content><author><name></name></author><category term="learned"/><category term="index"/><category term="research"/><category term="learned"/><category term="index"/><category term="research"/><summary type="html"><![CDATA[What is learned index and why? To search a key in b+ tree, traditional way is to do binary search. This complexity time is O(Log_n)]]></summary></entry><entry><title type="html">chibicc C compiler - multi char variable name</title><link href="https://bilyz98.github.io/blog/2025/chibicc-multi-char-var-name/" rel="alternate" type="text/html" title="chibicc C compiler - multi char variable name"/><published>2025-01-05T11:59:00+00:00</published><updated>2025-01-05T11:59:00+00:00</updated><id>https://bilyz98.github.io/blog/2025/chibicc-multi-char-var-name</id><content type="html" xml:base="https://bilyz98.github.io/blog/2025/chibicc-multi-char-var-name/"><![CDATA[<h3 id="find-bug-in-code-that-leads-to-seg-fault">Find bug in code that leads to seg fault.</h3> <p><a href="https://github.com/BilyZ98/chibicc/commit/3ca91cc6431246e1b23f4503b6442e77e7457246">https://github.com/BilyZ98/chibicc/commit/3ca91cc6431246e1b23f4503b6442e77e7457246</a></p> <p>The bug code is at parse.c. I use gdb to find out the bug location.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>77      ../sysdeps/x86_64/multiarch/strlen-evex.S: No such file or directory.
(gdb) bt
#0  __strlen_evex () at ../sysdeps/x86_64/multiarch/strlen-evex.S:77
#1  0x0000555555555ff7 in find_var (start=0x7fffffffe399 "a;", len=1) at parse.c:194
#2  0x0000555555556140 in primary (rest=0x7fffffffdd30, tok=0x55555555a360) at parse.c:220
#3  0x0000555555555fbf in unary (rest=0x7fffffffdd30, tok=0x55555555a360) at parse.c:187
#4  0x0000555555555e73 in mul (rest=0x7fffffffdd60, tok=0x55555555a360) at parse.c:160
#5  0x0000555555555d9a in add (rest=0x7fffffffdd90, tok=0x55555555a360) at parse.c:138
#6  0x0000555555555c1f in relational (rest=0x7fffffffddc0, tok=0x55555555a360) at parse.c:109
#7  0x0000555555555b46 in equality (rest=0x7fffffffddf0, tok=0x55555555a360) at parse.c:90
#8  0x0000555555555ac1 in assign (rest=0x7fffffffde40, tok=0x55555555a360) at parse.c:78
#9  0x0000555555555a98 in expr (rest=0x7fffffffde40, tok=0x55555555a360) at parse.c:73
#10 0x0000555555555a3d in expr_stmt (rest=0x7fffffffde98, tok=0x55555555a360) at parse.c:65
#11 0x00005555555559e4 in stmt (rest=0x7fffffffde98, tok=0x55555555a360) at parse.c:46
#12 0x0000555555556248 in parse (tok=0x55555555a360) at parse.c:245
#13 0x00005555555558c9 in main (argc=2, argv=0x7fffffffe038) at main.c:9
</code></pre></div></div> <p>function</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">Obj</span><span class="o">*</span> <span class="nf">find_var</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span><span class="p">(</span><span class="n">Obj</span><span class="o">*</span> <span class="n">o_idx</span> <span class="o">=</span> <span class="n">local_obj_ptr</span><span class="p">;</span> <span class="n">o_idx</span><span class="p">;</span> <span class="n">o_idx</span><span class="o">=</span><span class="n">o_idx</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="n">strlen</span><span class="p">(</span><span class="n">o_idx</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">strncmp</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">o_idx</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">o_idx</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>Finally found the bug.</p> <p>I did not include this define at <code class="language-plaintext highlighter-rouge">chibicc.h</code></p> <p>lol.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#define _POSIX_C_SOURCE 200809L
</code></pre></div></div> <p>This line of code enable functions like <code class="language-plaintext highlighter-rouge">strndup, getline, and clock_gettime</code> which are not part of the standard C library but are available in the POSIX standard. Spend really long time on this.</p> <p>Correct code:</p> <p><a href="https://github.com/BilyZ98/chibicc/tree/1651006f9035bb0a1f3afffd1fb328948006cc28">https://github.com/BilyZ98/chibicc/tree/1651006f9035bb0a1f3afffd1fb328948006cc28</a></p>]]></content><author><name></name></author><category term="compiler"/><category term="c"/><category term="compiler"/><category term="cpp"/><summary type="html"><![CDATA[Find bug in code that leads to seg fault.]]></summary></entry><entry><title type="html">C++ and linux kernel memory allocation</title><link href="https://bilyz98.github.io/blog/2025/cpp-interview-questions/" rel="alternate" type="text/html" title="C++ and linux kernel memory allocation"/><published>2025-01-02T11:59:00+00:00</published><updated>2025-01-02T11:59:00+00:00</updated><id>https://bilyz98.github.io/blog/2025/cpp-interview-questions</id><content type="html" xml:base="https://bilyz98.github.io/blog/2025/cpp-interview-questions/"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/EIVDCWHr8EFEl4LX6UqWHQ">How malloc allocates memory?</a></p> <p>kernel memory allocation</p> <ul> <li> <p>buddy algorithm</p> </li> <li> <p>slab allocator</p> </li> </ul> <p>The slab allocator and buddy algorithm are two different memory allocation techniques used in the Linux kernel, each with its own strengths and use cases.</p> <h3 id="buddy-algorithm">Buddy Algorithm</h3> <p>The buddy algorithm is used for allocating memory in large contiguous blocks. It works by dividing memory into blocks of size 2^n and maintaining a binary tree structure. When a memory request is made, the allocator finds the smallest block that can satisfy the request. If a larger block is found, it is split into smaller blocks (buddies) until the desired size is obtained. This method is efficient for allocating large blocks of memory and helps reduce fragmentation](https://www.tutorialspoint.com/allocating-kernel-memory-buddy-system-and-slab-system).</p> <h3 id="slab-allocator">Slab Allocator</h3> <p>The slab allocator, on the other hand, is designed for allocating small, frequently used objects. It maintains caches of pre-allocated memory chunks (slabs) for different object sizes. When an object is needed, it is allocated from the appropriate slab, which reduces the overhead of frequent allocations and deallocations. This method is particularly useful for kernel objects like process descriptors, file descriptors, and other small data structures](https://www.tutorialspoint.com/allocating-kernel-memory-buddy-system-and-slab-system).</p> <h3 id="relationship">Relationship</h3> <p>The relationship between the two lies in their complementary roles within the Linux kernel. The buddy algorithm is used for allocating large contiguous blocks of memory, which can then be subdivided by the slab allocator for smaller, frequently used objects. This combination allows the Linux kernel to efficiently manage memory for both large and small allocations, optimizing performance and reducing fragmentation](https://www.tutorialspoint.com/allocating-kernel-memory-buddy-system-and-slab-system).</p> <p><a href="https://www.tutorialspoint.com/allocating-kernel-memory-buddy-system-and-slab-system">ref 1</a></p> <h3 id="which-algorithm-does-linux-use-when-brk-syscall-is-called-to-allocate-memory-">which algorithm does linux use when brk() syscall is called to allocate memory ?</h3> <p>When the <code class="language-plaintext highlighter-rouge">brk()</code> system call is used in Linux to allocate memory, it primarily relies on the <strong>buddy algorithm</strong> for managing the memory. The <code class="language-plaintext highlighter-rouge">brk()</code> system call adjusts the end of the data segment of a process, effectively increasing or decreasing the amount of memory allocated to the process. The buddy algorithm is used to allocate large contiguous blocks of memory, which can then be managed by the process.</p> <h3 id="difference-between-malloc-and-new-in-c-">Difference between malloc and new in c++ ?</h3> <p>malloc is a system call function. When calling malloc it will not call constructor of class or do memory initialization. <code class="language-plaintext highlighter-rouge">free</code> to free memory.</p> <p>new is a primitive word in c++ itself. <code class="language-plaintext highlighter-rouge">new</code> will call constructor of class and do memory initialization. <code class="language-plaintext highlighter-rouge">new</code> is managed by c++ compiler. <code class="language-plaintext highlighter-rouge">delete</code> to free memory and destructor is called for <code class="language-plaintext highlighter-rouge">delete</code></p> <h3 id="memory-allocation-for-process-in-linux">Memory allocation for process in linux</h3> <ol> <li> <p>For small memory allocation <code class="language-plaintext highlighter-rouge">brk</code> is called.</p> <p><code class="language-plaintext highlighter-rouge">brk</code> will allocate memory from heap and the allocated memory will not be returned to kernel immediately after <code class="language-plaintext highlighter-rouge">free</code>. It will stay in the process memory mapping space for future use.</p> </li> <li> <p>For large memory allocation <code class="language-plaintext highlighter-rouge">mmap</code> is called. For memory size allocation request &gt; 128KB, memory allocated is in file mapping space in process memory space. The physical memory is returned to kernel immediately after <code class="language-plaintext highlighter-rouge">free</code> call which is different from <code class="language-plaintext highlighter-rouge">brk</code></p> </li> </ol> <p><a href="https://mp.weixin.qq.com/s/EIVDCWHr8EFEl4LX6UqWHQ">ref article about memory allocation </a></p>]]></content><author><name></name></author><category term="compiler"/><category term="c"/><category term="compiler"/><category term="cpp"/><category term="linux"/><summary type="html"><![CDATA[How malloc allocates memory?]]></summary></entry></feed>