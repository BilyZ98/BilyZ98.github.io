<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://bilyz98.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://bilyz98.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-10-20T16:53:50+00:00</updated><id>https://bilyz98.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Ssh Display Img</title><link href="https://bilyz98.github.io/blog/2024/ssh-display-img/" rel="alternate" type="text/html" title="Ssh Display Img"/><published>2024-10-18T00:00:00+00:00</published><updated>2024-10-18T00:00:00+00:00</updated><id>https://bilyz98.github.io/blog/2024/ssh-display-img</id><content type="html" xml:base="https://bilyz98.github.io/blog/2024/ssh-display-img/"><![CDATA[<p>To display an image on your local machine after using the <code class="language-plaintext highlighter-rouge">ssh -Y</code> command, youâ€™ll need to have an image viewer installed on the remote server. Hereâ€™s a step-by-step example:</p> <ol> <li><strong>Connect to the remote server with X11 forwarding</strong>: <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ssh <span class="nt">-Y</span> user@remote-server
</code></pre></div> </div> </li> <li><strong>Check if an image viewer is installed</strong>: <ul> <li>Common image viewers include <code class="language-plaintext highlighter-rouge">eog</code> (Eye of GNOME), <code class="language-plaintext highlighter-rouge">display</code> (ImageMagick), and <code class="language-plaintext highlighter-rouge">xdg-open</code>.</li> <li>You can check if one of these is installed by running, for example: <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>which eog
</code></pre></div> </div> <p>If itâ€™s installed, the command will return the path to the executable. If not, you might need to install it using the package manager for your distribution.</p> </li> </ul> </li> <li><strong>Display an image</strong>: <ul> <li>Assuming you have an image file named <code class="language-plaintext highlighter-rouge">example.png</code> in your home directory on the remote server, you can display it using: <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>eog ~/example.png
</code></pre></div> </div> </li> <li>This command will open the image using the Eye of GNOME image viewer, and the image should be displayed on your local machine.</li> </ul> </li> </ol> <p>Remember, the exact command to display an image will depend on the image viewers available on the remote server. If youâ€™re not sure which image viewers are installed, you can try running the command for a few common ones until you find one that works. Also, ensure that your local machine is running an X server (like XQuartz on macOS or Xming on Windows) to handle the forwarded X11 display.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Parallel programming - round robin assignment</title><link href="https://bilyz98.github.io/blog/2024/stf-cs149-parallel-programming-assignment1/" rel="alternate" type="text/html" title="Parallel programming - round robin assignment"/><published>2024-10-17T11:59:00+00:00</published><updated>2024-10-17T11:59:00+00:00</updated><id>https://bilyz98.github.io/blog/2024/stf-cs149-parallel-programming-assignment1</id><content type="html" xml:base="https://bilyz98.github.io/blog/2024/stf-cs149-parallel-programming-assignment1/"><![CDATA[<h2 id="program1-generate-image-with-multiple-threads">Program1: generate image with multiple threads.</h2> <p>Hardware: hyperthreads?</p> <p>Code: partition the image generation task.</p> <p>Plot speedup line with number of threads as x axis.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(base) âžœ  prog1_mandelbrot_threads git:(master) âœ— ./mandelbrot --threads 2
[mandelbrot serial]:            [525.650] ms
Wrote image file mandelbrot-serial.ppm
[mandelbrot thread]:            [280.569] ms
Wrote image file mandelbrot-thread.ppm
                                (1.87x speedup from 2 threads)
(base) âžœ  prog1_mandelbrot_threads git:(master) âœ— ./mandelbrot --threads 3
Wrote image file mandelbrot-serial.ppm
[mandelbrot thread]:            [341.063] ms
Wrote image file mandelbrot-thread.ppm                                                                                                                                                       (1.56x speedup from 3 threads)
(base) âžœ  prog1_mandelbrot_threads git:(master) âœ— ./mandelbrot --threads 4
[mandelbrot serial]:            [531.202] ms
Wrote image file mandelbrot-serial.ppm
[mandelbrot thread]:            [237.027] ms
Wrote image file mandelbrot-thread.ppm                                                                                                                                                       (2.24x speedup from 4 threads)
(base) âžœ  prog1_mandelbrot_threads git:(master) âœ— ./mandelbrot --threads 5
[mandelbrot serial]:            [532.980] ms
Wrote image file mandelbrot-serial.ppm
[mandelbrot thread]:            [213.517] ms
Wrote image file mandelbrot-thread.ppm                                                                                                                                                       (2.50x speedup from 5 threads)
(base) âžœ  prog1_mandelbrot_threads git:(master) âœ— ./mandelbrot --threads 6
[mandelbrot serial]:            [531.480] ms
Wrote image file mandelbrot-serial.ppm
[mandelbrot thread]:            [182.457] ms
Wrote image file mandelbrot-thread.ppm                                                                                                                                                       (2.91x speedup from 6 threads)
(base) âžœ  prog1_mandelbrot_threads git:(master) âœ— ./mandelbrot --threads 7
[mandelbrot serial]:            [530.595] ms
Wrote image file mandelbrot-serial.ppm
[mandelbrot thread]:            [173.007] ms
Wrote image file mandelbrot-thread.ppm
Mismatch : [1197][142], Expected : 1, Actual : 0
Error : Output from threads does not match serial output
(base) âžœ  prog1_mandelbrot_threads git:(master) âœ— ./mandelbrot --threads 8
[mandelbrot serial]:            [534.651] ms
Wrote image file mandelbrot-serial.ppm
[mandelbrot thread]:            [150.080] ms
Wrote image file mandelbrot-thread.ppm                                                                                                                                                       (3.56x speedup from 8 threads)
</code></pre></div></div> <p>Time for each thread</p> <p>Not all threads run with same finish time.</p> <p>Why is that?</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(base) âžœ  prog1_mandelbrot_threads git:(master) âœ— ./mandelbrot --threads 2
[mandelbrot serial]:            [529.644] ms
Wrote image file mandelbrot-serial.ppm
exe time: 275.106996 ms
exe time: 294.014979 ms
exe time: 278.083589 ms
exe time: 280.188169 ms
exe time: 268.240355 ms
exe time: 288.978558 ms
exe time: 274.672702 ms
exe time: 285.212621 ms
exe time: 275.313959 ms
exe time: 291.359153 ms
[mandelbrot thread]:            [280.327] ms
Wrote image file mandelbrot-thread.ppm                                                                                                                                                       
(1.89x speedup from 2 threads)


(base) âžœ  prog1_mandelbrot_threads git:(master) âœ— ./mandelbrot --threads 3
[mandelbrot serial]:            [532.551] ms
Wrote image file mandelbrot-serial.ppm
exe time: 120.048959 ms
exe time: 127.574176 ms
exe time: 346.292444 ms
exe time: 122.336693 ms
exe time: 122.885458 ms
exe time: 342.198521 ms
exe time: 123.949669 ms
exe time: 123.917334 ms
exe time: 343.334582 ms
exe time: 121.276554 ms
exe time: 121.796411 ms
exe time: 339.319866 ms
exe time: 122.690346 ms
exe time: 123.405423 ms
exe time: 341.921013 ms
[mandelbrot thread]:            [339.491] ms
Wrote image file mandelbrot-thread.ppm
                                (1.57x speedup from 3 threads)


(base) âžœ  prog1_mandelbrot_threads git:(master) âœ— ./mandelbrot --threads 4
[mandelbrot serial]:            [532.573] ms
Wrote image file mandelbrot-serial.ppm
exe time: 66.314548 ms
exe time: 69.146506 ms
exe time: 236.007646 ms
exe time: 236.860119 ms
exe time: 67.293212 ms
exe time: 68.643764 ms
exe time: 235.531762 ms
exe time: 235.957604 ms
exe time: 67.872606 ms
exe time: 68.252590 ms
exe time: 231.048137 ms
exe time: 236.915503 ms
exe time: 68.757534 ms
exe time: 70.160590 ms
exe time: 219.524853 ms
exe time: 238.315675 ms
exe time: 66.293016 ms
exe time: 66.733379 ms
exe time: 233.316239 ms
exe time: 234.051295 ms
[mandelbrot thread]:            [234.236] ms
Wrote image file mandelbrot-thread.ppm
                                (2.27x speedup from 4 threads)


(base) âžœ  prog1_mandelbrot_threads git:(master) âœ— ./mandelbrot --threads 8
[mandelbrot serial]:            [533.956] ms
Wrote image file mandelbrot-serial.ppm
exe time: 21.111727 ms
exe time: 21.316495 ms
exe time: 59.669584 ms
exe time: 59.972882 ms
exe time: 101.592321 ms
exe time: 104.972839 ms
exe time: 144.783191 ms
exe time: 145.647489 ms
[mandelbrot thread]:            [133.506] ms
Wrote image file mandelbrot-thread.ppm
                                (4.00x speedup from 8 threads)
</code></pre></div></div> <h2 id="more-efficient-implementation">More efficient implementation</h2> <p>cacheline aware ?</p> <p>In this code image is divided by <code class="language-plaintext highlighter-rouge">numThreads</code> blocks and each thread with <code class="language-plaintext highlighter-rouge">threadId</code> accesses idx:threadId of each block.</p> <p>This means that itâ€™s highly likely that at the same moment each thread access the same memory block that is in cache.</p> <p>This is just my understanding.</p> <p>The reason for some threads taking much longer time to finish the job is that some adjacent rows need much more time to compute. If we use round-robin assignment strategy then we can distribute the computation job evenly and each thread can get equal amount of computation job.</p> <p>GPT give me following answer when I asked it why to use round-robin assignment:</p> <p>Thread 2 has one more row to process than the other threads, which can lead to a slight imbalance. However, the imbalance becomes more pronounced if the work done per row is not uniform. For example, if the computation for the Mandelbrot set is more complex for certain rows, the threads processing those rows will take longer to complete, leading to idle time for other threads.</p> <p>This imbalance can be avoided by using a better load balancing strategy, such as the round-robin assignment used in the original code, which distributes the rows more evenly across the threads. ðŸ˜Š</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">workerThreadStart</span><span class="p">(</span><span class="n">WorkerArgs</span> <span class="o">*</span> <span class="k">const</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>

  <span class="c1">// TODO FOR CS149 STUDENTS: Implement the body of the worker</span>
  <span class="c1">// thread here. Each thread should make a call to mandelbrotSerial()</span>
  <span class="c1">// to compute a part of the output image.  For example, in a</span>
  <span class="c1">// program that uses two threads, thread 0 could compute the top</span>
  <span class="c1">// half of the image and thread 1 could compute the bottom half.</span>
  <span class="c1">//</span>
  <span class="kt">double</span> <span class="n">startTime</span> <span class="o">=</span> <span class="n">CycleTimer</span><span class="o">::</span><span class="n">currentSeconds</span><span class="p">();</span>
  <span class="kt">float</span> <span class="n">x0</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">x0</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">y0</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">y0</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">x1</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">y1</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">width</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">height</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">;</span>

  <span class="c1">// printf("cur start row: %d, cur total row:%d\n", cur_start_row, cur_total_rows);</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">height</span><span class="o">/</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">numThreads</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">start_row</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">threadId</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">numThreads</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">num_rows</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">mandelbrotSerial</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span>
                     <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span>
                     <span class="n">start_row</span><span class="p">,</span> <span class="n">num_rows</span><span class="p">,</span>
                     <span class="n">args</span><span class="o">-&gt;</span><span class="n">maxIterations</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">output</span><span class="p">);</span>


  <span class="p">}</span>
  <span class="kt">double</span> <span class="n">endTime</span> <span class="o">=</span> <span class="n">CycleTimer</span><span class="o">::</span><span class="n">currentSeconds</span><span class="p">();</span>
  <span class="kt">double</span> <span class="n">exe_time</span> <span class="o">=</span> <span class="n">endTime</span> <span class="o">-</span> <span class="n">startTime</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"exe time: %f ms</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">exe_time</span><span class="o">*</span><span class="mi">1000</span><span class="p">);</span>


  <span class="c1">// printf("Hello world from thread %d\n", args-&gt;threadId);</span>
<span class="p">}</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(base) âžœ  prog1_mandelbrot_threads git:(master) âœ— ./mandelbrot --threads 4
[mandelbrot serial]:            [533.651] ms
Wrote image file mandelbrot-serial.ppm
exe time: 142.692391 ms
exe time: 157.330707 ms
exe time: 157.454997 ms
exe time: 157.499295 ms
exe time: 141.290620 ms
exe time: 150.249667 ms
exe time: 150.373559 ms
exe time: 150.334526 ms
exe time: 138.450164 ms
exe time: 151.096858 ms
exe time: 151.156478 ms
exe time: 151.210513 ms
exe time: 138.270788 ms
exe time: 150.668491 ms
exe time: 150.774766 ms
exe time: 150.800020 ms
exe time: 138.079636 ms
exe time: 150.737014 ms
exe time: 150.741972 ms
exe time: 150.848471 ms
[mandelbrot thread]:            [150.471] ms
Wrote image file mandelbrot-thread.ppm
                                (3.55x speedup from 4 threads)
</code></pre></div></div> <h3 id="comparison-between-inefficient-assignment-and-round-robin-assignment">Comparison between inefficient assignment and round-robin assignment</h3> <p>Naive sequential assignment:</p> <p>Thread running time for another image genration</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(base) âžœ  prog1_mandelbrot_threads git:(master) âœ— ./mandelbrot --view 2 --threads 4
[mandelbrot serial]:            [311.051] ms
Wrote image file mandelbrot-serial.ppm
exe time: 84.468454 ms
exe time: 86.912777 ms
exe time: 87.307919 ms
exe time: 133.808278 ms
[mandelbrot thread]:            [119.725] ms
Wrote image file mandelbrot-thread.ppm                                                                                                                                                       
(2.60x speedup from 4 threads)
</code></pre></div></div> <p>Round-robin assignment:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(base) âžœ  prog1_mandelbrot_threads git:(master) âœ— ./mandelbrot --view 2 --threads 4
[mandelbrot serial]:            [310.842] ms
Wrote image file mandelbrot-serial.ppm
exe time: 83.830711 ms
exe time: 93.051653 ms
exe time: 93.096461 ms
exe time: 93.373701 ms
[mandelbrot thread]:            [93.562] ms
Wrote image file mandelbrot-thread.ppm                                                                                                                                                       (3.32x speedup from 4 threads)
</code></pre></div></div>]]></content><author><name></name></author><category term="parallel"/><category term="programming"/><category term="parallel"/><category term="programming"/><summary type="html"><![CDATA[Program1: generate image with multiple threads.]]></summary></entry><entry><title type="html">C compiler - single letter local variable</title><link href="https://bilyz98.github.io/blog/2024/chibicc-single-letter-ident/" rel="alternate" type="text/html" title="C compiler - single letter local variable"/><published>2024-10-15T11:59:00+00:00</published><updated>2024-10-15T11:59:00+00:00</updated><id>https://bilyz98.github.io/blog/2024/chibicc-single-letter-ident</id><content type="html" xml:base="https://bilyz98.github.io/blog/2024/chibicc-single-letter-ident/"><![CDATA[<h2 id="add-single-letter-identity-in-c-compiler">Add single letter identity in c compiler</h2> <p>Need to allocate memory address for single letter variable.</p> <p>Use following two registers. <code class="language-plaintext highlighter-rouge">rsp</code> <code class="language-plaintext highlighter-rouge">rbp</code></p> <p>In x86 assembly language, <code class="language-plaintext highlighter-rouge">rsp</code> and <code class="language-plaintext highlighter-rouge">rbp</code> are registers that play a crucial role in stack management and function calls:</p> <ul> <li> <p><strong><code class="language-plaintext highlighter-rouge">rsp</code> (Stack Pointer)</strong>: This register points to the top of the stack, which is a region of memory used for dynamic storage during program execution. The stack pointer is adjusted automatically when values are pushed onto or popped off the stack. Itâ€™s typically used to keep track of the current position in the stack.</p> </li> <li> <p><strong><code class="language-plaintext highlighter-rouge">rbp</code> (Base Pointer)</strong>: This register is used as a reference point for the stack frame of a function. A stack frame contains the functionâ€™s local variables and saved registers. The base pointer is usually set to the value of the stack pointer at the beginning of a function and remains constant throughout the functionâ€™s execution. This allows for easy access to function parameters and local variables via fixed offsets from <code class="language-plaintext highlighter-rouge">rbp</code>.</p> </li> </ul> <p>Hereâ€™s a brief example to illustrate their usage in a function call:</p> <pre><code class="language-assembly">push rbp            ; Save the caller's base pointer
mov rbp, rsp        ; Set the base pointer to the current stack pointer
sub rsp, 16         ; Allocate space for local variables
; Function body
mov rsp, rbp        ; Restore the stack pointer
pop rbp             ; Restore the caller's base pointer
ret                 ; Return to the caller
</code></pre> <p>In this example:</p> <ul> <li>The callerâ€™s base pointer is saved on the stack.</li> <li>The base pointer is set to the current stack pointer, establishing a new stack frame.</li> <li>Space is allocated on the stack for local variables.</li> <li>At the end of the function, the stack pointer and base pointer are restored, and control is returned to the caller.</li> </ul> <p>These registers are essential for implementing nested function calls and maintaining a clean and organized stack structure. If youâ€™re interested in learning more about x86 assembly and stack management, I can provide further details or examples. Just let me know! ðŸ˜Š</p> <p><code class="language-plaintext highlighter-rouge">mov (%%rax), %%rax</code> moves value in <code class="language-plaintext highlighter-rouge">%rax</code> address memory to %rax</p> <p><code class="language-plaintext highlighter-rouge">lea 8(%%rbp), %%rax</code> calculate the effective address <code class="language-plaintext highlighter-rouge">8+%rbp</code> and then load effective address (not memory content) into <code class="language-plaintext highlighter-rouge">%%rax</code></p> <h3 id="parse">Parse</h3> <p>Add assign expression and equality expression.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// expr = assign</span>
<span class="k">static</span> <span class="n">Node</span><span class="o">*</span> <span class="nf">expr</span><span class="p">(</span><span class="n">Token</span> <span class="o">**</span><span class="n">rest</span><span class="p">,</span> <span class="n">Token</span><span class="o">*</span> <span class="n">tok</span><span class="p">){</span>
  <span class="k">return</span> <span class="n">assign</span><span class="p">(</span><span class="n">rest</span><span class="p">,</span> <span class="n">tok</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// assign = equality ("=" assign)?</span>
<span class="k">static</span> <span class="n">Node</span><span class="o">*</span> <span class="nf">assign</span><span class="p">(</span><span class="n">Token</span><span class="o">**</span> <span class="n">rest</span><span class="p">,</span> <span class="n">Token</span><span class="o">*</span> <span class="n">tok</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">equality</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">tok</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="n">equal</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">"="</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">node</span> <span class="o">=</span> <span class="n">new_binary</span><span class="p">(</span><span class="n">ND_ASSIGN</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">assign</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="o">*</span><span class="n">rest</span> <span class="o">=</span> <span class="n">tok</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>Add ident type in primary expression.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// primary = "(" expr ")" | ident | num</span>
<span class="k">static</span> <span class="n">Node</span><span class="o">*</span> <span class="nf">primary</span><span class="p">(</span><span class="n">Token</span> <span class="o">**</span><span class="n">rest</span><span class="p">,</span> <span class="n">Token</span><span class="o">*</span> <span class="n">tok</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="n">equal</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">"("</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">expr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
    <span class="o">*</span><span class="n">rest</span> <span class="o">=</span> <span class="n">skip</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">")"</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span><span class="p">(</span><span class="n">tok</span><span class="o">-&gt;</span><span class="n">kind</span> <span class="o">==</span> <span class="n">TK_IDENT</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">new_var_node</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">tok</span><span class="o">-&gt;</span><span class="n">loc</span><span class="p">));</span>
    <span class="o">*</span><span class="n">rest</span> <span class="o">=</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span><span class="p">(</span><span class="n">tok</span><span class="o">-&gt;</span><span class="n">kind</span>  <span class="o">==</span> <span class="n">TK_NUM</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">new_num</span><span class="p">(</span><span class="n">tok</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
    <span class="o">*</span><span class="n">rest</span> <span class="o">=</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">error_tok</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">"expected an expression"</span><span class="p">);</span>

<span class="p">}</span>
</code></pre></div></div> <h3 id="codegen">Codegen</h3> <p>Add two new node types.</p> <ol> <li><code class="language-plaintext highlighter-rouge">ND_VAR</code> for loading memory address of variable.</li> <li><code class="language-plaintext highlighter-rouge">ND_ASSIGN</code> for get the value of right hand side expression and assign the value to memory address of the left hand side variable.</li> </ol> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">gen_expr</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">switch</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">kind</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">ND_NUM</span><span class="p">:</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">" mov $%d, %%rax</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>

    <span class="k">case</span> <span class="n">ND_NEG</span><span class="p">:</span>
    <span class="n">gen_expr</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">lhs</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">" neg %%rax</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>

    <span class="k">case</span> <span class="n">ND_VAR</span><span class="p">:</span>
    <span class="n">gen_addr</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"  mov (%%rax), %%rax</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;;</span>

    <span class="k">case</span> <span class="n">ND_ASSIGN</span><span class="p">:</span>
    <span class="n">gen_addr</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">lhs</span><span class="p">);</span>
    <span class="n">push</span><span class="p">();</span>
    <span class="n">gen_expr</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">rhs</span><span class="p">);</span>
    <span class="n">pop</span><span class="p">(</span><span class="s">"%rdi"</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"  mov %%rax, (%%rdi)</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

</code></pre></div></div> <p>Only use stack memory to store value of variable. Each single letter variable takes 8 bytes memory space.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">gen_addr</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">kind</span> <span class="o">==</span> <span class="n">ND_VAR</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">-</span> <span class="sc">'a'</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">8</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"  lea %d(%%rbp), %%rax</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">-</span><span class="n">offset</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">error</span><span class="p">(</span><span class="s">"not an lvalue"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="compiler"/><category term="c"/><category term="compiler"/><summary type="html"><![CDATA[Add single letter identity in c compiler Need to allocate memory address for single letter variable.]]></summary></entry><entry><title type="html">C compiler - parse example walkthrough</title><link href="https://bilyz98.github.io/blog/2024/statement-and-comparison/" rel="alternate" type="text/html" title="C compiler - parse example walkthrough"/><published>2024-10-14T11:59:00+00:00</published><updated>2024-10-14T11:59:00+00:00</updated><id>https://bilyz98.github.io/blog/2024/statement-and-comparison</id><content type="html" xml:base="https://bilyz98.github.io/blog/2024/statement-and-comparison/"><![CDATA[<h2 id="abstract-syntax-tree-generation-example">Abstract syntax tree generation example</h2> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"5+20-4;"
</code></pre></div></div> <pre><code class="language-asm">  .globl main
main: 
 mov $4, %rax
 push %rax
 mov $20, %rax
 push %rax
 mov $5, %rax
 pop %rdi
 add %rdi, %rax
 pop %rdi
 sub %rdi, %rax
  ret
</code></pre> <p>The parse tree looks like this</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     â”€  
   /  \ 
  +    4
/  \    
5  20
</code></pre></div></div> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">gen_expr</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">switch</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">kind</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">ND_NUM</span><span class="p">:</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">" mov $%d, %%rax</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>

    <span class="k">case</span> <span class="n">ND_NEG</span><span class="p">:</span>
    <span class="n">gen_expr</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">lhs</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">" neg %%rax</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">gen_expr</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">rhs</span><span class="p">);</span>
  <span class="n">push</span><span class="p">();</span>
  <span class="n">gen_expr</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">lhs</span><span class="p">);</span>
  <span class="n">pop</span><span class="p">(</span><span class="s">"%rdi"</span><span class="p">);</span>

  <span class="k">switch</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">kind</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">ND_ADD</span><span class="p">:</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">" add %%rdi, %%rax</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
    
    <span class="k">case</span> <span class="n">ND_SUB</span><span class="p">:</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">" sub %%rdi, %%rax</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>


</code></pre></div></div>]]></content><author><name></name></author><category term="compiler"/><category term="c"/><category term="compiler"/><summary type="html"><![CDATA[Abstract syntax tree generation example "5+20-4;"]]></summary></entry><entry><title type="html">Linux get cpu time and wall clock time</title><link href="https://bilyz98.github.io/blog/2024/get-function-cpu-time/" rel="alternate" type="text/html" title="Linux get cpu time and wall clock time"/><published>2024-10-13T11:59:00+00:00</published><updated>2024-10-13T11:59:00+00:00</updated><id>https://bilyz98.github.io/blog/2024/get-function-cpu-time</id><content type="html" xml:base="https://bilyz98.github.io/blog/2024/get-function-cpu-time/"><![CDATA[<h2 id="difference-between-wall-clock-time-and-cpu-time">Difference between wall clock time and cpu time</h2> <p>The difference between CPU time and system clock time (also known as wall-clock time) is an important concept in performance measurement:</p> <p><strong>CPU Time:</strong></p> <ul> <li><strong>User CPU Time</strong>: The amount of time the CPU spends executing code in user mode, outside the kernel.</li> <li><strong>System CPU Time</strong>: The amount of time the CPU spends executing code in kernel mode, on behalf of the process.</li> <li><strong>Total CPU Time</strong>: The sum of user and system CPU time, representing the total time the CPU was actively working on a specific process.</li> </ul> <p><strong>System Clock Time (Wall-Clock Time):</strong></p> <ul> <li>This is the real-world elapsed time from the start to the end of a process, as if measured by a stopwatch.</li> <li>It includes all time, including time spent waiting for I/O operations, network responses, or other processes to complete.</li> </ul> <p><strong>Key Differences:</strong></p> <ul> <li><strong>CPU time</strong> only accounts for the time the CPU is actively working on a task, while <strong>wall-clock time</strong> includes all waiting periods.</li> <li><strong>Wall-clock time</strong> is always greater than or equal to <strong>CPU time</strong> for a single-threaded process.</li> <li>For multi-threaded processes, <strong>CPU time</strong> can exceed <strong>wall-clock time</strong> if multiple threads are running in parallel on multiple CPU cores.</li> </ul> <p><strong>Example:</strong> If a program takes 2 seconds of CPU time but 5 seconds of wall-clock time, it means the program was waiting for 3 seconds (e.g., for I/O operations or network responses).</p> <p>Understanding these differences can help identify performance bottlenecks. If CPU time is close to wall-clock time, the process is CPU-bound. If wall-clock time is significantly higher, the process is likely I/O-bound or waiting on other resources.</p> <h2 id="get-cpu-time-in-rocksdb">Get cpu time in rocksdb</h2> <p>https://github.com/BilyZ98/rocksdb_kv_sep/blob/8a5f06aef1d74d4dace2ffdcd2f07b90ddcff083/db/flush_job.cc#L697</p> <p>Wall clock time: <code class="language-plaintext highlighter-rouge">CLOCK_MONOTONIC</code> is used to get wall clock time</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">uint64_t</span> <span class="n">NowNanos</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
<span class="cp">#if defined(OS_LINUX) || defined(OS_FREEBSD) || defined(OS_GNU_KFREEBSD) || \
    defined(OS_AIX)
</span>    <span class="k">struct</span> <span class="nc">timespec</span> <span class="n">ts</span><span class="p">;</span>
    <span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ts</span><span class="p">);</span>
    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ts</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000000000</span> <span class="o">+</span> <span class="n">ts</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">;</span>
<span class="cp">#elif defined(OS_SOLARIS)
</span>    <span class="k">return</span> <span class="n">gethrtime</span><span class="p">();</span>
<span class="cp">#elif defined(__MACH__)
</span>    <span class="n">clock_serv_t</span> <span class="n">cclock</span><span class="p">;</span>
    <span class="n">mach_timespec_t</span> <span class="n">ts</span><span class="p">;</span>
    <span class="n">host_get_clock_service</span><span class="p">(</span><span class="n">mach_host_self</span><span class="p">(),</span> <span class="n">CALENDAR_CLOCK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cclock</span><span class="p">);</span>
    <span class="n">clock_get_time</span><span class="p">(</span><span class="n">cclock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ts</span><span class="p">);</span>
    <span class="n">mach_port_deallocate</span><span class="p">(</span><span class="n">mach_task_self</span><span class="p">(),</span> <span class="n">cclock</span><span class="p">);</span>
    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ts</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000000000</span> <span class="o">+</span> <span class="n">ts</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">;</span>
<span class="cp">#else
</span>    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">nanoseconds</span><span class="o">&gt;</span><span class="p">(</span>
               <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">steady_clock</span><span class="o">::</span><span class="n">now</span><span class="p">().</span><span class="n">time_since_epoch</span><span class="p">())</span>
        <span class="p">.</span><span class="n">count</span><span class="p">();</span>
<span class="cp">#endif
</span>  <span class="p">}</span>
</code></pre></div></div> <p>CPU time: <code class="language-plaintext highlighter-rouge">CLOCK_THREAD_CPUTIME_ID</code> is used to get cpu time</p> <p>https://github.com/BilyZ98/rocksdb_kv_sep/blob/8a5f06aef1d74d4dace2ffdcd2f07b90ddcff083/env/env_posix.cc#L164</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">uint64_t</span> <span class="n">CPUMicros</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
<span class="cp">#if defined(OS_LINUX) || defined(OS_FREEBSD) || defined(OS_GNU_KFREEBSD) || \
    defined(OS_AIX) || (defined(__MACH__) &amp;&amp; defined(__MAC_10_12))
</span>    <span class="k">struct</span> <span class="nc">timespec</span> <span class="n">ts</span><span class="p">;</span>
    <span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_THREAD_CPUTIME_ID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ts</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ts</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000000000</span> <span class="o">+</span> <span class="n">ts</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">;</span>
<span class="cp">#endif
</span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="os"/><category term="c"/><category term="linux"/><summary type="html"><![CDATA[Difference between wall clock time and cpu time The difference between CPU time and system clock time (also known as wall-clock time) is an important concept in performance measurement:]]></summary></entry><entry><title type="html">Simple c compiler unary</title><link href="https://bilyz98.github.io/blog/2024/chibicc-unary/" rel="alternate" type="text/html" title="Simple c compiler unary"/><published>2024-10-10T11:59:00+00:00</published><updated>2024-10-10T11:59:00+00:00</updated><id>https://bilyz98.github.io/blog/2024/chibicc-unary</id><content type="html" xml:base="https://bilyz98.github.io/blog/2024/chibicc-unary/"><![CDATA[<h2 id="add-unary-to-parser">Add unary to parser</h2> <p><a href="./2024-10-12-chibicc-gen-expr.md">Previous parser post</a></p> <p>Add unary symbol in mul. Add unary node kind and replace primary with unary. unary is a super set of unary and primary.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// expr = unary ("*" unary | "/" unary)*</span>
<span class="k">static</span> <span class="n">Node</span><span class="o">*</span> <span class="nf">mul</span><span class="p">(</span><span class="n">Token</span><span class="o">**</span><span class="n">rest</span><span class="p">,</span> <span class="n">Token</span><span class="o">*</span> <span class="n">tok</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">unary</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">tok</span><span class="p">);</span>

  <span class="k">for</span><span class="p">(;;)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">equal</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">"*"</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">node</span> <span class="o">=</span>  <span class="n">new_binary</span><span class="p">(</span><span class="n">ND_MUL</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">unary</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">));</span>
      <span class="k">continue</span><span class="p">;;</span>
    <span class="p">}</span>

    <span class="k">if</span><span class="p">(</span><span class="n">equal</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">"/"</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">node</span> <span class="o">=</span> <span class="n">new_binary</span><span class="p">(</span><span class="n">ND_DIV</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">unary</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">));</span>
      <span class="k">continue</span><span class="p">;;</span>
    <span class="p">}</span>

    <span class="o">*</span><span class="n">rest</span> <span class="o">=</span> <span class="n">tok</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>


<span class="c1">// unary = ("+" | "-") unary | primary</span>
<span class="k">static</span> <span class="n">Node</span><span class="o">*</span> <span class="nf">unary</span><span class="p">(</span><span class="n">Token</span> <span class="o">**</span><span class="n">rest</span><span class="p">,</span> <span class="n">Token</span><span class="o">*</span> <span class="n">tok</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="n">equal</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">"+"</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">unary</span><span class="p">(</span><span class="n">rest</span><span class="p">,</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>

  <span class="k">if</span><span class="p">(</span><span class="n">equal</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">"-"</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">new_unary</span><span class="p">(</span><span class="n">ND_NEG</span><span class="p">,</span> <span class="n">unary</span><span class="p">(</span><span class="n">rest</span><span class="p">,</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">));</span>

  <span class="k">return</span> <span class="n">primary</span><span class="p">(</span><span class="n">rest</span><span class="p">,</span> <span class="n">tok</span><span class="p">);</span>

<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="compiler"/><category term="c"/><category term="compiler"/><summary type="html"><![CDATA[Add unary to parser Previous parser post]]></summary></entry><entry><title type="html">Simple c compiler gen expr</title><link href="https://bilyz98.github.io/blog/2024/chibicc-gen-expr/" rel="alternate" type="text/html" title="Simple c compiler gen expr"/><published>2024-10-09T11:59:00+00:00</published><updated>2024-10-09T11:59:00+00:00</updated><id>https://bilyz98.github.io/blog/2024/chibicc-gen-expr</id><content type="html" xml:base="https://bilyz98.github.io/blog/2024/chibicc-gen-expr/"><![CDATA[<p>Once we have the tokenize we can then write parser code to generate abstract syntax tree by traversing the token list. We use stack to generate tree.</p> <p><code class="language-plaintext highlighter-rouge">'+'</code> has the lowest priority. Number and <code class="language-plaintext highlighter-rouge">(expr)</code>has highest parsing priority.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// expr = mul ("+" mul | "-" mul)*</span>
<span class="k">static</span> <span class="n">Node</span><span class="o">*</span> <span class="nf">expr</span><span class="p">(</span><span class="n">Token</span> <span class="o">**</span><span class="n">rest</span><span class="p">,</span> <span class="n">Token</span><span class="o">*</span> <span class="n">tok</span><span class="p">){</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">node</span><span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">tok</span><span class="p">);</span>

  <span class="k">for</span><span class="p">(;;){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">equal</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">"+"</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">node</span> <span class="o">=</span> <span class="n">new_binary</span><span class="p">(</span><span class="n">ND_ADD</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">mul</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">));</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span><span class="p">(</span><span class="n">equal</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">"-"</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">node</span> <span class="o">=</span> <span class="n">new_binary</span><span class="p">(</span><span class="n">ND_SUB</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">mul</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">));</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="o">*</span><span class="n">rest</span> <span class="o">=</span> <span class="n">tok</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">node</span><span class="p">;</span>

  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// expr = primary ("*" primary | "/" primary)*</span>
<span class="k">static</span> <span class="n">Node</span><span class="o">*</span> <span class="nf">mul</span><span class="p">(</span><span class="n">Token</span><span class="o">**</span><span class="n">rest</span><span class="p">,</span> <span class="n">Token</span><span class="o">*</span> <span class="n">tok</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">primary</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">tok</span><span class="p">);</span>

  <span class="k">for</span><span class="p">(;;)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">equal</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">"*"</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">node</span> <span class="o">=</span>  <span class="n">new_binary</span><span class="p">(</span><span class="n">ND_MUL</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">primary</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">));</span>
      <span class="k">continue</span><span class="p">;;</span>
    <span class="p">}</span>

    <span class="k">if</span><span class="p">(</span><span class="n">equal</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">"/"</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">node</span> <span class="o">=</span> <span class="n">new_binary</span><span class="p">(</span><span class="n">ND_DIV</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">primary</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">));</span>
      <span class="k">continue</span><span class="p">;;</span>
    <span class="p">}</span>

    <span class="o">*</span><span class="n">rest</span> <span class="o">=</span> <span class="n">tok</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// primary = "(" expr ")" | num</span>
<span class="k">static</span> <span class="n">Node</span><span class="o">*</span> <span class="nf">primary</span><span class="p">(</span><span class="n">Token</span> <span class="o">**</span><span class="n">rest</span><span class="p">,</span> <span class="n">Token</span><span class="o">*</span> <span class="n">tok</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="n">equal</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">"("</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">expr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
    <span class="o">*</span><span class="n">rest</span> <span class="o">=</span> <span class="n">skip</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">")"</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span><span class="p">(</span><span class="n">tok</span><span class="o">-&gt;</span><span class="n">kind</span>  <span class="o">==</span> <span class="n">TK_NUM</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">new_num</span><span class="p">(</span><span class="n">tok</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
    <span class="o">*</span><span class="n">rest</span> <span class="o">=</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">error_tok</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">"expected an expression"</span><span class="p">);</span>

<span class="p">}</span>
</code></pre></div></div> <h2 id="order-of-parser-is-important">order of parser is important</h2> <p>The order of operations in the code snippet you provided is crucial for correctly evaluating the expression represented by the abstract syntax tree (AST). Letâ€™s go through the code step-by-step:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">gen_expr</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">rhs</span><span class="p">);</span>
<span class="n">push</span><span class="p">();</span>
<span class="n">gen_expr</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">lhs</span><span class="p">);</span>
<span class="n">pop</span><span class="p">(</span><span class="s">"%rdi"</span><span class="p">);</span>
</code></pre></div></div> <ol> <li><strong>Evaluate the Right Subtree</strong>: <code class="language-plaintext highlighter-rouge">gen_expr(node-&gt;rhs);</code> <ul> <li>This recursively generates code for the right-hand side expression of the current node. The result of this expression is expected to be in the <code class="language-plaintext highlighter-rouge">%rax</code> register.</li> </ul> </li> <li><strong>Push the Result of the Right Subtree</strong>: <code class="language-plaintext highlighter-rouge">push();</code> <ul> <li>The value in <code class="language-plaintext highlighter-rouge">%rax</code> (which is the result of the right-hand side expression) is pushed onto the stack. This saves the result so that the <code class="language-plaintext highlighter-rouge">%rax</code> register can be used for other purposes.</li> </ul> </li> <li><strong>Evaluate the Left Subtree</strong>: <code class="language-plaintext highlighter-rouge">gen_expr(node-&gt;lhs);</code> <ul> <li>This recursively generates code for the left-hand side expression of the current node. The result of this expression is also expected to be in the <code class="language-plaintext highlighter-rouge">%rax</code> register.</li> </ul> </li> <li><strong>Pop the Saved Right Subtree Result</strong>: <code class="language-plaintext highlighter-rouge">pop("%rdi");</code> <ul> <li>The value that was previously pushed onto the stack (the result of the right-hand side expression) is popped into the <code class="language-plaintext highlighter-rouge">%rdi</code> register.</li> </ul> </li> </ol> <p>The reason for this specific order is to ensure that the values of the left and right subtrees are correctly placed in the registers for further operations. By convention, the result of the left subtree is left in <code class="language-plaintext highlighter-rouge">%rax</code>, and the result of the right subtree is placed in <code class="language-plaintext highlighter-rouge">%rdi</code>. This is a common calling convention for binary operations where the left operand is in <code class="language-plaintext highlighter-rouge">%rax</code> and the right operand is in <code class="language-plaintext highlighter-rouge">%rdi</code>.</p> <p>This order of operations is necessary because the code generator needs to follow the calling convention and ensure that the values are in the correct registers before performing the operation represented by the current node. The <code class="language-plaintext highlighter-rouge">push</code> and <code class="language-plaintext highlighter-rouge">pop</code> operations are used to temporarily save and restore the values to maintain the correct evaluation order and register usage.</p> <h2 id="quotient-and-remainder-in-division">quotient and remainder in division</h2> <p>The <strong>quotient</strong> and <strong>remainder</strong> are the results of a division operation. The quotient is the number of times the divisor fits into the dividend, and the remainder is whatâ€™s left over after the division.</p> <p>Hereâ€™s a simple example to illustrate:</p> <p>Letâ€™s say we want to divide 17 by 5:</p> <ul> <li><strong>Dividend</strong>: 17</li> <li><strong>Divisor</strong>: 5</li> </ul> <p>When we divide 17 by 5, we get:</p> <ul> <li><strong>Quotient</strong>: 3 (because 5 fits into 17 three times)</li> <li><strong>Remainder</strong>: 2 (because after taking away 15, which is 5 times 3, from 17, we have 2 left over)</li> </ul> <p>So, in mathematical terms: [ 17 \div 5 = 3 \text{ remainder } 2 ]</p> <p>In the context of the <code class="language-plaintext highlighter-rouge">idiv</code> instruction in assembly language:</p> <ul> <li>The quotient is stored in the <code class="language-plaintext highlighter-rouge">%rax</code> register.</li> <li>The remainder is stored in the <code class="language-plaintext highlighter-rouge">%rdx</code> register.</li> </ul> <p>This is how the division operation works at a fundamental level, and itâ€™s the same concept used in assembly language for the <code class="language-plaintext highlighter-rouge">idiv</code> instruction. The <code class="language-plaintext highlighter-rouge">idiv</code> instruction performs a division and stores the quotient and remainder in the appropriate registers.</p>]]></content><author><name></name></author><category term="compiler"/><category term="c"/><category term="compiler"/><summary type="html"><![CDATA[Once we have the tokenize we can then write parser code to generate abstract syntax tree by traversing the token list. We use stack to generate tree.]]></summary></entry><entry><title type="html">Python pyplot trick</title><link href="https://bilyz98.github.io/blog/2024/python-plot-trick/" rel="alternate" type="text/html" title="Python pyplot trick"/><published>2024-09-20T11:59:00+00:00</published><updated>2024-09-20T11:59:00+00:00</updated><id>https://bilyz98.github.io/blog/2024/python-plot-trick</id><content type="html" xml:base="https://bilyz98.github.io/blog/2024/python-plot-trick/"><![CDATA[<p>grey line for y axis.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import matplotlib.pyplot as plt

# Create a plot
plt.figure()

# Add solid horizontal lines with light grey color at y = 20, y = 40, y = 60
plt.axhline(y=20, color='lightgrey', linestyle='-')
plt.axhline(y=40, color='lightgrey', linestyle='-')
plt.axhline(y=60, color='lightgrey', linestyle='-')

# Display the plot
plt.show()

</code></pre></div></div> <p>At the back of the bar chart</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import matplotlib.pyplot as plt
import numpy as np

# Sample data for bar chart
x = np.arange(5)
y = [10, 30, 50, 70, 90]

# Create a plot
fig, ax = plt.subplots()

# Plot the bar chart
ax.bar(x, y)

# Add solid horizontal lines with light grey color at y = 20, y = 40, y = 60
ax.axhline(y=20, color='lightgrey', linestyle='-', zorder=0)
ax.axhline(y=40, color='lightgrey', linestyle='-', zorder=0)
ax.axhline(y=60, color='lightgrey', linestyle='-', zorder=0)

# Display the plot
plt.show()

</code></pre></div></div>]]></content><author><name></name></author><category term="python"/><category term="python"/><summary type="html"><![CDATA[grey line for y axis. ``` import matplotlib.pyplot as plt]]></summary></entry><entry><title type="html">Python capture function print output</title><link href="https://bilyz98.github.io/blog/2024/capture-output-python/" rel="alternate" type="text/html" title="Python capture function print output"/><published>2024-08-24T11:59:00+00:00</published><updated>2024-08-24T11:59:00+00:00</updated><id>https://bilyz98.github.io/blog/2024/capture-output-python</id><content type="html" xml:base="https://bilyz98.github.io/blog/2024/capture-output-python/"><![CDATA[<p>You can redirect the output of the <code class="language-plaintext highlighter-rouge">print</code> function to a string in Python using the <code class="language-plaintext highlighter-rouge">io.StringIO</code> class from the <code class="language-plaintext highlighter-rouge">io</code> module. Hereâ€™s a simple example to demonstrate how you can achieve this:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">io</span>
<span class="kn">import</span> <span class="n">sys</span>

<span class="k">def</span> <span class="nf">capture_print_output</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="c1"># Create a StringIO object to capture the output
</span>    <span class="n">captured_output</span> <span class="o">=</span> <span class="n">io</span><span class="p">.</span><span class="nc">StringIO</span><span class="p">()</span>
    <span class="c1"># Redirect sys.stdout to the StringIO object
</span>    <span class="n">sys</span><span class="p">.</span><span class="n">stdout</span> <span class="o">=</span> <span class="n">captured_output</span>
    
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Call the function with the provided arguments
</span>        <span class="nf">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="c1"># Reset sys.stdout to its original value
</span>        <span class="n">sys</span><span class="p">.</span><span class="n">stdout</span> <span class="o">=</span> <span class="n">sys</span><span class="p">.</span><span class="n">__stdout__</span>
    
    <span class="c1"># Get the captured output as a string
</span>    <span class="k">return</span> <span class="n">captured_output</span><span class="p">.</span><span class="nf">getvalue</span><span class="p">()</span>

<span class="c1"># Example function that prints something
</span><span class="k">def</span> <span class="nf">example_function</span><span class="p">():</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Hello, World!</span><span class="sh">"</span><span class="p">)</span>

<span class="c1"># Capture the output of the example_function
</span><span class="n">output</span> <span class="o">=</span> <span class="nf">capture_print_output</span><span class="p">(</span><span class="n">example_function</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Captured Output:</span><span class="sh">"</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
</code></pre></div></div> <p>In this example:</p> <ol> <li>We create a <code class="language-plaintext highlighter-rouge">StringIO</code> object to capture the output.</li> <li>We redirect <code class="language-plaintext highlighter-rouge">sys.stdout</code> to the <code class="language-plaintext highlighter-rouge">StringIO</code> object.</li> <li>We call the function whose output we want to capture.</li> <li>We reset <code class="language-plaintext highlighter-rouge">sys.stdout</code> to its original value.</li> <li>We retrieve the captured output as a string using the <code class="language-plaintext highlighter-rouge">getvalue()</code> method.</li> </ol> <p>Feel free to adapt this code to fit your specific needs! If you have any other questions or need further assistance, just let me know.</p> <p>Source: Conversation with Copilot, 8/26/2024 (1) How can I redirect print output of a function in python. https://stackoverflow.com/questions/14197009/how-can-i-redirect-print-%20%20output-of-a-function-in-python%20/%2014197079. (2) How do I redirect output of multiple functions to string or stdout in â€¦. https://stackoverflow.com/questions/64199833/how-do-i-redirect-output-of-multiple-functions-to-string-or-stdout-in-python-t. (3) How to assign Print output to a Variable in Python | bobbyhadz. https://bobbyhadz.com/blog/python-assign-string-output-to-variable. (4) Python 101: Redirecting stdout - Mouse Vs Python. https://www.blog.pythonlibrary.org/2016/06/16/python-101-redirecting-stdout/.</p>]]></content><author><name></name></author><category term="python"/><category term="python"/><summary type="html"><![CDATA[You can redirect the output of the print function to a string in Python using the io.StringIO class from the io module. Hereâ€™s a simple example to demonstrate how you can achieve this:]]></summary></entry><entry><title type="html">Simple lru cache cpp implementation</title><link href="https://bilyz98.github.io/blog/2024/lru-cache/" rel="alternate" type="text/html" title="Simple lru cache cpp implementation"/><published>2024-08-24T11:59:00+00:00</published><updated>2024-08-24T11:59:00+00:00</updated><id>https://bilyz98.github.io/blog/2024/lru-cache</id><content type="html" xml:base="https://bilyz98.github.io/blog/2024/lru-cache/"><![CDATA[<p>Use std::list and std::map</p> <p>To get more low level. One should implement list himself/herself.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cassert&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;list&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Cache</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Cache</span><span class="p">(</span><span class="kt">int</span> <span class="n">cap</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cap_</span> <span class="o">=</span> <span class="n">cap</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kt">int</span> <span class="nf">get</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">map_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">!=</span> <span class="n">map_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
      <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">map_</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
      <span class="n">moveToFront</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">value</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

  <span class="p">}</span>

  <span class="kt">void</span> <span class="nf">put</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">map_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">!=</span> <span class="n">map_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">moveToFront</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">items_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">cap_</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// remove the tail key from list and map</span>
      <span class="kt">int</span> <span class="n">tail_key</span> <span class="o">=</span> <span class="n">items_</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">second</span><span class="p">;</span>
      <span class="k">auto</span> <span class="n">tail_key_iter</span> <span class="o">=</span> <span class="n">map_</span><span class="p">[</span><span class="n">tail_key</span><span class="p">];</span> 
      <span class="c1">// does the order matter?</span>
      <span class="n">map_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">tail_key</span><span class="p">);</span>
      <span class="c1">// items_.erase(tail_key_iter);</span>
      <span class="n">items_</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">items_</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">));</span>
    <span class="n">map_</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">items_</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
  <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="kt">void</span> <span class="nf">moveToFront</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">items_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">map_</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span>
    <span class="n">items_</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">));</span>
    <span class="c1">// map_.insert(std::make_pair(key, items_.begin()));</span>
    <span class="n">map_</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">items_</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="kt">int</span> <span class="n">cap_</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">items_</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;::</span><span class="n">iterator</span><span class="o">&gt;</span> <span class="n">map_</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">cache</span> <span class="o">=</span>   <span class="n">Cache</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
  <span class="n">cache</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span> <span class="p">);</span>
  <span class="n">cache</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span> <span class="p">);</span>
  <span class="n">cache</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">cache</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">cache</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">cache</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">);</span>

  <span class="n">cache</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">cache</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

  <span class="n">assert</span><span class="p">(</span><span class="n">cache</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">);</span>
  <span class="n">cache</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">cache</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"OK</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

<span class="p">}</span>
</code></pre></div></div> <h3 id="cpp-constructor">Cpp constructor</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">LRUCache</span><span class="o">::</span><span class="n">LRUCache</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">capacity</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_shard_bits</span><span class="p">,</span>
                   <span class="kt">bool</span> <span class="n">strict_capacity_limit</span><span class="p">,</span> <span class="kt">double</span> <span class="n">high_pri_pool_ratio</span><span class="p">,</span>
                   <span class="kt">double</span> <span class="n">low_pri_pool_ratio</span><span class="p">,</span>
                   <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">MemoryAllocator</span><span class="o">&gt;</span> <span class="n">allocator</span><span class="p">,</span>
                   <span class="kt">bool</span> <span class="n">use_adaptive_mutex</span><span class="p">,</span>
                   <span class="n">CacheMetadataChargePolicy</span> <span class="n">metadata_charge_policy</span><span class="p">,</span>
                   <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">SecondaryCache</span><span class="o">&gt;</span> <span class="n">_secondary_cache</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">ShardedCache</span><span class="p">(</span><span class="n">capacity</span><span class="p">,</span> <span class="n">num_shard_bits</span><span class="p">,</span> <span class="n">strict_capacity_limit</span><span class="p">,</span>
                   <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">allocator</span><span class="p">)),</span>
      <span class="n">secondary_cache_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">_secondary_cache</span><span class="p">))</span> <span class="p">{</span>
  <span class="kt">size_t</span> <span class="n">per_shard</span> <span class="o">=</span> <span class="n">GetPerShardCapacity</span><span class="p">();</span>
  <span class="n">SecondaryCache</span><span class="o">*</span> <span class="n">secondary_cache</span> <span class="o">=</span> <span class="n">secondary_cache_</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
  <span class="n">MemoryAllocator</span><span class="o">*</span> <span class="n">alloc</span> <span class="o">=</span> <span class="n">memory_allocator</span><span class="p">();</span>
  <span class="n">InitShards</span><span class="p">([</span><span class="o">=</span><span class="p">](</span><span class="n">LRUCacheShard</span><span class="o">*</span> <span class="n">cs</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">new</span> <span class="p">(</span><span class="n">cs</span><span class="p">)</span> <span class="n">LRUCacheShard</span><span class="p">(</span>
        <span class="n">per_shard</span><span class="p">,</span> <span class="n">strict_capacity_limit</span><span class="p">,</span> <span class="n">high_pri_pool_ratio</span><span class="p">,</span>
        <span class="n">low_pri_pool_ratio</span><span class="p">,</span> <span class="n">use_adaptive_mutex</span><span class="p">,</span> <span class="n">metadata_charge_policy</span><span class="p">,</span>
        <span class="cm">/* max_upper_hash_bits */</span> <span class="mi">32</span> <span class="o">-</span> <span class="n">num_shard_bits</span><span class="p">,</span> <span class="n">alloc</span><span class="p">,</span> <span class="n">secondary_cache</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">[=]</code> is capture clause and itâ€™s used forthe lambda function to to capture all local variables by value.</p> <p>Lambda function makes a copy of each variable so updating variables inside the lambda does not affect the original variables outside the lambda.</p> <h3 id="lru-cache-in-rocksdb">lru cache in rocksdb</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Status</span> <span class="n">LRUCacheShard</span><span class="o">::</span><span class="n">Insert</span><span class="p">(</span><span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">hash</span><span class="p">,</span>
                             <span class="n">Cache</span><span class="o">::</span><span class="n">ObjectPtr</span> <span class="n">value</span><span class="p">,</span>
                             <span class="k">const</span> <span class="n">Cache</span><span class="o">::</span><span class="n">CacheItemHelper</span><span class="o">*</span> <span class="n">helper</span><span class="p">,</span>
                             <span class="kt">size_t</span> <span class="n">charge</span><span class="p">,</span> <span class="n">LRUHandle</span><span class="o">**</span> <span class="n">handle</span><span class="p">,</span>
                             <span class="n">Cache</span><span class="o">::</span><span class="n">Priority</span> <span class="n">priority</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">helper</span><span class="p">);</span>

  <span class="c1">// Allocate the memory here outside of the mutex.</span>
  <span class="c1">// If the cache is full, we'll have to release it.</span>
  <span class="c1">// It shouldn't happen very often though.</span>
  <span class="n">LRUHandle</span><span class="o">*</span> <span class="n">e</span> <span class="o">=</span>
      <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">LRUHandle</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">LRUHandle</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">key</span><span class="p">.</span><span class="n">size</span><span class="p">()));</span>

  <span class="n">e</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
  <span class="n">e</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">e</span><span class="o">-&gt;</span><span class="n">im_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">e</span><span class="o">-&gt;</span><span class="n">helper</span> <span class="o">=</span> <span class="n">helper</span><span class="p">;</span>
  <span class="n">e</span><span class="o">-&gt;</span><span class="n">key_length</span> <span class="o">=</span> <span class="n">key</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
  <span class="n">e</span><span class="o">-&gt;</span><span class="n">hash</span> <span class="o">=</span> <span class="n">hash</span><span class="p">;</span>
  <span class="n">e</span><span class="o">-&gt;</span><span class="n">refs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">e</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
  <span class="n">e</span><span class="o">-&gt;</span><span class="n">SetInCache</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
  <span class="n">e</span><span class="o">-&gt;</span><span class="n">SetPriority</span><span class="p">(</span><span class="n">priority</span><span class="p">);</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">key_data</span><span class="p">,</span> <span class="n">key</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">key</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
  <span class="n">e</span><span class="o">-&gt;</span><span class="n">CalcTotalCharge</span><span class="p">(</span><span class="n">charge</span><span class="p">,</span> <span class="n">metadata_charge_policy_</span><span class="p">);</span>

  <span class="c1">// value == nullptr is reserved for indicating failure for when secondary</span>
  <span class="c1">// cache compatible</span>
  <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">IsSecondaryCacheCompatible</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">value</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">));</span>

  <span class="k">return</span> <span class="n">InsertItem</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">handle</span><span class="p">,</span> <span class="cm">/* free_handle_on_fail */</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Status</span> <span class="n">LRUCacheShard</span><span class="o">::</span><span class="n">InsertItem</span><span class="p">(</span><span class="n">LRUHandle</span><span class="o">*</span> <span class="n">e</span><span class="p">,</span> <span class="n">LRUHandle</span><span class="o">**</span> <span class="n">handle</span><span class="p">,</span>
                                 <span class="kt">bool</span> <span class="n">free_handle_on_fail</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Status</span> <span class="n">s</span> <span class="o">=</span> <span class="n">Status</span><span class="o">::</span><span class="n">OK</span><span class="p">();</span>
  <span class="n">autovector</span><span class="o">&lt;</span><span class="n">LRUHandle</span><span class="o">*&gt;</span> <span class="n">last_reference_list</span><span class="p">;</span>

  <span class="p">{</span>
    <span class="n">DMutexLock</span> <span class="n">l</span><span class="p">(</span><span class="n">mutex_</span><span class="p">);</span>

    <span class="c1">// Free the space following strict LRU policy until enough space</span>
    <span class="c1">// is freed or the lru list is empty.</span>
    <span class="n">EvictFromLRU</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">total_charge</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">last_reference_list</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">usage_</span> <span class="o">+</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">total_charge</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">capacity_</span> <span class="o">&amp;&amp;</span>
        <span class="p">(</span><span class="n">strict_capacity_limit_</span> <span class="o">||</span> <span class="n">handle</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">e</span><span class="o">-&gt;</span><span class="n">SetInCache</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">handle</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Don't insert the entry but still return ok, as if the entry inserted</span>
        <span class="c1">// into cache and get evicted immediately.</span>
        <span class="n">last_reference_list</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">free_handle_on_fail</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">free</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
          <span class="o">*</span><span class="n">handle</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">Status</span><span class="o">::</span><span class="n">MemoryLimit</span><span class="p">(</span><span class="s">"Insert failed due to LRU cache being full."</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// Insert into the cache. Note that the cache might get larger than its</span>
      <span class="c1">// capacity if not enough space was freed up.</span>
      <span class="n">LRUHandle</span><span class="o">*</span> <span class="n">old</span> <span class="o">=</span> <span class="n">table_</span><span class="p">.</span><span class="n">Insert</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
      <span class="n">usage_</span> <span class="o">+=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">total_charge</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">old</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">Status</span><span class="o">::</span><span class="n">OkOverwritten</span><span class="p">();</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">InCache</span><span class="p">());</span>
        <span class="n">old</span><span class="o">-&gt;</span><span class="n">SetInCache</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">HasRefs</span><span class="p">())</span> <span class="p">{</span>
          <span class="c1">// old is on LRU because it's in cache and its reference count is 0.</span>
          <span class="n">LRU_Remove</span><span class="p">(</span><span class="n">old</span><span class="p">);</span>
          <span class="n">assert</span><span class="p">(</span><span class="n">usage_</span> <span class="o">&gt;=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">total_charge</span><span class="p">);</span>
          <span class="n">usage_</span> <span class="o">-=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">total_charge</span><span class="p">;</span>
          <span class="n">last_reference_list</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">old</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">handle</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">LRU_Insert</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// If caller already holds a ref, no need to take one here.</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">HasRefs</span><span class="p">())</span> <span class="p">{</span>
          <span class="n">e</span><span class="o">-&gt;</span><span class="n">Ref</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="o">*</span><span class="n">handle</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">TryInsertIntoSecondaryCache</span><span class="p">(</span><span class="n">last_reference_list</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="cpp"/><category term="cpp"/><category term="programming"/><summary type="html"><![CDATA[Use std::list and std::map]]></summary></entry></feed>