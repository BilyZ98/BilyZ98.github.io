<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://bilyz98.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://bilyz98.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-08-27T08:21:22+00:00</updated><id>https://bilyz98.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Python capture function print output</title><link href="https://bilyz98.github.io/blog/2024/capture-output-python/" rel="alternate" type="text/html" title="Python capture function print output"/><published>2024-08-24T11:59:00+00:00</published><updated>2024-08-24T11:59:00+00:00</updated><id>https://bilyz98.github.io/blog/2024/capture-output-python</id><content type="html" xml:base="https://bilyz98.github.io/blog/2024/capture-output-python/"><![CDATA[<p>You can redirect the output of the <code class="language-plaintext highlighter-rouge">print</code> function to a string in Python using the <code class="language-plaintext highlighter-rouge">io.StringIO</code> class from the <code class="language-plaintext highlighter-rouge">io</code> module. Here’s a simple example to demonstrate how you can achieve this:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">io</span>
<span class="kn">import</span> <span class="n">sys</span>

<span class="k">def</span> <span class="nf">capture_print_output</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="c1"># Create a StringIO object to capture the output
</span>    <span class="n">captured_output</span> <span class="o">=</span> <span class="n">io</span><span class="p">.</span><span class="nc">StringIO</span><span class="p">()</span>
    <span class="c1"># Redirect sys.stdout to the StringIO object
</span>    <span class="n">sys</span><span class="p">.</span><span class="n">stdout</span> <span class="o">=</span> <span class="n">captured_output</span>
    
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Call the function with the provided arguments
</span>        <span class="nf">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="c1"># Reset sys.stdout to its original value
</span>        <span class="n">sys</span><span class="p">.</span><span class="n">stdout</span> <span class="o">=</span> <span class="n">sys</span><span class="p">.</span><span class="n">__stdout__</span>
    
    <span class="c1"># Get the captured output as a string
</span>    <span class="k">return</span> <span class="n">captured_output</span><span class="p">.</span><span class="nf">getvalue</span><span class="p">()</span>

<span class="c1"># Example function that prints something
</span><span class="k">def</span> <span class="nf">example_function</span><span class="p">():</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Hello, World!</span><span class="sh">"</span><span class="p">)</span>

<span class="c1"># Capture the output of the example_function
</span><span class="n">output</span> <span class="o">=</span> <span class="nf">capture_print_output</span><span class="p">(</span><span class="n">example_function</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Captured Output:</span><span class="sh">"</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
</code></pre></div></div> <p>In this example:</p> <ol> <li>We create a <code class="language-plaintext highlighter-rouge">StringIO</code> object to capture the output.</li> <li>We redirect <code class="language-plaintext highlighter-rouge">sys.stdout</code> to the <code class="language-plaintext highlighter-rouge">StringIO</code> object.</li> <li>We call the function whose output we want to capture.</li> <li>We reset <code class="language-plaintext highlighter-rouge">sys.stdout</code> to its original value.</li> <li>We retrieve the captured output as a string using the <code class="language-plaintext highlighter-rouge">getvalue()</code> method.</li> </ol> <p>Feel free to adapt this code to fit your specific needs! If you have any other questions or need further assistance, just let me know.</p> <p>Source: Conversation with Copilot, 8/26/2024 (1) How can I redirect print output of a function in python. https://stackoverflow.com/questions/14197009/how-can-i-redirect-print-%20%20output-of-a-function-in-python%20/%2014197079. (2) How do I redirect output of multiple functions to string or stdout in …. https://stackoverflow.com/questions/64199833/how-do-i-redirect-output-of-multiple-functions-to-string-or-stdout-in-python-t. (3) How to assign Print output to a Variable in Python | bobbyhadz. https://bobbyhadz.com/blog/python-assign-string-output-to-variable. (4) Python 101: Redirecting stdout - Mouse Vs Python. https://www.blog.pythonlibrary.org/2016/06/16/python-101-redirecting-stdout/.</p>]]></content><author><name></name></author><category term="python"/><category term="python"/><summary type="html"><![CDATA[You can redirect the output of the print function to a string in Python using the io.StringIO class from the io module. Here’s a simple example to demonstrate how you can achieve this:]]></summary></entry><entry><title type="html">Simple lru cache cpp implementation</title><link href="https://bilyz98.github.io/blog/2024/lru-cache/" rel="alternate" type="text/html" title="Simple lru cache cpp implementation"/><published>2024-08-24T11:59:00+00:00</published><updated>2024-08-24T11:59:00+00:00</updated><id>https://bilyz98.github.io/blog/2024/lru-cache</id><content type="html" xml:base="https://bilyz98.github.io/blog/2024/lru-cache/"><![CDATA[<p>Use std::list and std::map</p> <p>To get more low level. One should implement list himself/herself.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cassert&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;list&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Cache</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Cache</span><span class="p">(</span><span class="kt">int</span> <span class="n">cap</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cap_</span> <span class="o">=</span> <span class="n">cap</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kt">int</span> <span class="nf">get</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">map_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">!=</span> <span class="n">map_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
      <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">map_</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
      <span class="n">moveToFront</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">value</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

  <span class="p">}</span>

  <span class="kt">void</span> <span class="nf">put</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">map_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">!=</span> <span class="n">map_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">moveToFront</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">items_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">cap_</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// remove the tail key from list and map</span>
      <span class="kt">int</span> <span class="n">tail_key</span> <span class="o">=</span> <span class="n">items_</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">second</span><span class="p">;</span>
      <span class="k">auto</span> <span class="n">tail_key_iter</span> <span class="o">=</span> <span class="n">map_</span><span class="p">[</span><span class="n">tail_key</span><span class="p">];</span> 
      <span class="c1">// does the order matter?</span>
      <span class="n">map_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">tail_key</span><span class="p">);</span>
      <span class="c1">// items_.erase(tail_key_iter);</span>
      <span class="n">items_</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">items_</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">));</span>
    <span class="n">map_</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">items_</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
  <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="kt">void</span> <span class="nf">moveToFront</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">items_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">map_</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span>
    <span class="n">items_</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">));</span>
    <span class="c1">// map_.insert(std::make_pair(key, items_.begin()));</span>
    <span class="n">map_</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">items_</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="kt">int</span> <span class="n">cap_</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">items_</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;::</span><span class="n">iterator</span><span class="o">&gt;</span> <span class="n">map_</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">cache</span> <span class="o">=</span>   <span class="n">Cache</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
  <span class="n">cache</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span> <span class="p">);</span>
  <span class="n">cache</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span> <span class="p">);</span>
  <span class="n">cache</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">cache</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">cache</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">cache</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">);</span>

  <span class="n">cache</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">cache</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

  <span class="n">assert</span><span class="p">(</span><span class="n">cache</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">);</span>
  <span class="n">cache</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">cache</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"OK</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

<span class="p">}</span>
</code></pre></div></div> <h3 id="cpp-constructor">Cpp constructor</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">LRUCache</span><span class="o">::</span><span class="n">LRUCache</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">capacity</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_shard_bits</span><span class="p">,</span>
                   <span class="kt">bool</span> <span class="n">strict_capacity_limit</span><span class="p">,</span> <span class="kt">double</span> <span class="n">high_pri_pool_ratio</span><span class="p">,</span>
                   <span class="kt">double</span> <span class="n">low_pri_pool_ratio</span><span class="p">,</span>
                   <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">MemoryAllocator</span><span class="o">&gt;</span> <span class="n">allocator</span><span class="p">,</span>
                   <span class="kt">bool</span> <span class="n">use_adaptive_mutex</span><span class="p">,</span>
                   <span class="n">CacheMetadataChargePolicy</span> <span class="n">metadata_charge_policy</span><span class="p">,</span>
                   <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">SecondaryCache</span><span class="o">&gt;</span> <span class="n">_secondary_cache</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">ShardedCache</span><span class="p">(</span><span class="n">capacity</span><span class="p">,</span> <span class="n">num_shard_bits</span><span class="p">,</span> <span class="n">strict_capacity_limit</span><span class="p">,</span>
                   <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">allocator</span><span class="p">)),</span>
      <span class="n">secondary_cache_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">_secondary_cache</span><span class="p">))</span> <span class="p">{</span>
  <span class="kt">size_t</span> <span class="n">per_shard</span> <span class="o">=</span> <span class="n">GetPerShardCapacity</span><span class="p">();</span>
  <span class="n">SecondaryCache</span><span class="o">*</span> <span class="n">secondary_cache</span> <span class="o">=</span> <span class="n">secondary_cache_</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
  <span class="n">MemoryAllocator</span><span class="o">*</span> <span class="n">alloc</span> <span class="o">=</span> <span class="n">memory_allocator</span><span class="p">();</span>
  <span class="n">InitShards</span><span class="p">([</span><span class="o">=</span><span class="p">](</span><span class="n">LRUCacheShard</span><span class="o">*</span> <span class="n">cs</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">new</span> <span class="p">(</span><span class="n">cs</span><span class="p">)</span> <span class="n">LRUCacheShard</span><span class="p">(</span>
        <span class="n">per_shard</span><span class="p">,</span> <span class="n">strict_capacity_limit</span><span class="p">,</span> <span class="n">high_pri_pool_ratio</span><span class="p">,</span>
        <span class="n">low_pri_pool_ratio</span><span class="p">,</span> <span class="n">use_adaptive_mutex</span><span class="p">,</span> <span class="n">metadata_charge_policy</span><span class="p">,</span>
        <span class="cm">/* max_upper_hash_bits */</span> <span class="mi">32</span> <span class="o">-</span> <span class="n">num_shard_bits</span><span class="p">,</span> <span class="n">alloc</span><span class="p">,</span> <span class="n">secondary_cache</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">[=]</code> is capture clause and it’s used forthe lambda function to to capture all local variables by value.</p> <p>Lambda function makes a copy of each variable so updating variables inside the lambda does not affect the original variables outside the lambda.</p> <h3 id="lru-cache-in-rocksdb">lru cache in rocksdb</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Status</span> <span class="n">LRUCacheShard</span><span class="o">::</span><span class="n">Insert</span><span class="p">(</span><span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">hash</span><span class="p">,</span>
                             <span class="n">Cache</span><span class="o">::</span><span class="n">ObjectPtr</span> <span class="n">value</span><span class="p">,</span>
                             <span class="k">const</span> <span class="n">Cache</span><span class="o">::</span><span class="n">CacheItemHelper</span><span class="o">*</span> <span class="n">helper</span><span class="p">,</span>
                             <span class="kt">size_t</span> <span class="n">charge</span><span class="p">,</span> <span class="n">LRUHandle</span><span class="o">**</span> <span class="n">handle</span><span class="p">,</span>
                             <span class="n">Cache</span><span class="o">::</span><span class="n">Priority</span> <span class="n">priority</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">helper</span><span class="p">);</span>

  <span class="c1">// Allocate the memory here outside of the mutex.</span>
  <span class="c1">// If the cache is full, we'll have to release it.</span>
  <span class="c1">// It shouldn't happen very often though.</span>
  <span class="n">LRUHandle</span><span class="o">*</span> <span class="n">e</span> <span class="o">=</span>
      <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">LRUHandle</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">LRUHandle</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">key</span><span class="p">.</span><span class="n">size</span><span class="p">()));</span>

  <span class="n">e</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
  <span class="n">e</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">e</span><span class="o">-&gt;</span><span class="n">im_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">e</span><span class="o">-&gt;</span><span class="n">helper</span> <span class="o">=</span> <span class="n">helper</span><span class="p">;</span>
  <span class="n">e</span><span class="o">-&gt;</span><span class="n">key_length</span> <span class="o">=</span> <span class="n">key</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
  <span class="n">e</span><span class="o">-&gt;</span><span class="n">hash</span> <span class="o">=</span> <span class="n">hash</span><span class="p">;</span>
  <span class="n">e</span><span class="o">-&gt;</span><span class="n">refs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">e</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
  <span class="n">e</span><span class="o">-&gt;</span><span class="n">SetInCache</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
  <span class="n">e</span><span class="o">-&gt;</span><span class="n">SetPriority</span><span class="p">(</span><span class="n">priority</span><span class="p">);</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">key_data</span><span class="p">,</span> <span class="n">key</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">key</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
  <span class="n">e</span><span class="o">-&gt;</span><span class="n">CalcTotalCharge</span><span class="p">(</span><span class="n">charge</span><span class="p">,</span> <span class="n">metadata_charge_policy_</span><span class="p">);</span>

  <span class="c1">// value == nullptr is reserved for indicating failure for when secondary</span>
  <span class="c1">// cache compatible</span>
  <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">IsSecondaryCacheCompatible</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">value</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">));</span>

  <span class="k">return</span> <span class="n">InsertItem</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">handle</span><span class="p">,</span> <span class="cm">/* free_handle_on_fail */</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Status</span> <span class="n">LRUCacheShard</span><span class="o">::</span><span class="n">InsertItem</span><span class="p">(</span><span class="n">LRUHandle</span><span class="o">*</span> <span class="n">e</span><span class="p">,</span> <span class="n">LRUHandle</span><span class="o">**</span> <span class="n">handle</span><span class="p">,</span>
                                 <span class="kt">bool</span> <span class="n">free_handle_on_fail</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Status</span> <span class="n">s</span> <span class="o">=</span> <span class="n">Status</span><span class="o">::</span><span class="n">OK</span><span class="p">();</span>
  <span class="n">autovector</span><span class="o">&lt;</span><span class="n">LRUHandle</span><span class="o">*&gt;</span> <span class="n">last_reference_list</span><span class="p">;</span>

  <span class="p">{</span>
    <span class="n">DMutexLock</span> <span class="n">l</span><span class="p">(</span><span class="n">mutex_</span><span class="p">);</span>

    <span class="c1">// Free the space following strict LRU policy until enough space</span>
    <span class="c1">// is freed or the lru list is empty.</span>
    <span class="n">EvictFromLRU</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">total_charge</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">last_reference_list</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">usage_</span> <span class="o">+</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">total_charge</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">capacity_</span> <span class="o">&amp;&amp;</span>
        <span class="p">(</span><span class="n">strict_capacity_limit_</span> <span class="o">||</span> <span class="n">handle</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">e</span><span class="o">-&gt;</span><span class="n">SetInCache</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">handle</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Don't insert the entry but still return ok, as if the entry inserted</span>
        <span class="c1">// into cache and get evicted immediately.</span>
        <span class="n">last_reference_list</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">free_handle_on_fail</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">free</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
          <span class="o">*</span><span class="n">handle</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">Status</span><span class="o">::</span><span class="n">MemoryLimit</span><span class="p">(</span><span class="s">"Insert failed due to LRU cache being full."</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// Insert into the cache. Note that the cache might get larger than its</span>
      <span class="c1">// capacity if not enough space was freed up.</span>
      <span class="n">LRUHandle</span><span class="o">*</span> <span class="n">old</span> <span class="o">=</span> <span class="n">table_</span><span class="p">.</span><span class="n">Insert</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
      <span class="n">usage_</span> <span class="o">+=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">total_charge</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">old</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">Status</span><span class="o">::</span><span class="n">OkOverwritten</span><span class="p">();</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">InCache</span><span class="p">());</span>
        <span class="n">old</span><span class="o">-&gt;</span><span class="n">SetInCache</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">HasRefs</span><span class="p">())</span> <span class="p">{</span>
          <span class="c1">// old is on LRU because it's in cache and its reference count is 0.</span>
          <span class="n">LRU_Remove</span><span class="p">(</span><span class="n">old</span><span class="p">);</span>
          <span class="n">assert</span><span class="p">(</span><span class="n">usage_</span> <span class="o">&gt;=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">total_charge</span><span class="p">);</span>
          <span class="n">usage_</span> <span class="o">-=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">total_charge</span><span class="p">;</span>
          <span class="n">last_reference_list</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">old</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">handle</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">LRU_Insert</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// If caller already holds a ref, no need to take one here.</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">HasRefs</span><span class="p">())</span> <span class="p">{</span>
          <span class="n">e</span><span class="o">-&gt;</span><span class="n">Ref</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="o">*</span><span class="n">handle</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">TryInsertIntoSecondaryCache</span><span class="p">(</span><span class="n">last_reference_list</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="cpp"/><category term="cpp"/><category term="programming"/><summary type="html"><![CDATA[Use std::list and std::map]]></summary></entry><entry><title type="html">LightGBM dataset</title><link href="https://bilyz98.github.io/blog/2024/lightgbm-dataset/" rel="alternate" type="text/html" title="LightGBM dataset"/><published>2024-08-23T11:59:00+00:00</published><updated>2024-08-23T11:59:00+00:00</updated><id>https://bilyz98.github.io/blog/2024/lightgbm-dataset</id><content type="html" xml:base="https://bilyz98.github.io/blog/2024/lightgbm-dataset/"><![CDATA[<h2 id="early-stop-of-lightgbm-training">Early stop of lightgbm training</h2> <p>The function <code class="language-plaintext highlighter-rouge">LGBM_BoosterGetEval</code> itself does not directly affect the early stopping mechanism of <code class="language-plaintext highlighter-rouge">LGBM_BoosterUpdateOneIter</code>. However, it plays a crucial role in the process by providing the evaluation results needed to determine whether early stopping should occur.</p> <p>Here’s how it works:</p> <ol> <li> <p><strong>Evaluation Metrics</strong>: During training, <code class="language-plaintext highlighter-rouge">LGBM_BoosterUpdateOneIter</code> updates the model for one iteration. After each iteration, <code class="language-plaintext highlighter-rouge">LGBM_BoosterGetEval</code> can be used to retrieve the evaluation metrics (e.g., RMSE, accuracy) for the training and validation datasets.</p> </li> <li> <p><strong>Early Stopping Criteria</strong>: Early stopping is typically based on the performance of the model on the validation dataset. If the evaluation metric does not improve for a specified number of rounds (stopping rounds), training is stopped early to prevent overfitting.</p> </li> <li> <p><strong>Implementation</strong>: In practice, after each call to <code class="language-plaintext highlighter-rouge">LGBM_BoosterUpdateOneIter</code>, you would use <code class="language-plaintext highlighter-rouge">LGBM_BoosterGetEval</code> to get the current evaluation metric. You then compare this metric to the best metric observed so far. If there is no improvement for a certain number of iterations, you trigger early stopping.</p> </li> </ol> <p>Here’s a simplified example in C++:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;LightGBM/c_api.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Initialize datasets and booster (similar to previous example)</span>
    <span class="c1">// ...</span>

    <span class="kt">int</span> <span class="n">stopping_rounds</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">num_iterations</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">best_eval_result</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">rounds_without_improvement</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_iterations</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">LGBM_BoosterUpdateOneIter</span><span class="p">(</span><span class="n">booster</span><span class="p">);</span>

        <span class="c1">// Get evaluation result</span>
        <span class="kt">double</span> <span class="n">eval_result</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">out_len</span><span class="p">;</span>
        <span class="n">LGBM_BoosterGetEval</span><span class="p">(</span><span class="n">booster</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">out_len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eval_result</span><span class="p">);</span> <span class="c1">// Assuming 1 is the index for validation data</span>

        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Iteration "</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">": RMSE = "</span> <span class="o">&lt;&lt;</span> <span class="n">eval_result</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

        <span class="c1">// Check for early stopping</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">eval_result</span> <span class="o">&lt;</span> <span class="n">best_eval_result</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">best_eval_result</span> <span class="o">=</span> <span class="n">eval_result</span><span class="p">;</span>
            <span class="n">rounds_without_improvement</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">rounds_without_improvement</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">rounds_without_improvement</span> <span class="o">&gt;=</span> <span class="n">stopping_rounds</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Early stopping at iteration "</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Save model and free memory (similar to previous example)</span>
    <span class="c1">// ...</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>In this example, <code class="language-plaintext highlighter-rouge">LGBM_BoosterGetEval</code> is used to retrieve the evaluation metric after each iteration, and the early stopping logic is implemented based on the retrieved metric¹². If the evaluation metric does not improve for <code class="language-plaintext highlighter-rouge">stopping_rounds</code> consecutive iterations, training is stopped early.</p> <p>If you have any more questions or need further clarification, feel free to ask!</p> <p>Source: Conversation with Copilot, 8/24/2024 (1) C API — LightGBM 4.5.0.99 documentation - Read the Docs. https://lightgbm.readthedocs.io/en/latest/C-API.html. (2) lightgbm.early_stopping — LightGBM 4.5.0.99 documentation - Read the Docs. https://lightgbm.readthedocs.io/en/latest/pythonapi/lightgbm.early_stopping.html.</p> <h2 id="split-lightgbm-dataset">Split lightgbm dataset</h2> <p>Yes, you can split a LightGBM dataset object into training and evaluation datasets. Here’s an example in C++:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;LightGBM/c_api.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;random&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Load the full dataset</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">data_path</span> <span class="o">=</span> <span class="s">"full_data.txt"</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">params</span> <span class="o">=</span> <span class="s">"objective=regression metric=rmse"</span><span class="p">;</span>
    <span class="n">DatasetHandle</span> <span class="n">full_data</span><span class="p">;</span>
    <span class="n">LGBM_DatasetCreateFromFile</span><span class="p">(</span><span class="n">data_path</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">full_data</span><span class="p">);</span>

    <span class="c1">// Get the number of data points</span>
    <span class="kt">int</span> <span class="n">num_data</span><span class="p">;</span>
    <span class="n">LGBM_DatasetGetNumData</span><span class="p">(</span><span class="n">full_data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num_data</span><span class="p">);</span>

    <span class="c1">// Split indices into training and evaluation sets</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">indices</span><span class="p">(</span><span class="n">num_data</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">iota</span><span class="p">(</span><span class="n">indices</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">indices</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shuffle</span><span class="p">(</span><span class="n">indices</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">indices</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">mt19937</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">random_device</span><span class="p">{}()});</span>

    <span class="kt">int</span> <span class="n">train_size</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">0.8</span> <span class="o">*</span> <span class="n">num_data</span><span class="p">);</span> <span class="c1">// 80% for training</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">train_indices</span><span class="p">(</span><span class="n">indices</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">indices</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">train_size</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">eval_indices</span><span class="p">(</span><span class="n">indices</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">train_size</span><span class="p">,</span> <span class="n">indices</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

    <span class="c1">// Create training and evaluation datasets</span>
    <span class="n">DatasetHandle</span> <span class="n">train_data</span><span class="p">;</span>
    <span class="n">DatasetHandle</span> <span class="n">eval_data</span><span class="p">;</span>
    <span class="n">LGBM_DatasetCreateSubset</span><span class="p">(</span><span class="n">full_data</span><span class="p">,</span> <span class="n">train_indices</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">train_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">train_data</span><span class="p">);</span>
    <span class="n">LGBM_DatasetCreateSubset</span><span class="p">(</span><span class="n">full_data</span><span class="p">,</span> <span class="n">eval_indices</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">num_data</span> <span class="o">-</span> <span class="n">train_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eval_data</span><span class="p">);</span>

    <span class="c1">// Create booster</span>
    <span class="n">BoosterHandle</span> <span class="n">booster</span><span class="p">;</span>
    <span class="n">LGBM_BoosterCreate</span><span class="p">(</span><span class="n">train_data</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">booster</span><span class="p">);</span>

    <span class="c1">// Train model</span>
    <span class="kt">int</span> <span class="n">num_iterations</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_iterations</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">LGBM_BoosterUpdateOneIter</span><span class="p">(</span><span class="n">booster</span><span class="p">);</span>

        <span class="c1">// Evaluate model</span>
        <span class="kt">double</span> <span class="n">eval_result</span><span class="p">;</span>
        <span class="n">LGBM_BoosterGetEval</span><span class="p">(</span><span class="n">booster</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eval_result</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Iteration "</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">": RMSE = "</span> <span class="o">&lt;&lt;</span> <span class="n">eval_result</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Save model</span>
    <span class="n">LGBM_BoosterSaveModel</span><span class="p">(</span><span class="n">booster</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s">"model.txt"</span><span class="p">);</span>

    <span class="c1">// Free memory</span>
    <span class="n">LGBM_DatasetFree</span><span class="p">(</span><span class="n">full_data</span><span class="p">);</span>
    <span class="n">LGBM_DatasetFree</span><span class="p">(</span><span class="n">train_data</span><span class="p">);</span>
    <span class="n">LGBM_DatasetFree</span><span class="p">(</span><span class="n">eval_data</span><span class="p">);</span>
    <span class="n">LGBM_BoosterFree</span><span class="p">(</span><span class="n">booster</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>In this example:</p> <ol> <li>The full dataset is loaded from a file.</li> <li>The dataset is split into training and evaluation sets using a random shuffle.</li> <li>Subsets are created for training and evaluation.</li> <li>A LightGBM booster is created and trained using the training dataset.</li> <li>The model is evaluated on the evaluation dataset during training.</li> </ol> <p>Feel free to adjust the parameters and paths to fit your specific use case. If you have any more questions or need further assistance, let me know!</p> <p>Source: Conversation with Copilot, 8/24/2024 (1) lightgbm.train — LightGBM 4.5.0.99 documentation - Read the Docs. https://lightgbm.readthedocs.io/en/latest/pythonapi/lightgbm.train.html. (2) LightGBM regression example with cross validation and early stop run. https://www.datasciencebyexample.com/2023/04/24/lightgbm-regression-complete-example-with-cross-validation-and-early-stop/. (3) Train a model using LightGBM - GeeksforGeeks. https://www.geeksforgeeks.org/train-a-model-using-lightgbm/. (4) LightGBM - An In-Depth Guide [Python API] - CoderzColumn. https://coderzcolumn.com/tutorials/machine-learning/lightgbm-an-in-depth-guide-python.</p>]]></content><author><name></name></author><category term="ml"/><category term="ml"/><category term="lightgbm"/><summary type="html"><![CDATA[Early stop of lightgbm training The function LGBM_BoosterGetEval itself does not directly affect the early stopping mechanism of LGBM_BoosterUpdateOneIter. However, it plays a crucial role in the process by providing the evaluation results needed to determine whether early stopping should occur.]]></summary></entry><entry><title type="html">calloc and malloc</title><link href="https://bilyz98.github.io/blog/2024/calloc/" rel="alternate" type="text/html" title="calloc and malloc"/><published>2024-08-23T11:59:00+00:00</published><updated>2024-08-23T11:59:00+00:00</updated><id>https://bilyz98.github.io/blog/2024/calloc</id><content type="html" xml:base="https://bilyz98.github.io/blog/2024/calloc/"><![CDATA[<p><code class="language-plaintext highlighter-rouge">calloc</code> and <code class="language-plaintext highlighter-rouge">malloc</code> are both functions in C used for dynamic memory allocation, but they have some key differences.</p> <h3 id="calloc"><code class="language-plaintext highlighter-rouge">calloc</code></h3> <p><code class="language-plaintext highlighter-rouge">calloc</code> stands for “contiguous allocation.” It allocates memory for an array of elements, initializes all bytes to zero, and returns a pointer to the allocated memory.</p> <p><strong>Syntax</strong>:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="o">*</span><span class="nf">calloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">num</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
</code></pre></div></div> <ul> <li><strong>Parameters</strong>: <ul> <li><code class="language-plaintext highlighter-rouge">num</code>: Number of elements.</li> <li><code class="language-plaintext highlighter-rouge">size</code>: Size of each element.</li> </ul> </li> </ul> <h3 id="malloc"><code class="language-plaintext highlighter-rouge">malloc</code></h3> <p><code class="language-plaintext highlighter-rouge">malloc</code> stands for “memory allocation.” It allocates a specified number of bytes of memory and returns a pointer to the allocated memory. However, it does not initialize the memory.</p> <p><strong>Syntax</strong>:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="o">*</span><span class="nf">malloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
</code></pre></div></div> <ul> <li><strong>Parameter</strong>: <ul> <li><code class="language-plaintext highlighter-rouge">size</code>: Number of bytes to allocate.</li> </ul> </li> </ul> <h3 id="key-differences">Key Differences</h3> <ol> <li><strong>Initialization</strong>: <ul> <li><code class="language-plaintext highlighter-rouge">calloc</code>: Initializes the allocated memory to zero.</li> <li><code class="language-plaintext highlighter-rouge">malloc</code>: Does not initialize the allocated memory; it contains garbage values.</li> </ul> </li> <li><strong>Parameters</strong>: <ul> <li><code class="language-plaintext highlighter-rouge">calloc</code>: Takes two parameters (number of elements and size of each element).</li> <li><code class="language-plaintext highlighter-rouge">malloc</code>: Takes one parameter (total number of bytes to allocate).</li> </ul> </li> <li><strong>Usage</strong>: <ul> <li><code class="language-plaintext highlighter-rouge">calloc</code> is useful when you need an array of elements initialized to zero.</li> <li><code class="language-plaintext highlighter-rouge">malloc</code> is useful when you need a block of memory without initialization.</li> </ul> </li> </ol> <h3 id="example">Example</h3> <p>Here’s an example to illustrate the difference:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Using calloc</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">arr1</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">calloc</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span> <span class="c1">// Allocates memory for 5 integers and initializes them to 0</span>

<span class="c1">// Using malloc</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">arr2</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span> <span class="c1">// Allocates memory for 5 integers, but they contain garbage values</span>
</code></pre></div></div> <p>Would you like to see more examples or have any specific questions about these functions?</p>]]></content><author><name></name></author><category term="c"/><category term="c"/><summary type="html"><![CDATA[calloc and malloc are both functions in C used for dynamic memory allocation, but they have some key differences.]]></summary></entry><entry><title type="html">Simple c compiler</title><link href="https://bilyz98.github.io/blog/2024/chibicc-compiler/" rel="alternate" type="text/html" title="Simple c compiler"/><published>2024-08-23T11:59:00+00:00</published><updated>2024-08-23T11:59:00+00:00</updated><id>https://bilyz98.github.io/blog/2024/chibicc-compiler</id><content type="html" xml:base="https://bilyz98.github.io/blog/2024/chibicc-compiler/"><![CDATA[<p>Follow this repo commit history to learn basics of compiler.</p> <p>Very nice repo to compiler tutorial.</p> <p>You can follow the commit history to build a simple c compiler step by step.</p> <p><a href="https://github.com/rui314/chibicc/commits/main/?since=2020-10-01&amp;until=2020-10-27&amp;after=90d1f7f199cc55b13c7fdb5839d1409806633fdb+34">https://github.com/rui314/chibicc/commits/main/?since=2020-10-01&amp;until=2020-10-27&amp;after=90d1f7f199cc55b13c7fdb5839d1409806633fdb+34</a></p> <h2 id="-and---and-number-lexer">+ and - and number lexer</h2> <p>With machine code generation</p> <p>main.c</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;ctype.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdarg.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdbool.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
  <span class="n">TK_PUNCT</span><span class="p">,</span> <span class="c1">// punctuators</span>
  <span class="n">TK_NUM</span><span class="p">,</span> 
  <span class="n">TK_EOF</span><span class="p">,</span>

<span class="p">}</span> <span class="n">TokenKind</span><span class="p">;</span>



<span class="k">typedef</span> <span class="k">struct</span> <span class="n">Token</span> <span class="n">Token</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">Token</span> <span class="p">{</span>
  <span class="n">TokenKind</span> <span class="n">kind</span><span class="p">;</span>
  <span class="n">Token</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">val</span><span class="p">;</span> <span class="c1">// if TokenKind is TK_NUM, its value</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">loc</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">error</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span> <span class="p">{</span>
  <span class="kt">va_list</span> <span class="n">ap</span><span class="p">;</span>
  <span class="n">va_start</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
  <span class="n">vfprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">ap</span><span class="p">);</span> 
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">equal</span><span class="p">(</span><span class="n">Token</span><span class="o">*</span> <span class="n">tok</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">op</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">memcmp</span><span class="p">(</span><span class="n">tok</span><span class="o">-&gt;</span><span class="n">loc</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">op</span><span class="p">[</span><span class="n">tok</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'\0'</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="n">Token</span><span class="o">*</span> <span class="nf">skip</span><span class="p">(</span><span class="n">Token</span><span class="o">*</span> <span class="n">tok</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">equal</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">error</span><span class="p">(</span><span class="s">"expected '%s', cur tok is '%s', len %d"</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">loc</span><span class="p">,</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_number</span><span class="p">(</span><span class="n">Token</span><span class="o">*</span> <span class="n">tok</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="n">tok</span><span class="o">-&gt;</span><span class="n">kind</span> <span class="o">!=</span> <span class="n">TK_NUM</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">error</span><span class="p">(</span><span class="s">"expected a number"</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">Token</span><span class="o">*</span> <span class="nf">new_token</span><span class="p">(</span><span class="n">TokenKind</span> <span class="n">kind</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">start</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Token</span><span class="o">*</span> <span class="n">tok</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Token</span><span class="p">));</span>
  <span class="n">tok</span><span class="o">-&gt;</span><span class="n">kind</span> <span class="o">=</span> <span class="n">kind</span><span class="p">;</span>
  <span class="n">tok</span><span class="o">-&gt;</span><span class="n">loc</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
  <span class="n">tok</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">tok</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="n">Token</span><span class="o">*</span> <span class="nf">tokenize</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Token</span> <span class="n">head</span> <span class="o">=</span> <span class="p">{};</span>
  <span class="n">Token</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">head</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">isspace</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">p</span><span class="o">++</span><span class="p">;</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span><span class="p">(</span><span class="n">isdigit</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">new_token</span><span class="p">(</span><span class="n">TK_NUM</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
      <span class="kt">char</span><span class="o">*</span> <span class="n">q</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
      <span class="n">cur</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">strtoul</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
      <span class="n">cur</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span> <span class="n">q</span><span class="p">;</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">==</span> <span class="sc">'+'</span> <span class="o">||</span> <span class="o">*</span><span class="n">p</span> <span class="o">==</span> <span class="sc">'-'</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">new_token</span><span class="p">(</span><span class="n">TK_PUNCT</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
      <span class="n">p</span><span class="o">++</span><span class="p">;</span>
      <span class="k">continue</span><span class="p">;;</span>
    <span class="p">}</span>

    <span class="n">error</span><span class="p">(</span><span class="s">"invalid token"</span><span class="p">);</span>


  <span class="p">}</span>
  <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">new_token</span><span class="p">(</span><span class="n">TK_EOF</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">head</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>



<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">error</span><span class="p">(</span><span class="s">"%s: invalid number of arguments"</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
  <span class="p">}</span>
  <span class="n">Token</span><span class="o">*</span> <span class="n">tok</span> <span class="o">=</span> <span class="n">tokenize</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"  .globl main</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"main: </span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"  mov $%d, %%rax</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">get_number</span><span class="p">(</span><span class="n">tok</span><span class="p">));</span>
  <span class="n">tok</span> <span class="o">=</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

  <span class="k">while</span><span class="p">(</span><span class="n">tok</span><span class="o">-&gt;</span><span class="n">kind</span> <span class="o">!=</span> <span class="n">TK_EOF</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">equal</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">"+"</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"  add $%d, %%rax</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">get_number</span><span class="p">(</span><span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">));</span>
      <span class="n">tok</span> <span class="o">=</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">tok</span> <span class="o">=</span> <span class="n">skip</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">"-"</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"  sub $%d, %%rax</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">get_number</span><span class="p">(</span><span class="n">tok</span><span class="p">));</span>
    <span class="n">tok</span> <span class="o">=</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"  ret</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span> 


</code></pre></div></div> <p>test.sh</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>

assert<span class="o">()</span> <span class="o">{</span>
  <span class="nv">expected</span><span class="o">=</span><span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span>
  <span class="nv">input</span><span class="o">=</span><span class="s2">"</span><span class="nv">$2</span><span class="s2">"</span>

  ./chibicc <span class="s2">"</span><span class="nv">$input</span><span class="s2">"</span> <span class="o">&gt;</span> tmp.s <span class="o">||</span> <span class="nb">exit
  </span>gcc <span class="nt">-static</span> <span class="nt">-o</span> tmp tmp.s
  ./tmp
  <span class="nv">actual</span><span class="o">=</span><span class="s2">"</span><span class="nv">$?</span><span class="s2">"</span>


  <span class="k">if</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$actual</span><span class="s2">"</span> <span class="o">=</span> <span class="s2">"</span><span class="nv">$expected</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$input</span><span class="s2"> =&gt; </span><span class="nv">$actual</span><span class="s2">"</span>
  <span class="k">else
    </span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$input</span><span class="s2"> =&gt; </span><span class="nv">$expected</span><span class="s2"> expected, but got </span><span class="nv">$actual</span><span class="s2">"</span>
    <span class="nb">exit </span>1

  <span class="k">fi</span>

<span class="o">}</span>

assert 0 0
assert 42 42
assert 21 <span class="s2">"5+20-4"</span>
assert 41 <span class="s2">" 12 + 34 - 5 "</span>

<span class="nb">echo </span>OK
</code></pre></div></div> <p>Makefile</p> <pre><code class="language-Makefile">CFLAGS=-std=c11 -g -fno-common

chibicc: main.o
	$(CC) -o chibicc main.o $(LDFLAGS)

test: chibicc
	./test.sh


clean:
	rm -f chibicc *.o *~ tmp*

.PHONY: test clean

</code></pre>]]></content><author><name></name></author><category term="compiler"/><category term="c"/><category term="compiler"/><summary type="html"><![CDATA[Follow this repo commit history to learn basics of compiler.]]></summary></entry><entry><title type="html">Difference between deep copy and shallow copy in python</title><link href="https://bilyz98.github.io/blog/2024/python-deep-copy/" rel="alternate" type="text/html" title="Difference between deep copy and shallow copy in python"/><published>2024-08-20T11:59:00+00:00</published><updated>2024-08-20T11:59:00+00:00</updated><id>https://bilyz98.github.io/blog/2024/python-deep-copy</id><content type="html" xml:base="https://bilyz98.github.io/blog/2024/python-deep-copy/"><![CDATA[<h3 id="shallow-copy">Shallow Copy</h3> <ul> <li><strong>Definition</strong>: A shallow copy creates a new object, but inserts references into it to the objects found in the original.</li> <li><strong>Behavior</strong>: Only the top-level object is copied. If the original object contains other objects (like lists within lists), the references to these objects are copied, not the objects themselves.</li> <li><strong>Use Case</strong>: Suitable for simple data structures or when you don’t need to copy nested objects.</li> <li><strong>Example</strong>: <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">copy</span>

<span class="n">original</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">4</span><span class="p">]</span>
<span class="n">shallow_copy</span> <span class="o">=</span> <span class="n">copy</span><span class="p">.</span><span class="nf">copy</span><span class="p">(</span><span class="n">original</span><span class="p">)</span>

<span class="n">shallow_copy</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sh">'</span><span class="s">changed</span><span class="sh">'</span>
<span class="nf">print</span><span class="p">(</span><span class="n">original</span><span class="p">)</span>  <span class="c1"># Output: [1, ['changed', 3], 4]
</span></code></pre></div> </div> </li> </ul> <h3 id="deep-copy">Deep Copy</h3> <ul> <li><strong>Definition</strong>: A deep copy creates a new object and recursively copies all objects found in the original.</li> <li><strong>Behavior</strong>: Both the top-level object and all nested objects are copied. Changes to the copied object do not affect the original object.</li> <li><strong>Use Case</strong>: Necessary when you need to copy complex data structures with nested objects.</li> <li><strong>Example</strong>: <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">copy</span>

<span class="n">original</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">4</span><span class="p">]</span>
<span class="n">deep_copy</span> <span class="o">=</span> <span class="n">copy</span><span class="p">.</span><span class="nf">deepcopy</span><span class="p">(</span><span class="n">original</span><span class="p">)</span>

<span class="n">deep_copy</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sh">'</span><span class="s">changed</span><span class="sh">'</span>
<span class="nf">print</span><span class="p">(</span><span class="n">original</span><span class="p">)</span>  <span class="c1"># Output: [1, [2, 3], 4]
</span></code></pre></div> </div> </li> </ul> <h3 id="summary">Summary</h3> <ul> <li><strong>Shallow Copy</strong>: Copies the structure of the object, but not the elements within nested objects.</li> <li><strong>Deep Copy</strong>: Copies the structure and all elements within nested objects, creating a completely independent copy.</li> </ul> <p>Understanding these differences helps you choose the right type of copy for your specific needs. If you have any more questions or need further clarification, feel free to ask!</p>]]></content><author><name></name></author><category term="python"/><summary type="html"><![CDATA[Shallow Copy Definition: A shallow copy creates a new object, but inserts references into it to the objects found in the original. Behavior: Only the top-level object is copied. If the original object contains other objects (like lists within lists), the references to these objects are copied, not the objects themselves. Use Case: Suitable for simple data structures or when you don’t need to copy nested objects. Example: ```python import copy]]></summary></entry><entry><title type="html">Python Package Path</title><link href="https://bilyz98.github.io/blog/2024/python-package-path/" rel="alternate" type="text/html" title="Python Package Path"/><published>2024-08-10T00:00:00+00:00</published><updated>2024-08-10T00:00:00+00:00</updated><id>https://bilyz98.github.io/blog/2024/python-package-path</id><content type="html" xml:base="https://bilyz98.github.io/blog/2024/python-package-path/"><![CDATA[<p>I have micrograd2 under micrograd folder but this error shows when I run test.py. how to fix it ?</p> <p>File “/home/zt/bilyz_website_new/code/micrograd/test/test.py”, line 2, in <module> from micrograd2.engine import Value ModuleNotFoundError: No module named 'micrograd2'</module></p> <p>It looks like Python is unable to find the <code class="language-plaintext highlighter-rouge">micrograd2</code> module. Here are a few steps you can try to resolve this issue:</p> <ol> <li> <p><strong>Check the Directory Structure</strong>: Ensure that the <code class="language-plaintext highlighter-rouge">micrograd2</code> folder is correctly placed within the <code class="language-plaintext highlighter-rouge">micrograd</code> directory and that it contains an <code class="language-plaintext highlighter-rouge">__init__.py</code> file. This file is necessary for Python to recognize the directory as a package.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> micrograd/
 ├── micrograd2/
 │   ├── __init__.py
 │   └── engine.py
 └── test/
     └── test.py
</code></pre></div> </div> </li> <li><strong>Update the Import Statement</strong>: If <code class="language-plaintext highlighter-rouge">micrograd2</code> is a subdirectory of <code class="language-plaintext highlighter-rouge">micrograd</code>, you might need to adjust your import statement in <code class="language-plaintext highlighter-rouge">test.py</code> to reflect the correct path. Try changing: <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kn">from</span> <span class="n">micrograd2.engine</span> <span class="kn">import</span> <span class="n">Value</span>
</code></pre></div> </div> <p>to:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kn">from</span> <span class="n">micrograd.micrograd2.engine</span> <span class="kn">import</span> <span class="n">Value</span>
</code></pre></div> </div> </li> <li><strong>Check the PYTHONPATH</strong>: Ensure that the <code class="language-plaintext highlighter-rouge">micrograd</code> directory is included in your <code class="language-plaintext highlighter-rouge">PYTHONPATH</code>. You can temporarily add it by running: <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nb">export </span><span class="nv">PYTHONPATH</span><span class="o">=</span>/home/zt/bilyz_website_new/code/micrograd:<span class="nv">$PYTHONPATH</span>
</code></pre></div> </div> </li> <li><strong>Run the Script from the Correct Directory</strong>: Make sure you are running <code class="language-plaintext highlighter-rouge">test.py</code> from the <code class="language-plaintext highlighter-rouge">micrograd</code> directory or adjust your working directory accordingly.</li> </ol>]]></content><author><name></name></author><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">cpp async</title><link href="https://bilyz98.github.io/blog/2024/cpp-async/" rel="alternate" type="text/html" title="cpp async"/><published>2024-08-05T11:59:00+00:00</published><updated>2024-08-05T11:59:00+00:00</updated><id>https://bilyz98.github.io/blog/2024/cpp-async</id><content type="html" xml:base="https://bilyz98.github.io/blog/2024/cpp-async/"><![CDATA[<p><a href="https://github.com/muluoleiguo/interview/blob/master/%E9%9D%A2%E8%AF%95/c%2B%2B%E5%B9%B6%E5%8F%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B/C%2B%2B%E5%A4%9A%E7%BA%BF%E7%A8%8B.md">async</a></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;future&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;Windows.h&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">double</span> <span class="nf">t1</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">double</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
 <span class="kt">double</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
 <span class="n">Sleep</span><span class="p">(</span><span class="mi">3000</span><span class="p">);</span><span class="c1">//假设t1函数是个复杂的计算过程，需要消耗3秒</span>
 <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
<span class="p">{</span>
 <span class="kt">double</span> <span class="n">a</span> <span class="o">=</span> <span class="mf">2.3</span><span class="p">;</span>
 <span class="kt">double</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">6.7</span><span class="p">;</span>
 <span class="n">future</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">fu</span> <span class="o">=</span> <span class="n">async</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span><span class="c1">//创建异步线程线程，并将线程的执行结果用fu占位；</span>
 <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"正在进行计算"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
 <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"计算结果马上就准备好，请您耐心等待"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
 <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"计算结果："</span> <span class="o">&lt;&lt;</span> <span class="n">fu</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span><span class="c1">//阻塞主线程，直至异步线程return</span>
        <span class="c1">//cout &lt;&lt; "计算结果：" &lt;&lt; fu.get() &lt;&lt; endl;//取消该语句注释后运行会报错，因为future对象的get()方法只能调用一次。</span>
 <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>Output:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>正在进行计算
计算结果马上就准备好，请您耐心等待
计算结果：9
</code></pre></div></div>]]></content><author><name></name></author><category term="cpp"/><category term="cpp"/><summary type="html"><![CDATA[async]]></summary></entry><entry><title type="html">cpp thread local</title><link href="https://bilyz98.github.io/blog/2024/cpp-thread-local/" rel="alternate" type="text/html" title="cpp thread local"/><published>2024-08-05T11:59:00+00:00</published><updated>2024-08-05T11:59:00+00:00</updated><id>https://bilyz98.github.io/blog/2024/cpp-thread-local</id><content type="html" xml:base="https://bilyz98.github.io/blog/2024/cpp-thread-local/"><![CDATA[<p><a href="https://github.com/muluoleiguo/interview/blob/master/%E9%9D%A2%E8%AF%95/c%2B%2B%E5%B9%B6%E5%8F%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8.md">thread-local</a></p> <p>When to use thread local?</p> <p>When you want to store data that is unique to each thread, you can use thread local storage. This is useful when you want to store data that is global to a thread, but not global to the entire program. For example, you might want to store a counter that is unique to each thread, or a pointer to a resource that is unique to each thread.</p> <p>Usually each thread uses thread local when there are multiple function calls in each thread and each function call needs to access the same data.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">thread_local</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// static thread_local int count = 0; // 两种写法等价！</span>
    <span class="n">count</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
    <span class="c1">// 休眠n秒，防止输出时数据交错（Mac会出现）</span>
    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="s">":"</span><span class="o">&lt;&lt;</span><span class="n">count</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">td</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">td</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">td</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">join</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>Output:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>23456242050624:1
23456239949376:2
</code></pre></div></div> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">dump</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">id</span><span class="o">&lt;&lt;</span><span class="s">":"</span><span class="o">&lt;&lt;</span><span class="n">count</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">id</span> <span class="n">id</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">thread_local</span> <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">thread_local</span> <span class="kt">int</span> <span class="n">A</span><span class="o">::</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">A</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">a</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">();</span>
    <span class="n">a</span><span class="p">.</span><span class="n">count</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>
    <span class="n">a</span><span class="p">.</span><span class="n">dump</span><span class="p">();</span>
    <span class="n">A</span> <span class="n">aa</span><span class="p">;</span>
    <span class="n">aa</span><span class="p">.</span><span class="n">dump</span><span class="p">();</span> <span class="c1">// aa 和 a 中的count在同一个线程内相同。</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">td</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">td</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">td</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">join</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>Output:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>23456242050624:1
thread::id of a non-executing thread:1
23456239949376:2
thread::id of a non-executing thread:2
</code></pre></div></div>]]></content><author><name></name></author><category term="cpp"/><category term="cpp"/><summary type="html"><![CDATA[thread-local]]></summary></entry><entry><title type="html">micrograd</title><link href="https://bilyz98.github.io/blog/2024/micrograd/" rel="alternate" type="text/html" title="micrograd"/><published>2024-08-05T11:59:00+00:00</published><updated>2024-08-05T11:59:00+00:00</updated><id>https://bilyz98.github.io/blog/2024/micrograd</id><content type="html" xml:base="https://bilyz98.github.io/blog/2024/micrograd/"><![CDATA[<p>What is micrograd?</p> <p>micrograd is a simple implementation of pytorch-like autograd engine built by karparthy.</p> <h2 id="test-code">Test code</h2> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">from</span> <span class="n">micrograd.engine</span> <span class="kn">import</span> <span class="n">Value</span>

<span class="n">a</span> <span class="o">=</span> <span class="nc">Value</span><span class="p">(</span><span class="mf">4.0</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="nc">Value</span><span class="p">(</span><span class="mf">3.0</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">c</span><span class="p">.</span><span class="n">data</span><span class="si">:</span><span class="p">.</span><span class="mi">4</span><span class="n">f</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>

<span class="n">c</span><span class="p">.</span><span class="nf">backward</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">a</span><span class="p">.</span><span class="n">grad</span><span class="si">:</span><span class="p">.</span><span class="mi">4</span><span class="n">f</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">b</span><span class="p">.</span><span class="n">grad</span><span class="si">:</span><span class="p">.</span><span class="mi">4</span><span class="n">f</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">c</span><span class="p">.</span><span class="n">grad</span><span class="si">:</span><span class="p">.</span><span class="mi">4</span><span class="n">f</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
</code></pre></div></div> <p>The output is quite straightforward:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>12.0000
3.0000
4.0000
1.0000
</code></pre></div></div> <p>However, the grad will accumulate in the value if it’s not set to zero.</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">micrograd.engine</span> <span class="kn">import</span> <span class="n">Value</span>

<span class="n">a</span> <span class="o">=</span> <span class="nc">Value</span><span class="p">(</span><span class="mf">4.0</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="nc">Value</span><span class="p">(</span><span class="mf">3.0</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">c</span><span class="p">.</span><span class="n">data</span><span class="si">:</span><span class="p">.</span><span class="mi">4</span><span class="n">f</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>

<span class="n">c</span><span class="p">.</span><span class="nf">backward</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">a</span><span class="p">.</span><span class="n">grad</span><span class="si">:</span><span class="p">.</span><span class="mi">4</span><span class="n">f</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">b</span><span class="p">.</span><span class="n">grad</span><span class="si">:</span><span class="p">.</span><span class="mi">4</span><span class="n">f</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">c</span><span class="p">.</span><span class="n">grad</span><span class="si">:</span><span class="p">.</span><span class="mi">4</span><span class="n">f</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>


<span class="c1"># a = Value(4.0)
# b = Value(3.0)
</span><span class="n">d</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="n">d</span><span class="p">.</span><span class="nf">backward</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">a</span><span class="p">.</span><span class="n">grad</span><span class="si">:</span><span class="p">.</span><span class="mi">4</span><span class="n">f</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">b</span><span class="p">.</span><span class="n">grad</span><span class="si">:</span><span class="p">.</span><span class="mi">4</span><span class="n">f</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>


</code></pre></div></div> <p>OUtput:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>12.0000
3.0000
4.0000
1.0000
4.0000
5.0000
</code></pre></div></div> <h3 id="internal-implementation">Internal implementation</h3> <p>Please check code in this notebook <a href="https://colab.research.google.com/drive/1KF6houJ-X_uLIgZ5BaSV24-GnYpTQdeh?usp=sharing">micrograd note book</a></p> <p>Some vector based tensor implementation based on micrograd <a href="https://github.com/rohit-krish/Deeplex/tree/main">deeplex</a> <a href="https://github.com/conscell/ugrad">ugrad</a></p>]]></content><author><name></name></author><category term="ml"/><category term="ml"/><category term="pytorch"/><summary type="html"><![CDATA[What is micrograd?]]></summary></entry></feed>