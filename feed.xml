<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://bilyz98.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://bilyz98.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-10-16T09:05:15+00:00</updated><id>https://bilyz98.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Linux get cpu time and wall clock time</title><link href="https://bilyz98.github.io/blog/2024/get-function-cpu-time/" rel="alternate" type="text/html" title="Linux get cpu time and wall clock time"/><published>2024-10-13T11:59:00+00:00</published><updated>2024-10-13T11:59:00+00:00</updated><id>https://bilyz98.github.io/blog/2024/get-function-cpu-time</id><content type="html" xml:base="https://bilyz98.github.io/blog/2024/get-function-cpu-time/"><![CDATA[<h2 id="difference-between-wall-clock-time-and-cpu-time">Difference between wall clock time and cpu time</h2> <p>The difference between CPU time and system clock time (also known as wall-clock time) is an important concept in performance measurement:</p> <p><strong>CPU Time:</strong></p> <ul> <li><strong>User CPU Time</strong>: The amount of time the CPU spends executing code in user mode, outside the kernel.</li> <li><strong>System CPU Time</strong>: The amount of time the CPU spends executing code in kernel mode, on behalf of the process.</li> <li><strong>Total CPU Time</strong>: The sum of user and system CPU time, representing the total time the CPU was actively working on a specific process.</li> </ul> <p><strong>System Clock Time (Wall-Clock Time):</strong></p> <ul> <li>This is the real-world elapsed time from the start to the end of a process, as if measured by a stopwatch.</li> <li>It includes all time, including time spent waiting for I/O operations, network responses, or other processes to complete.</li> </ul> <p><strong>Key Differences:</strong></p> <ul> <li><strong>CPU time</strong> only accounts for the time the CPU is actively working on a task, while <strong>wall-clock time</strong> includes all waiting periods.</li> <li><strong>Wall-clock time</strong> is always greater than or equal to <strong>CPU time</strong> for a single-threaded process.</li> <li>For multi-threaded processes, <strong>CPU time</strong> can exceed <strong>wall-clock time</strong> if multiple threads are running in parallel on multiple CPU cores.</li> </ul> <p><strong>Example:</strong> If a program takes 2 seconds of CPU time but 5 seconds of wall-clock time, it means the program was waiting for 3 seconds (e.g., for I/O operations or network responses).</p> <p>Understanding these differences can help identify performance bottlenecks. If CPU time is close to wall-clock time, the process is CPU-bound. If wall-clock time is significantly higher, the process is likely I/O-bound or waiting on other resources.</p> <h2 id="get-cpu-time-in-rocksdb">Get cpu time in rocksdb</h2> <p>https://github.com/BilyZ98/rocksdb_kv_sep/blob/8a5f06aef1d74d4dace2ffdcd2f07b90ddcff083/db/flush_job.cc#L697</p> <p>Wall clock time: <code class="language-plaintext highlighter-rouge">CLOCK_MONOTONIC</code> is used to get wall clock time</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">uint64_t</span> <span class="n">NowNanos</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
<span class="cp">#if defined(OS_LINUX) || defined(OS_FREEBSD) || defined(OS_GNU_KFREEBSD) || \
    defined(OS_AIX)
</span>    <span class="k">struct</span> <span class="nc">timespec</span> <span class="n">ts</span><span class="p">;</span>
    <span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ts</span><span class="p">);</span>
    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ts</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000000000</span> <span class="o">+</span> <span class="n">ts</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">;</span>
<span class="cp">#elif defined(OS_SOLARIS)
</span>    <span class="k">return</span> <span class="n">gethrtime</span><span class="p">();</span>
<span class="cp">#elif defined(__MACH__)
</span>    <span class="n">clock_serv_t</span> <span class="n">cclock</span><span class="p">;</span>
    <span class="n">mach_timespec_t</span> <span class="n">ts</span><span class="p">;</span>
    <span class="n">host_get_clock_service</span><span class="p">(</span><span class="n">mach_host_self</span><span class="p">(),</span> <span class="n">CALENDAR_CLOCK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cclock</span><span class="p">);</span>
    <span class="n">clock_get_time</span><span class="p">(</span><span class="n">cclock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ts</span><span class="p">);</span>
    <span class="n">mach_port_deallocate</span><span class="p">(</span><span class="n">mach_task_self</span><span class="p">(),</span> <span class="n">cclock</span><span class="p">);</span>
    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ts</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000000000</span> <span class="o">+</span> <span class="n">ts</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">;</span>
<span class="cp">#else
</span>    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">nanoseconds</span><span class="o">&gt;</span><span class="p">(</span>
               <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">steady_clock</span><span class="o">::</span><span class="n">now</span><span class="p">().</span><span class="n">time_since_epoch</span><span class="p">())</span>
        <span class="p">.</span><span class="n">count</span><span class="p">();</span>
<span class="cp">#endif
</span>  <span class="p">}</span>
</code></pre></div></div> <p>CPU time: <code class="language-plaintext highlighter-rouge">CLOCK_THREAD_CPUTIME_ID</code> is used to get cpu time</p> <p>https://github.com/BilyZ98/rocksdb_kv_sep/blob/8a5f06aef1d74d4dace2ffdcd2f07b90ddcff083/env/env_posix.cc#L164</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">uint64_t</span> <span class="n">CPUMicros</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
<span class="cp">#if defined(OS_LINUX) || defined(OS_FREEBSD) || defined(OS_GNU_KFREEBSD) || \
    defined(OS_AIX) || (defined(__MACH__) &amp;&amp; defined(__MAC_10_12))
</span>    <span class="k">struct</span> <span class="nc">timespec</span> <span class="n">ts</span><span class="p">;</span>
    <span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_THREAD_CPUTIME_ID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ts</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ts</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000000000</span> <span class="o">+</span> <span class="n">ts</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">;</span>
<span class="cp">#endif
</span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="os"/><category term="c"/><category term="linux"/><summary type="html"><![CDATA[Difference between wall clock time and cpu time The difference between CPU time and system clock time (also known as wall-clock time) is an important concept in performance measurement:]]></summary></entry><entry><title type="html">Simple c compiler unary</title><link href="https://bilyz98.github.io/blog/2024/chibicc-unary/" rel="alternate" type="text/html" title="Simple c compiler unary"/><published>2024-10-10T11:59:00+00:00</published><updated>2024-10-10T11:59:00+00:00</updated><id>https://bilyz98.github.io/blog/2024/chibicc-unary</id><content type="html" xml:base="https://bilyz98.github.io/blog/2024/chibicc-unary/"><![CDATA[<h2 id="add-unary-to-parser">Add unary to parser</h2> <p><a href="./2024-10-12-chibicc-gen-expr.md">Previous parser post</a></p> <p>Add unary symbol in mul. Add unary node kind and replace primary with unary. unary is a super set of unary and primary.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// expr = unary ("*" unary | "/" unary)*</span>
<span class="k">static</span> <span class="n">Node</span><span class="o">*</span> <span class="nf">mul</span><span class="p">(</span><span class="n">Token</span><span class="o">**</span><span class="n">rest</span><span class="p">,</span> <span class="n">Token</span><span class="o">*</span> <span class="n">tok</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">unary</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">tok</span><span class="p">);</span>

  <span class="k">for</span><span class="p">(;;)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">equal</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">"*"</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">node</span> <span class="o">=</span>  <span class="n">new_binary</span><span class="p">(</span><span class="n">ND_MUL</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">unary</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">));</span>
      <span class="k">continue</span><span class="p">;;</span>
    <span class="p">}</span>

    <span class="k">if</span><span class="p">(</span><span class="n">equal</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">"/"</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">node</span> <span class="o">=</span> <span class="n">new_binary</span><span class="p">(</span><span class="n">ND_DIV</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">unary</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">));</span>
      <span class="k">continue</span><span class="p">;;</span>
    <span class="p">}</span>

    <span class="o">*</span><span class="n">rest</span> <span class="o">=</span> <span class="n">tok</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>


<span class="c1">// unary = ("+" | "-") unary | primary</span>
<span class="k">static</span> <span class="n">Node</span><span class="o">*</span> <span class="nf">unary</span><span class="p">(</span><span class="n">Token</span> <span class="o">**</span><span class="n">rest</span><span class="p">,</span> <span class="n">Token</span><span class="o">*</span> <span class="n">tok</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="n">equal</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">"+"</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">unary</span><span class="p">(</span><span class="n">rest</span><span class="p">,</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>

  <span class="k">if</span><span class="p">(</span><span class="n">equal</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">"-"</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">new_unary</span><span class="p">(</span><span class="n">ND_NEG</span><span class="p">,</span> <span class="n">unary</span><span class="p">(</span><span class="n">rest</span><span class="p">,</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">));</span>

  <span class="k">return</span> <span class="n">primary</span><span class="p">(</span><span class="n">rest</span><span class="p">,</span> <span class="n">tok</span><span class="p">);</span>

<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="compiler"/><category term="c"/><category term="compiler"/><summary type="html"><![CDATA[Add unary to parser Previous parser post]]></summary></entry><entry><title type="html">Simple c compiler gen expr</title><link href="https://bilyz98.github.io/blog/2024/chibicc-gen-expr/" rel="alternate" type="text/html" title="Simple c compiler gen expr"/><published>2024-10-09T11:59:00+00:00</published><updated>2024-10-09T11:59:00+00:00</updated><id>https://bilyz98.github.io/blog/2024/chibicc-gen-expr</id><content type="html" xml:base="https://bilyz98.github.io/blog/2024/chibicc-gen-expr/"><![CDATA[<p>Once we have the tokenize we can then write parser code to generate abstract syntax tree by traversing the token list. We use stack to generate tree.</p> <p><code class="language-plaintext highlighter-rouge">'+'</code> has the lowest priority. Number and <code class="language-plaintext highlighter-rouge">(expr)</code>has highest parsing priority.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// expr = mul ("+" mul | "-" mul)*</span>
<span class="k">static</span> <span class="n">Node</span><span class="o">*</span> <span class="nf">expr</span><span class="p">(</span><span class="n">Token</span> <span class="o">**</span><span class="n">rest</span><span class="p">,</span> <span class="n">Token</span><span class="o">*</span> <span class="n">tok</span><span class="p">){</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">node</span><span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">tok</span><span class="p">);</span>

  <span class="k">for</span><span class="p">(;;){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">equal</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">"+"</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">node</span> <span class="o">=</span> <span class="n">new_binary</span><span class="p">(</span><span class="n">ND_ADD</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">mul</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">));</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span><span class="p">(</span><span class="n">equal</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">"-"</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">node</span> <span class="o">=</span> <span class="n">new_binary</span><span class="p">(</span><span class="n">ND_SUB</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">mul</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">));</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="o">*</span><span class="n">rest</span> <span class="o">=</span> <span class="n">tok</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">node</span><span class="p">;</span>

  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// expr = primary ("*" primary | "/" primary)*</span>
<span class="k">static</span> <span class="n">Node</span><span class="o">*</span> <span class="nf">mul</span><span class="p">(</span><span class="n">Token</span><span class="o">**</span><span class="n">rest</span><span class="p">,</span> <span class="n">Token</span><span class="o">*</span> <span class="n">tok</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">primary</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">tok</span><span class="p">);</span>

  <span class="k">for</span><span class="p">(;;)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">equal</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">"*"</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">node</span> <span class="o">=</span>  <span class="n">new_binary</span><span class="p">(</span><span class="n">ND_MUL</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">primary</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">));</span>
      <span class="k">continue</span><span class="p">;;</span>
    <span class="p">}</span>

    <span class="k">if</span><span class="p">(</span><span class="n">equal</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">"/"</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">node</span> <span class="o">=</span> <span class="n">new_binary</span><span class="p">(</span><span class="n">ND_DIV</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">primary</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">));</span>
      <span class="k">continue</span><span class="p">;;</span>
    <span class="p">}</span>

    <span class="o">*</span><span class="n">rest</span> <span class="o">=</span> <span class="n">tok</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// primary = "(" expr ")" | num</span>
<span class="k">static</span> <span class="n">Node</span><span class="o">*</span> <span class="nf">primary</span><span class="p">(</span><span class="n">Token</span> <span class="o">**</span><span class="n">rest</span><span class="p">,</span> <span class="n">Token</span><span class="o">*</span> <span class="n">tok</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="n">equal</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">"("</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">expr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
    <span class="o">*</span><span class="n">rest</span> <span class="o">=</span> <span class="n">skip</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">")"</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span><span class="p">(</span><span class="n">tok</span><span class="o">-&gt;</span><span class="n">kind</span>  <span class="o">==</span> <span class="n">TK_NUM</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">new_num</span><span class="p">(</span><span class="n">tok</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
    <span class="o">*</span><span class="n">rest</span> <span class="o">=</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">error_tok</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">"expected an expression"</span><span class="p">);</span>

<span class="p">}</span>
</code></pre></div></div> <h2 id="order-of-parser-is-important">order of parser is important</h2> <p>The order of operations in the code snippet you provided is crucial for correctly evaluating the expression represented by the abstract syntax tree (AST). Let’s go through the code step-by-step:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">gen_expr</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">rhs</span><span class="p">);</span>
<span class="n">push</span><span class="p">();</span>
<span class="n">gen_expr</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">lhs</span><span class="p">);</span>
<span class="n">pop</span><span class="p">(</span><span class="s">"%rdi"</span><span class="p">);</span>
</code></pre></div></div> <ol> <li><strong>Evaluate the Right Subtree</strong>: <code class="language-plaintext highlighter-rouge">gen_expr(node-&gt;rhs);</code> <ul> <li>This recursively generates code for the right-hand side expression of the current node. The result of this expression is expected to be in the <code class="language-plaintext highlighter-rouge">%rax</code> register.</li> </ul> </li> <li><strong>Push the Result of the Right Subtree</strong>: <code class="language-plaintext highlighter-rouge">push();</code> <ul> <li>The value in <code class="language-plaintext highlighter-rouge">%rax</code> (which is the result of the right-hand side expression) is pushed onto the stack. This saves the result so that the <code class="language-plaintext highlighter-rouge">%rax</code> register can be used for other purposes.</li> </ul> </li> <li><strong>Evaluate the Left Subtree</strong>: <code class="language-plaintext highlighter-rouge">gen_expr(node-&gt;lhs);</code> <ul> <li>This recursively generates code for the left-hand side expression of the current node. The result of this expression is also expected to be in the <code class="language-plaintext highlighter-rouge">%rax</code> register.</li> </ul> </li> <li><strong>Pop the Saved Right Subtree Result</strong>: <code class="language-plaintext highlighter-rouge">pop("%rdi");</code> <ul> <li>The value that was previously pushed onto the stack (the result of the right-hand side expression) is popped into the <code class="language-plaintext highlighter-rouge">%rdi</code> register.</li> </ul> </li> </ol> <p>The reason for this specific order is to ensure that the values of the left and right subtrees are correctly placed in the registers for further operations. By convention, the result of the left subtree is left in <code class="language-plaintext highlighter-rouge">%rax</code>, and the result of the right subtree is placed in <code class="language-plaintext highlighter-rouge">%rdi</code>. This is a common calling convention for binary operations where the left operand is in <code class="language-plaintext highlighter-rouge">%rax</code> and the right operand is in <code class="language-plaintext highlighter-rouge">%rdi</code>.</p> <p>This order of operations is necessary because the code generator needs to follow the calling convention and ensure that the values are in the correct registers before performing the operation represented by the current node. The <code class="language-plaintext highlighter-rouge">push</code> and <code class="language-plaintext highlighter-rouge">pop</code> operations are used to temporarily save and restore the values to maintain the correct evaluation order and register usage.</p> <h2 id="quotient-and-remainder-in-division">quotient and remainder in division</h2> <p>The <strong>quotient</strong> and <strong>remainder</strong> are the results of a division operation. The quotient is the number of times the divisor fits into the dividend, and the remainder is what’s left over after the division.</p> <p>Here’s a simple example to illustrate:</p> <p>Let’s say we want to divide 17 by 5:</p> <ul> <li><strong>Dividend</strong>: 17</li> <li><strong>Divisor</strong>: 5</li> </ul> <p>When we divide 17 by 5, we get:</p> <ul> <li><strong>Quotient</strong>: 3 (because 5 fits into 17 three times)</li> <li><strong>Remainder</strong>: 2 (because after taking away 15, which is 5 times 3, from 17, we have 2 left over)</li> </ul> <p>So, in mathematical terms: [ 17 \div 5 = 3 \text{ remainder } 2 ]</p> <p>In the context of the <code class="language-plaintext highlighter-rouge">idiv</code> instruction in assembly language:</p> <ul> <li>The quotient is stored in the <code class="language-plaintext highlighter-rouge">%rax</code> register.</li> <li>The remainder is stored in the <code class="language-plaintext highlighter-rouge">%rdx</code> register.</li> </ul> <p>This is how the division operation works at a fundamental level, and it’s the same concept used in assembly language for the <code class="language-plaintext highlighter-rouge">idiv</code> instruction. The <code class="language-plaintext highlighter-rouge">idiv</code> instruction performs a division and stores the quotient and remainder in the appropriate registers.</p>]]></content><author><name></name></author><category term="compiler"/><category term="c"/><category term="compiler"/><summary type="html"><![CDATA[Once we have the tokenize we can then write parser code to generate abstract syntax tree by traversing the token list. We use stack to generate tree.]]></summary></entry><entry><title type="html">Python pyplot trick</title><link href="https://bilyz98.github.io/blog/2024/python-plot-trick/" rel="alternate" type="text/html" title="Python pyplot trick"/><published>2024-09-20T11:59:00+00:00</published><updated>2024-09-20T11:59:00+00:00</updated><id>https://bilyz98.github.io/blog/2024/python-plot-trick</id><content type="html" xml:base="https://bilyz98.github.io/blog/2024/python-plot-trick/"><![CDATA[<p>grey line for y axis.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import matplotlib.pyplot as plt

# Create a plot
plt.figure()

# Add solid horizontal lines with light grey color at y = 20, y = 40, y = 60
plt.axhline(y=20, color='lightgrey', linestyle='-')
plt.axhline(y=40, color='lightgrey', linestyle='-')
plt.axhline(y=60, color='lightgrey', linestyle='-')

# Display the plot
plt.show()

</code></pre></div></div> <p>At the back of the bar chart</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import matplotlib.pyplot as plt
import numpy as np

# Sample data for bar chart
x = np.arange(5)
y = [10, 30, 50, 70, 90]

# Create a plot
fig, ax = plt.subplots()

# Plot the bar chart
ax.bar(x, y)

# Add solid horizontal lines with light grey color at y = 20, y = 40, y = 60
ax.axhline(y=20, color='lightgrey', linestyle='-', zorder=0)
ax.axhline(y=40, color='lightgrey', linestyle='-', zorder=0)
ax.axhline(y=60, color='lightgrey', linestyle='-', zorder=0)

# Display the plot
plt.show()

</code></pre></div></div>]]></content><author><name></name></author><category term="python"/><category term="python"/><summary type="html"><![CDATA[grey line for y axis. ``` import matplotlib.pyplot as plt]]></summary></entry><entry><title type="html">Python capture function print output</title><link href="https://bilyz98.github.io/blog/2024/capture-output-python/" rel="alternate" type="text/html" title="Python capture function print output"/><published>2024-08-24T11:59:00+00:00</published><updated>2024-08-24T11:59:00+00:00</updated><id>https://bilyz98.github.io/blog/2024/capture-output-python</id><content type="html" xml:base="https://bilyz98.github.io/blog/2024/capture-output-python/"><![CDATA[<p>You can redirect the output of the <code class="language-plaintext highlighter-rouge">print</code> function to a string in Python using the <code class="language-plaintext highlighter-rouge">io.StringIO</code> class from the <code class="language-plaintext highlighter-rouge">io</code> module. Here’s a simple example to demonstrate how you can achieve this:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">io</span>
<span class="kn">import</span> <span class="n">sys</span>

<span class="k">def</span> <span class="nf">capture_print_output</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="c1"># Create a StringIO object to capture the output
</span>    <span class="n">captured_output</span> <span class="o">=</span> <span class="n">io</span><span class="p">.</span><span class="nc">StringIO</span><span class="p">()</span>
    <span class="c1"># Redirect sys.stdout to the StringIO object
</span>    <span class="n">sys</span><span class="p">.</span><span class="n">stdout</span> <span class="o">=</span> <span class="n">captured_output</span>
    
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Call the function with the provided arguments
</span>        <span class="nf">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="c1"># Reset sys.stdout to its original value
</span>        <span class="n">sys</span><span class="p">.</span><span class="n">stdout</span> <span class="o">=</span> <span class="n">sys</span><span class="p">.</span><span class="n">__stdout__</span>
    
    <span class="c1"># Get the captured output as a string
</span>    <span class="k">return</span> <span class="n">captured_output</span><span class="p">.</span><span class="nf">getvalue</span><span class="p">()</span>

<span class="c1"># Example function that prints something
</span><span class="k">def</span> <span class="nf">example_function</span><span class="p">():</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Hello, World!</span><span class="sh">"</span><span class="p">)</span>

<span class="c1"># Capture the output of the example_function
</span><span class="n">output</span> <span class="o">=</span> <span class="nf">capture_print_output</span><span class="p">(</span><span class="n">example_function</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Captured Output:</span><span class="sh">"</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
</code></pre></div></div> <p>In this example:</p> <ol> <li>We create a <code class="language-plaintext highlighter-rouge">StringIO</code> object to capture the output.</li> <li>We redirect <code class="language-plaintext highlighter-rouge">sys.stdout</code> to the <code class="language-plaintext highlighter-rouge">StringIO</code> object.</li> <li>We call the function whose output we want to capture.</li> <li>We reset <code class="language-plaintext highlighter-rouge">sys.stdout</code> to its original value.</li> <li>We retrieve the captured output as a string using the <code class="language-plaintext highlighter-rouge">getvalue()</code> method.</li> </ol> <p>Feel free to adapt this code to fit your specific needs! If you have any other questions or need further assistance, just let me know.</p> <p>Source: Conversation with Copilot, 8/26/2024 (1) How can I redirect print output of a function in python. https://stackoverflow.com/questions/14197009/how-can-i-redirect-print-%20%20output-of-a-function-in-python%20/%2014197079. (2) How do I redirect output of multiple functions to string or stdout in …. https://stackoverflow.com/questions/64199833/how-do-i-redirect-output-of-multiple-functions-to-string-or-stdout-in-python-t. (3) How to assign Print output to a Variable in Python | bobbyhadz. https://bobbyhadz.com/blog/python-assign-string-output-to-variable. (4) Python 101: Redirecting stdout - Mouse Vs Python. https://www.blog.pythonlibrary.org/2016/06/16/python-101-redirecting-stdout/.</p>]]></content><author><name></name></author><category term="python"/><category term="python"/><summary type="html"><![CDATA[You can redirect the output of the print function to a string in Python using the io.StringIO class from the io module. Here’s a simple example to demonstrate how you can achieve this:]]></summary></entry><entry><title type="html">Simple lru cache cpp implementation</title><link href="https://bilyz98.github.io/blog/2024/lru-cache/" rel="alternate" type="text/html" title="Simple lru cache cpp implementation"/><published>2024-08-24T11:59:00+00:00</published><updated>2024-08-24T11:59:00+00:00</updated><id>https://bilyz98.github.io/blog/2024/lru-cache</id><content type="html" xml:base="https://bilyz98.github.io/blog/2024/lru-cache/"><![CDATA[<p>Use std::list and std::map</p> <p>To get more low level. One should implement list himself/herself.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cassert&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;list&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Cache</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Cache</span><span class="p">(</span><span class="kt">int</span> <span class="n">cap</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cap_</span> <span class="o">=</span> <span class="n">cap</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kt">int</span> <span class="nf">get</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">map_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">!=</span> <span class="n">map_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
      <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">map_</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
      <span class="n">moveToFront</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">value</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

  <span class="p">}</span>

  <span class="kt">void</span> <span class="nf">put</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">map_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">!=</span> <span class="n">map_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">moveToFront</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">items_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">cap_</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// remove the tail key from list and map</span>
      <span class="kt">int</span> <span class="n">tail_key</span> <span class="o">=</span> <span class="n">items_</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">second</span><span class="p">;</span>
      <span class="k">auto</span> <span class="n">tail_key_iter</span> <span class="o">=</span> <span class="n">map_</span><span class="p">[</span><span class="n">tail_key</span><span class="p">];</span> 
      <span class="c1">// does the order matter?</span>
      <span class="n">map_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">tail_key</span><span class="p">);</span>
      <span class="c1">// items_.erase(tail_key_iter);</span>
      <span class="n">items_</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">items_</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">));</span>
    <span class="n">map_</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">items_</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
  <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="kt">void</span> <span class="nf">moveToFront</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">items_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">map_</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span>
    <span class="n">items_</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">));</span>
    <span class="c1">// map_.insert(std::make_pair(key, items_.begin()));</span>
    <span class="n">map_</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">items_</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="kt">int</span> <span class="n">cap_</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">items_</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;::</span><span class="n">iterator</span><span class="o">&gt;</span> <span class="n">map_</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">cache</span> <span class="o">=</span>   <span class="n">Cache</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
  <span class="n">cache</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span> <span class="p">);</span>
  <span class="n">cache</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span> <span class="p">);</span>
  <span class="n">cache</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">cache</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">cache</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">cache</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">);</span>

  <span class="n">cache</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">cache</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

  <span class="n">assert</span><span class="p">(</span><span class="n">cache</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">);</span>
  <span class="n">cache</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">cache</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"OK</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

<span class="p">}</span>
</code></pre></div></div> <h3 id="cpp-constructor">Cpp constructor</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">LRUCache</span><span class="o">::</span><span class="n">LRUCache</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">capacity</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_shard_bits</span><span class="p">,</span>
                   <span class="kt">bool</span> <span class="n">strict_capacity_limit</span><span class="p">,</span> <span class="kt">double</span> <span class="n">high_pri_pool_ratio</span><span class="p">,</span>
                   <span class="kt">double</span> <span class="n">low_pri_pool_ratio</span><span class="p">,</span>
                   <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">MemoryAllocator</span><span class="o">&gt;</span> <span class="n">allocator</span><span class="p">,</span>
                   <span class="kt">bool</span> <span class="n">use_adaptive_mutex</span><span class="p">,</span>
                   <span class="n">CacheMetadataChargePolicy</span> <span class="n">metadata_charge_policy</span><span class="p">,</span>
                   <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">SecondaryCache</span><span class="o">&gt;</span> <span class="n">_secondary_cache</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">ShardedCache</span><span class="p">(</span><span class="n">capacity</span><span class="p">,</span> <span class="n">num_shard_bits</span><span class="p">,</span> <span class="n">strict_capacity_limit</span><span class="p">,</span>
                   <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">allocator</span><span class="p">)),</span>
      <span class="n">secondary_cache_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">_secondary_cache</span><span class="p">))</span> <span class="p">{</span>
  <span class="kt">size_t</span> <span class="n">per_shard</span> <span class="o">=</span> <span class="n">GetPerShardCapacity</span><span class="p">();</span>
  <span class="n">SecondaryCache</span><span class="o">*</span> <span class="n">secondary_cache</span> <span class="o">=</span> <span class="n">secondary_cache_</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
  <span class="n">MemoryAllocator</span><span class="o">*</span> <span class="n">alloc</span> <span class="o">=</span> <span class="n">memory_allocator</span><span class="p">();</span>
  <span class="n">InitShards</span><span class="p">([</span><span class="o">=</span><span class="p">](</span><span class="n">LRUCacheShard</span><span class="o">*</span> <span class="n">cs</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">new</span> <span class="p">(</span><span class="n">cs</span><span class="p">)</span> <span class="n">LRUCacheShard</span><span class="p">(</span>
        <span class="n">per_shard</span><span class="p">,</span> <span class="n">strict_capacity_limit</span><span class="p">,</span> <span class="n">high_pri_pool_ratio</span><span class="p">,</span>
        <span class="n">low_pri_pool_ratio</span><span class="p">,</span> <span class="n">use_adaptive_mutex</span><span class="p">,</span> <span class="n">metadata_charge_policy</span><span class="p">,</span>
        <span class="cm">/* max_upper_hash_bits */</span> <span class="mi">32</span> <span class="o">-</span> <span class="n">num_shard_bits</span><span class="p">,</span> <span class="n">alloc</span><span class="p">,</span> <span class="n">secondary_cache</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">[=]</code> is capture clause and it’s used forthe lambda function to to capture all local variables by value.</p> <p>Lambda function makes a copy of each variable so updating variables inside the lambda does not affect the original variables outside the lambda.</p> <h3 id="lru-cache-in-rocksdb">lru cache in rocksdb</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Status</span> <span class="n">LRUCacheShard</span><span class="o">::</span><span class="n">Insert</span><span class="p">(</span><span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">hash</span><span class="p">,</span>
                             <span class="n">Cache</span><span class="o">::</span><span class="n">ObjectPtr</span> <span class="n">value</span><span class="p">,</span>
                             <span class="k">const</span> <span class="n">Cache</span><span class="o">::</span><span class="n">CacheItemHelper</span><span class="o">*</span> <span class="n">helper</span><span class="p">,</span>
                             <span class="kt">size_t</span> <span class="n">charge</span><span class="p">,</span> <span class="n">LRUHandle</span><span class="o">**</span> <span class="n">handle</span><span class="p">,</span>
                             <span class="n">Cache</span><span class="o">::</span><span class="n">Priority</span> <span class="n">priority</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">helper</span><span class="p">);</span>

  <span class="c1">// Allocate the memory here outside of the mutex.</span>
  <span class="c1">// If the cache is full, we'll have to release it.</span>
  <span class="c1">// It shouldn't happen very often though.</span>
  <span class="n">LRUHandle</span><span class="o">*</span> <span class="n">e</span> <span class="o">=</span>
      <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">LRUHandle</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">LRUHandle</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">key</span><span class="p">.</span><span class="n">size</span><span class="p">()));</span>

  <span class="n">e</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
  <span class="n">e</span><span class="o">-&gt;</span><span class="n">m_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">e</span><span class="o">-&gt;</span><span class="n">im_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">e</span><span class="o">-&gt;</span><span class="n">helper</span> <span class="o">=</span> <span class="n">helper</span><span class="p">;</span>
  <span class="n">e</span><span class="o">-&gt;</span><span class="n">key_length</span> <span class="o">=</span> <span class="n">key</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
  <span class="n">e</span><span class="o">-&gt;</span><span class="n">hash</span> <span class="o">=</span> <span class="n">hash</span><span class="p">;</span>
  <span class="n">e</span><span class="o">-&gt;</span><span class="n">refs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">e</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
  <span class="n">e</span><span class="o">-&gt;</span><span class="n">SetInCache</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
  <span class="n">e</span><span class="o">-&gt;</span><span class="n">SetPriority</span><span class="p">(</span><span class="n">priority</span><span class="p">);</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">key_data</span><span class="p">,</span> <span class="n">key</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">key</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
  <span class="n">e</span><span class="o">-&gt;</span><span class="n">CalcTotalCharge</span><span class="p">(</span><span class="n">charge</span><span class="p">,</span> <span class="n">metadata_charge_policy_</span><span class="p">);</span>

  <span class="c1">// value == nullptr is reserved for indicating failure for when secondary</span>
  <span class="c1">// cache compatible</span>
  <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">IsSecondaryCacheCompatible</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">value</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">));</span>

  <span class="k">return</span> <span class="n">InsertItem</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">handle</span><span class="p">,</span> <span class="cm">/* free_handle_on_fail */</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Status</span> <span class="n">LRUCacheShard</span><span class="o">::</span><span class="n">InsertItem</span><span class="p">(</span><span class="n">LRUHandle</span><span class="o">*</span> <span class="n">e</span><span class="p">,</span> <span class="n">LRUHandle</span><span class="o">**</span> <span class="n">handle</span><span class="p">,</span>
                                 <span class="kt">bool</span> <span class="n">free_handle_on_fail</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Status</span> <span class="n">s</span> <span class="o">=</span> <span class="n">Status</span><span class="o">::</span><span class="n">OK</span><span class="p">();</span>
  <span class="n">autovector</span><span class="o">&lt;</span><span class="n">LRUHandle</span><span class="o">*&gt;</span> <span class="n">last_reference_list</span><span class="p">;</span>

  <span class="p">{</span>
    <span class="n">DMutexLock</span> <span class="n">l</span><span class="p">(</span><span class="n">mutex_</span><span class="p">);</span>

    <span class="c1">// Free the space following strict LRU policy until enough space</span>
    <span class="c1">// is freed or the lru list is empty.</span>
    <span class="n">EvictFromLRU</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">total_charge</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">last_reference_list</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">usage_</span> <span class="o">+</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">total_charge</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">capacity_</span> <span class="o">&amp;&amp;</span>
        <span class="p">(</span><span class="n">strict_capacity_limit_</span> <span class="o">||</span> <span class="n">handle</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">e</span><span class="o">-&gt;</span><span class="n">SetInCache</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">handle</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Don't insert the entry but still return ok, as if the entry inserted</span>
        <span class="c1">// into cache and get evicted immediately.</span>
        <span class="n">last_reference_list</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">free_handle_on_fail</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">free</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
          <span class="o">*</span><span class="n">handle</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">Status</span><span class="o">::</span><span class="n">MemoryLimit</span><span class="p">(</span><span class="s">"Insert failed due to LRU cache being full."</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// Insert into the cache. Note that the cache might get larger than its</span>
      <span class="c1">// capacity if not enough space was freed up.</span>
      <span class="n">LRUHandle</span><span class="o">*</span> <span class="n">old</span> <span class="o">=</span> <span class="n">table_</span><span class="p">.</span><span class="n">Insert</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
      <span class="n">usage_</span> <span class="o">+=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">total_charge</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">old</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">Status</span><span class="o">::</span><span class="n">OkOverwritten</span><span class="p">();</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">InCache</span><span class="p">());</span>
        <span class="n">old</span><span class="o">-&gt;</span><span class="n">SetInCache</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">HasRefs</span><span class="p">())</span> <span class="p">{</span>
          <span class="c1">// old is on LRU because it's in cache and its reference count is 0.</span>
          <span class="n">LRU_Remove</span><span class="p">(</span><span class="n">old</span><span class="p">);</span>
          <span class="n">assert</span><span class="p">(</span><span class="n">usage_</span> <span class="o">&gt;=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">total_charge</span><span class="p">);</span>
          <span class="n">usage_</span> <span class="o">-=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">total_charge</span><span class="p">;</span>
          <span class="n">last_reference_list</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">old</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">handle</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">LRU_Insert</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// If caller already holds a ref, no need to take one here.</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">HasRefs</span><span class="p">())</span> <span class="p">{</span>
          <span class="n">e</span><span class="o">-&gt;</span><span class="n">Ref</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="o">*</span><span class="n">handle</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">TryInsertIntoSecondaryCache</span><span class="p">(</span><span class="n">last_reference_list</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="cpp"/><category term="cpp"/><category term="programming"/><summary type="html"><![CDATA[Use std::list and std::map]]></summary></entry><entry><title type="html">LightGBM dataset</title><link href="https://bilyz98.github.io/blog/2024/lightgbm-dataset/" rel="alternate" type="text/html" title="LightGBM dataset"/><published>2024-08-23T11:59:00+00:00</published><updated>2024-08-23T11:59:00+00:00</updated><id>https://bilyz98.github.io/blog/2024/lightgbm-dataset</id><content type="html" xml:base="https://bilyz98.github.io/blog/2024/lightgbm-dataset/"><![CDATA[<h2 id="early-stop-of-lightgbm-training">Early stop of lightgbm training</h2> <p>The function <code class="language-plaintext highlighter-rouge">LGBM_BoosterGetEval</code> itself does not directly affect the early stopping mechanism of <code class="language-plaintext highlighter-rouge">LGBM_BoosterUpdateOneIter</code>. However, it plays a crucial role in the process by providing the evaluation results needed to determine whether early stopping should occur.</p> <p>Here’s how it works:</p> <ol> <li> <p><strong>Evaluation Metrics</strong>: During training, <code class="language-plaintext highlighter-rouge">LGBM_BoosterUpdateOneIter</code> updates the model for one iteration. After each iteration, <code class="language-plaintext highlighter-rouge">LGBM_BoosterGetEval</code> can be used to retrieve the evaluation metrics (e.g., RMSE, accuracy) for the training and validation datasets.</p> </li> <li> <p><strong>Early Stopping Criteria</strong>: Early stopping is typically based on the performance of the model on the validation dataset. If the evaluation metric does not improve for a specified number of rounds (stopping rounds), training is stopped early to prevent overfitting.</p> </li> <li> <p><strong>Implementation</strong>: In practice, after each call to <code class="language-plaintext highlighter-rouge">LGBM_BoosterUpdateOneIter</code>, you would use <code class="language-plaintext highlighter-rouge">LGBM_BoosterGetEval</code> to get the current evaluation metric. You then compare this metric to the best metric observed so far. If there is no improvement for a certain number of iterations, you trigger early stopping.</p> </li> </ol> <p>Here’s a simplified example in C++:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;LightGBM/c_api.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Initialize datasets and booster (similar to previous example)</span>
    <span class="c1">// ...</span>

    <span class="kt">int</span> <span class="n">stopping_rounds</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">num_iterations</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">best_eval_result</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">rounds_without_improvement</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_iterations</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">LGBM_BoosterUpdateOneIter</span><span class="p">(</span><span class="n">booster</span><span class="p">);</span>

        <span class="c1">// Get evaluation result</span>
        <span class="kt">double</span> <span class="n">eval_result</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">out_len</span><span class="p">;</span>
        <span class="n">LGBM_BoosterGetEval</span><span class="p">(</span><span class="n">booster</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">out_len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eval_result</span><span class="p">);</span> <span class="c1">// Assuming 1 is the index for validation data</span>

        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Iteration "</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">": RMSE = "</span> <span class="o">&lt;&lt;</span> <span class="n">eval_result</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

        <span class="c1">// Check for early stopping</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">eval_result</span> <span class="o">&lt;</span> <span class="n">best_eval_result</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">best_eval_result</span> <span class="o">=</span> <span class="n">eval_result</span><span class="p">;</span>
            <span class="n">rounds_without_improvement</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">rounds_without_improvement</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">rounds_without_improvement</span> <span class="o">&gt;=</span> <span class="n">stopping_rounds</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Early stopping at iteration "</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Save model and free memory (similar to previous example)</span>
    <span class="c1">// ...</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>In this example, <code class="language-plaintext highlighter-rouge">LGBM_BoosterGetEval</code> is used to retrieve the evaluation metric after each iteration, and the early stopping logic is implemented based on the retrieved metric¹². If the evaluation metric does not improve for <code class="language-plaintext highlighter-rouge">stopping_rounds</code> consecutive iterations, training is stopped early.</p> <p>If you have any more questions or need further clarification, feel free to ask!</p> <p>Source: Conversation with Copilot, 8/24/2024 (1) C API — LightGBM 4.5.0.99 documentation - Read the Docs. https://lightgbm.readthedocs.io/en/latest/C-API.html. (2) lightgbm.early_stopping — LightGBM 4.5.0.99 documentation - Read the Docs. https://lightgbm.readthedocs.io/en/latest/pythonapi/lightgbm.early_stopping.html.</p> <h2 id="split-lightgbm-dataset">Split lightgbm dataset</h2> <p>Yes, you can split a LightGBM dataset object into training and evaluation datasets. Here’s an example in C++:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;LightGBM/c_api.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;random&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Load the full dataset</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">data_path</span> <span class="o">=</span> <span class="s">"full_data.txt"</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">params</span> <span class="o">=</span> <span class="s">"objective=regression metric=rmse"</span><span class="p">;</span>
    <span class="n">DatasetHandle</span> <span class="n">full_data</span><span class="p">;</span>
    <span class="n">LGBM_DatasetCreateFromFile</span><span class="p">(</span><span class="n">data_path</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">full_data</span><span class="p">);</span>

    <span class="c1">// Get the number of data points</span>
    <span class="kt">int</span> <span class="n">num_data</span><span class="p">;</span>
    <span class="n">LGBM_DatasetGetNumData</span><span class="p">(</span><span class="n">full_data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num_data</span><span class="p">);</span>

    <span class="c1">// Split indices into training and evaluation sets</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">indices</span><span class="p">(</span><span class="n">num_data</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">iota</span><span class="p">(</span><span class="n">indices</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">indices</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shuffle</span><span class="p">(</span><span class="n">indices</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">indices</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">mt19937</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">random_device</span><span class="p">{}()});</span>

    <span class="kt">int</span> <span class="n">train_size</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">0.8</span> <span class="o">*</span> <span class="n">num_data</span><span class="p">);</span> <span class="c1">// 80% for training</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">train_indices</span><span class="p">(</span><span class="n">indices</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">indices</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">train_size</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">eval_indices</span><span class="p">(</span><span class="n">indices</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">train_size</span><span class="p">,</span> <span class="n">indices</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

    <span class="c1">// Create training and evaluation datasets</span>
    <span class="n">DatasetHandle</span> <span class="n">train_data</span><span class="p">;</span>
    <span class="n">DatasetHandle</span> <span class="n">eval_data</span><span class="p">;</span>
    <span class="n">LGBM_DatasetCreateSubset</span><span class="p">(</span><span class="n">full_data</span><span class="p">,</span> <span class="n">train_indices</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">train_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">train_data</span><span class="p">);</span>
    <span class="n">LGBM_DatasetCreateSubset</span><span class="p">(</span><span class="n">full_data</span><span class="p">,</span> <span class="n">eval_indices</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">num_data</span> <span class="o">-</span> <span class="n">train_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eval_data</span><span class="p">);</span>

    <span class="c1">// Create booster</span>
    <span class="n">BoosterHandle</span> <span class="n">booster</span><span class="p">;</span>
    <span class="n">LGBM_BoosterCreate</span><span class="p">(</span><span class="n">train_data</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">booster</span><span class="p">);</span>

    <span class="c1">// Train model</span>
    <span class="kt">int</span> <span class="n">num_iterations</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_iterations</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">LGBM_BoosterUpdateOneIter</span><span class="p">(</span><span class="n">booster</span><span class="p">);</span>

        <span class="c1">// Evaluate model</span>
        <span class="kt">double</span> <span class="n">eval_result</span><span class="p">;</span>
        <span class="n">LGBM_BoosterGetEval</span><span class="p">(</span><span class="n">booster</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eval_result</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Iteration "</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">": RMSE = "</span> <span class="o">&lt;&lt;</span> <span class="n">eval_result</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Save model</span>
    <span class="n">LGBM_BoosterSaveModel</span><span class="p">(</span><span class="n">booster</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s">"model.txt"</span><span class="p">);</span>

    <span class="c1">// Free memory</span>
    <span class="n">LGBM_DatasetFree</span><span class="p">(</span><span class="n">full_data</span><span class="p">);</span>
    <span class="n">LGBM_DatasetFree</span><span class="p">(</span><span class="n">train_data</span><span class="p">);</span>
    <span class="n">LGBM_DatasetFree</span><span class="p">(</span><span class="n">eval_data</span><span class="p">);</span>
    <span class="n">LGBM_BoosterFree</span><span class="p">(</span><span class="n">booster</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>In this example:</p> <ol> <li>The full dataset is loaded from a file.</li> <li>The dataset is split into training and evaluation sets using a random shuffle.</li> <li>Subsets are created for training and evaluation.</li> <li>A LightGBM booster is created and trained using the training dataset.</li> <li>The model is evaluated on the evaluation dataset during training.</li> </ol> <p>Feel free to adjust the parameters and paths to fit your specific use case. If you have any more questions or need further assistance, let me know!</p> <p>Source: Conversation with Copilot, 8/24/2024 (1) lightgbm.train — LightGBM 4.5.0.99 documentation - Read the Docs. https://lightgbm.readthedocs.io/en/latest/pythonapi/lightgbm.train.html. (2) LightGBM regression example with cross validation and early stop run. https://www.datasciencebyexample.com/2023/04/24/lightgbm-regression-complete-example-with-cross-validation-and-early-stop/. (3) Train a model using LightGBM - GeeksforGeeks. https://www.geeksforgeeks.org/train-a-model-using-lightgbm/. (4) LightGBM - An In-Depth Guide [Python API] - CoderzColumn. https://coderzcolumn.com/tutorials/machine-learning/lightgbm-an-in-depth-guide-python.</p>]]></content><author><name></name></author><category term="ml"/><category term="ml"/><category term="lightgbm"/><summary type="html"><![CDATA[Early stop of lightgbm training The function LGBM_BoosterGetEval itself does not directly affect the early stopping mechanism of LGBM_BoosterUpdateOneIter. However, it plays a crucial role in the process by providing the evaluation results needed to determine whether early stopping should occur.]]></summary></entry><entry><title type="html">calloc and malloc</title><link href="https://bilyz98.github.io/blog/2024/calloc/" rel="alternate" type="text/html" title="calloc and malloc"/><published>2024-08-23T11:59:00+00:00</published><updated>2024-08-23T11:59:00+00:00</updated><id>https://bilyz98.github.io/blog/2024/calloc</id><content type="html" xml:base="https://bilyz98.github.io/blog/2024/calloc/"><![CDATA[<p><code class="language-plaintext highlighter-rouge">calloc</code> and <code class="language-plaintext highlighter-rouge">malloc</code> are both functions in C used for dynamic memory allocation, but they have some key differences.</p> <h3 id="calloc"><code class="language-plaintext highlighter-rouge">calloc</code></h3> <p><code class="language-plaintext highlighter-rouge">calloc</code> stands for “contiguous allocation.” It allocates memory for an array of elements, initializes all bytes to zero, and returns a pointer to the allocated memory.</p> <p><strong>Syntax</strong>:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="o">*</span><span class="nf">calloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">num</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
</code></pre></div></div> <ul> <li><strong>Parameters</strong>: <ul> <li><code class="language-plaintext highlighter-rouge">num</code>: Number of elements.</li> <li><code class="language-plaintext highlighter-rouge">size</code>: Size of each element.</li> </ul> </li> </ul> <h3 id="malloc"><code class="language-plaintext highlighter-rouge">malloc</code></h3> <p><code class="language-plaintext highlighter-rouge">malloc</code> stands for “memory allocation.” It allocates a specified number of bytes of memory and returns a pointer to the allocated memory. However, it does not initialize the memory.</p> <p><strong>Syntax</strong>:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="o">*</span><span class="nf">malloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
</code></pre></div></div> <ul> <li><strong>Parameter</strong>: <ul> <li><code class="language-plaintext highlighter-rouge">size</code>: Number of bytes to allocate.</li> </ul> </li> </ul> <h3 id="key-differences">Key Differences</h3> <ol> <li><strong>Initialization</strong>: <ul> <li><code class="language-plaintext highlighter-rouge">calloc</code>: Initializes the allocated memory to zero.</li> <li><code class="language-plaintext highlighter-rouge">malloc</code>: Does not initialize the allocated memory; it contains garbage values.</li> </ul> </li> <li><strong>Parameters</strong>: <ul> <li><code class="language-plaintext highlighter-rouge">calloc</code>: Takes two parameters (number of elements and size of each element).</li> <li><code class="language-plaintext highlighter-rouge">malloc</code>: Takes one parameter (total number of bytes to allocate).</li> </ul> </li> <li><strong>Usage</strong>: <ul> <li><code class="language-plaintext highlighter-rouge">calloc</code> is useful when you need an array of elements initialized to zero.</li> <li><code class="language-plaintext highlighter-rouge">malloc</code> is useful when you need a block of memory without initialization.</li> </ul> </li> </ol> <h3 id="example">Example</h3> <p>Here’s an example to illustrate the difference:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Using calloc</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">arr1</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">calloc</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span> <span class="c1">// Allocates memory for 5 integers and initializes them to 0</span>

<span class="c1">// Using malloc</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">arr2</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span> <span class="c1">// Allocates memory for 5 integers, but they contain garbage values</span>
</code></pre></div></div> <p>Would you like to see more examples or have any specific questions about these functions?</p>]]></content><author><name></name></author><category term="c"/><category term="c"/><summary type="html"><![CDATA[calloc and malloc are both functions in C used for dynamic memory allocation, but they have some key differences.]]></summary></entry><entry><title type="html">Simple c compiler</title><link href="https://bilyz98.github.io/blog/2024/chibicc-compiler/" rel="alternate" type="text/html" title="Simple c compiler"/><published>2024-08-23T11:59:00+00:00</published><updated>2024-08-23T11:59:00+00:00</updated><id>https://bilyz98.github.io/blog/2024/chibicc-compiler</id><content type="html" xml:base="https://bilyz98.github.io/blog/2024/chibicc-compiler/"><![CDATA[<p>Follow this repo commit history to learn basics of compiler.</p> <p>Very nice repo to compiler tutorial.</p> <p>You can follow the commit history to build a simple c compiler step by step.</p> <p><a href="https://github.com/rui314/chibicc/commits/main/?since=2020-10-01&amp;until=2020-10-27&amp;after=90d1f7f199cc55b13c7fdb5839d1409806633fdb+34">https://github.com/rui314/chibicc/commits/main/?since=2020-10-01&amp;until=2020-10-27&amp;after=90d1f7f199cc55b13c7fdb5839d1409806633fdb+34</a></p> <h2 id="-and---and-number-lexer">+ and - and number lexer</h2> <p>With machine code generation</p> <p>main.c</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;ctype.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdarg.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdbool.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
  <span class="n">TK_PUNCT</span><span class="p">,</span> <span class="c1">// punctuators</span>
  <span class="n">TK_NUM</span><span class="p">,</span> 
  <span class="n">TK_EOF</span><span class="p">,</span>

<span class="p">}</span> <span class="n">TokenKind</span><span class="p">;</span>



<span class="k">typedef</span> <span class="k">struct</span> <span class="n">Token</span> <span class="n">Token</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">Token</span> <span class="p">{</span>
  <span class="n">TokenKind</span> <span class="n">kind</span><span class="p">;</span>
  <span class="n">Token</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">val</span><span class="p">;</span> <span class="c1">// if TokenKind is TK_NUM, its value</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">loc</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">error</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span> <span class="p">{</span>
  <span class="kt">va_list</span> <span class="n">ap</span><span class="p">;</span>
  <span class="n">va_start</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
  <span class="n">vfprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">ap</span><span class="p">);</span> 
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">equal</span><span class="p">(</span><span class="n">Token</span><span class="o">*</span> <span class="n">tok</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">op</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">memcmp</span><span class="p">(</span><span class="n">tok</span><span class="o">-&gt;</span><span class="n">loc</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">op</span><span class="p">[</span><span class="n">tok</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'\0'</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="n">Token</span><span class="o">*</span> <span class="nf">skip</span><span class="p">(</span><span class="n">Token</span><span class="o">*</span> <span class="n">tok</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">equal</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">error</span><span class="p">(</span><span class="s">"expected '%s', cur tok is '%s', len %d"</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">loc</span><span class="p">,</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_number</span><span class="p">(</span><span class="n">Token</span><span class="o">*</span> <span class="n">tok</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="n">tok</span><span class="o">-&gt;</span><span class="n">kind</span> <span class="o">!=</span> <span class="n">TK_NUM</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">error</span><span class="p">(</span><span class="s">"expected a number"</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">Token</span><span class="o">*</span> <span class="nf">new_token</span><span class="p">(</span><span class="n">TokenKind</span> <span class="n">kind</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">start</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Token</span><span class="o">*</span> <span class="n">tok</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Token</span><span class="p">));</span>
  <span class="n">tok</span><span class="o">-&gt;</span><span class="n">kind</span> <span class="o">=</span> <span class="n">kind</span><span class="p">;</span>
  <span class="n">tok</span><span class="o">-&gt;</span><span class="n">loc</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
  <span class="n">tok</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">tok</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="n">Token</span><span class="o">*</span> <span class="nf">tokenize</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Token</span> <span class="n">head</span> <span class="o">=</span> <span class="p">{};</span>
  <span class="n">Token</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">head</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">isspace</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">p</span><span class="o">++</span><span class="p">;</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span><span class="p">(</span><span class="n">isdigit</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">new_token</span><span class="p">(</span><span class="n">TK_NUM</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
      <span class="kt">char</span><span class="o">*</span> <span class="n">q</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
      <span class="n">cur</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">strtoul</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
      <span class="n">cur</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span> <span class="n">q</span><span class="p">;</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">==</span> <span class="sc">'+'</span> <span class="o">||</span> <span class="o">*</span><span class="n">p</span> <span class="o">==</span> <span class="sc">'-'</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">new_token</span><span class="p">(</span><span class="n">TK_PUNCT</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
      <span class="n">p</span><span class="o">++</span><span class="p">;</span>
      <span class="k">continue</span><span class="p">;;</span>
    <span class="p">}</span>

    <span class="n">error</span><span class="p">(</span><span class="s">"invalid token"</span><span class="p">);</span>


  <span class="p">}</span>
  <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">new_token</span><span class="p">(</span><span class="n">TK_EOF</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">head</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>



<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">error</span><span class="p">(</span><span class="s">"%s: invalid number of arguments"</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
  <span class="p">}</span>
  <span class="n">Token</span><span class="o">*</span> <span class="n">tok</span> <span class="o">=</span> <span class="n">tokenize</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"  .globl main</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"main: </span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"  mov $%d, %%rax</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">get_number</span><span class="p">(</span><span class="n">tok</span><span class="p">));</span>
  <span class="n">tok</span> <span class="o">=</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

  <span class="k">while</span><span class="p">(</span><span class="n">tok</span><span class="o">-&gt;</span><span class="n">kind</span> <span class="o">!=</span> <span class="n">TK_EOF</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">equal</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">"+"</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"  add $%d, %%rax</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">get_number</span><span class="p">(</span><span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">));</span>
      <span class="n">tok</span> <span class="o">=</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">tok</span> <span class="o">=</span> <span class="n">skip</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s">"-"</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"  sub $%d, %%rax</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">get_number</span><span class="p">(</span><span class="n">tok</span><span class="p">));</span>
    <span class="n">tok</span> <span class="o">=</span> <span class="n">tok</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"  ret</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span> 


</code></pre></div></div> <p>test.sh</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>

assert<span class="o">()</span> <span class="o">{</span>
  <span class="nv">expected</span><span class="o">=</span><span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span>
  <span class="nv">input</span><span class="o">=</span><span class="s2">"</span><span class="nv">$2</span><span class="s2">"</span>

  ./chibicc <span class="s2">"</span><span class="nv">$input</span><span class="s2">"</span> <span class="o">&gt;</span> tmp.s <span class="o">||</span> <span class="nb">exit
  </span>gcc <span class="nt">-static</span> <span class="nt">-o</span> tmp tmp.s
  ./tmp
  <span class="nv">actual</span><span class="o">=</span><span class="s2">"</span><span class="nv">$?</span><span class="s2">"</span>


  <span class="k">if</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$actual</span><span class="s2">"</span> <span class="o">=</span> <span class="s2">"</span><span class="nv">$expected</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$input</span><span class="s2"> =&gt; </span><span class="nv">$actual</span><span class="s2">"</span>
  <span class="k">else
    </span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$input</span><span class="s2"> =&gt; </span><span class="nv">$expected</span><span class="s2"> expected, but got </span><span class="nv">$actual</span><span class="s2">"</span>
    <span class="nb">exit </span>1

  <span class="k">fi</span>

<span class="o">}</span>

assert 0 0
assert 42 42
assert 21 <span class="s2">"5+20-4"</span>
assert 41 <span class="s2">" 12 + 34 - 5 "</span>

<span class="nb">echo </span>OK
</code></pre></div></div> <p>Makefile</p> <pre><code class="language-Makefile">CFLAGS=-std=c11 -g -fno-common

chibicc: main.o
	$(CC) -o chibicc main.o $(LDFLAGS)

test: chibicc
	./test.sh


clean:
	rm -f chibicc *.o *~ tmp*

.PHONY: test clean

</code></pre>]]></content><author><name></name></author><category term="compiler"/><category term="c"/><category term="compiler"/><summary type="html"><![CDATA[Follow this repo commit history to learn basics of compiler.]]></summary></entry><entry><title type="html">Difference between deep copy and shallow copy in python</title><link href="https://bilyz98.github.io/blog/2024/python-deep-copy/" rel="alternate" type="text/html" title="Difference between deep copy and shallow copy in python"/><published>2024-08-20T11:59:00+00:00</published><updated>2024-08-20T11:59:00+00:00</updated><id>https://bilyz98.github.io/blog/2024/python-deep-copy</id><content type="html" xml:base="https://bilyz98.github.io/blog/2024/python-deep-copy/"><![CDATA[<h3 id="shallow-copy">Shallow Copy</h3> <ul> <li><strong>Definition</strong>: A shallow copy creates a new object, but inserts references into it to the objects found in the original.</li> <li><strong>Behavior</strong>: Only the top-level object is copied. If the original object contains other objects (like lists within lists), the references to these objects are copied, not the objects themselves.</li> <li><strong>Use Case</strong>: Suitable for simple data structures or when you don’t need to copy nested objects.</li> <li><strong>Example</strong>: <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">copy</span>

<span class="n">original</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">4</span><span class="p">]</span>
<span class="n">shallow_copy</span> <span class="o">=</span> <span class="n">copy</span><span class="p">.</span><span class="nf">copy</span><span class="p">(</span><span class="n">original</span><span class="p">)</span>

<span class="n">shallow_copy</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sh">'</span><span class="s">changed</span><span class="sh">'</span>
<span class="nf">print</span><span class="p">(</span><span class="n">original</span><span class="p">)</span>  <span class="c1"># Output: [1, ['changed', 3], 4]
</span></code></pre></div> </div> </li> </ul> <h3 id="deep-copy">Deep Copy</h3> <ul> <li><strong>Definition</strong>: A deep copy creates a new object and recursively copies all objects found in the original.</li> <li><strong>Behavior</strong>: Both the top-level object and all nested objects are copied. Changes to the copied object do not affect the original object.</li> <li><strong>Use Case</strong>: Necessary when you need to copy complex data structures with nested objects.</li> <li><strong>Example</strong>: <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">copy</span>

<span class="n">original</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">4</span><span class="p">]</span>
<span class="n">deep_copy</span> <span class="o">=</span> <span class="n">copy</span><span class="p">.</span><span class="nf">deepcopy</span><span class="p">(</span><span class="n">original</span><span class="p">)</span>

<span class="n">deep_copy</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sh">'</span><span class="s">changed</span><span class="sh">'</span>
<span class="nf">print</span><span class="p">(</span><span class="n">original</span><span class="p">)</span>  <span class="c1"># Output: [1, [2, 3], 4]
</span></code></pre></div> </div> </li> </ul> <h3 id="summary">Summary</h3> <ul> <li><strong>Shallow Copy</strong>: Copies the structure of the object, but not the elements within nested objects.</li> <li><strong>Deep Copy</strong>: Copies the structure and all elements within nested objects, creating a completely independent copy.</li> </ul> <p>Understanding these differences helps you choose the right type of copy for your specific needs. If you have any more questions or need further clarification, feel free to ask!</p>]]></content><author><name></name></author><category term="python"/><summary type="html"><![CDATA[Shallow Copy Definition: A shallow copy creates a new object, but inserts references into it to the objects found in the original. Behavior: Only the top-level object is copied. If the original object contains other objects (like lists within lists), the references to these objects are copied, not the objects themselves. Use Case: Suitable for simple data structures or when you don’t need to copy nested objects. Example: ```python import copy]]></summary></entry></feed>